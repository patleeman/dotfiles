import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { globalWS } from './websocket';
import * as backend from './backend';

// Mock backend module
vi.mock('./backend', () => ({
  getBackendPort: vi.fn(),
}));

describe('GlobalWebSocket', () => {
  let mockWebSocket: any;
  let wsInstances: any[];

  beforeEach(() => {
    wsInstances = [];
    vi.mocked(backend.getBackendPort).mockResolvedValue(8080);

    // Mock WebSocket - use numeric literals to avoid dependency on WebSocket constants
    mockWebSocket = class MockWebSocket {
      static CONNECTING = 0;
      static OPEN = 1;
      static CLOSING = 2;
      static CLOSED = 3;

      url: string;
      readyState: number = 0; // CONNECTING
      onopen: ((event: Event) => void) | null = null;
      onmessage: ((event: MessageEvent) => void) | null = null;
      onclose: ((event: CloseEvent) => void) | null = null;
      onerror: ((event: Event) => void) | null = null;

      constructor(url: string) {
        this.url = url;
        wsInstances.push(this);
        // Simulate async connection
        setTimeout(() => {
          this.readyState = 1; // OPEN
          if (this.onopen) {
            this.onopen(new Event('open'));
          }
        }, 10);
      }

      send(_data: string) {
        // Mock send
      }

      close() {
        this.readyState = 3; // CLOSED
        if (this.onclose) {
          this.onclose(new CloseEvent('close'));
        }
      }
    };

    (globalThis as any).WebSocket = mockWebSocket;

    // Reset the globalWS singleton state after mock is set up
    globalWS._reset();
  });

  afterEach(() => {
    vi.clearAllMocks();
    globalWS._reset();
    wsInstances = [];
  });

  describe('connection', () => {
    it('connects to WebSocket', async () => {
      const ws = await globalWS.connect();
      expect(ws).toBeDefined();
      expect(wsInstances.length).toBe(1);
      expect(wsInstances[0].url).toBe('ws://localhost:8080/api/ws');
    });

    it('returns same connection on subsequent calls', async () => {
      const ws1 = await globalWS.connect();
      const ws2 = await globalWS.connect();
      expect(ws1).toBe(ws2);
      expect(wsInstances.length).toBe(1);
    });

    it('uses correct port from backend', async () => {
      vi.mocked(backend.getBackendPort).mockResolvedValue(9999);
      await globalWS.connect();
      expect(wsInstances[0].url).toBe('ws://localhost:9999/api/ws');
    });
  });

  describe('send', () => {
    it('sends message and receives response', async () => {
      let sentData: any = null;

      // Connect first to create the WebSocket instance
      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      // Now override the send method on the created instance
      wsInstances[0].send = vi.fn((_data: string) => {
        sentData = JSON.parse(_data);
        // Simulate response
        setTimeout(() => {
          const response = {
            request_id: sentData.request_id,
            status: 'ok',
            payload: { result: 'success' },
          };
          if (wsInstances[0].onmessage) {
            wsInstances[0].onmessage({
              data: JSON.stringify(response),
            } as MessageEvent);
          }
        }, 10);
      });

      const result = await globalWS.send({
        type: 'test_request',
        payload: { test: 'data' },
      });

      expect(sentData.type).toBe('test_request');
      expect(sentData.payload.test).toBe('data');
      expect(sentData.request_id).toBeDefined();
      expect(result.result).toBe('success');
    });

    it('handles error responses', async () => {
      // Connect first to create the WebSocket instance
      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      // Now override the send method
      wsInstances[0].send = vi.fn((_data: string) => {
        const sentData = JSON.parse(_data);
        setTimeout(() => {
          const response = {
            request_id: sentData.request_id,
            status: 'error',
            error: 'Something went wrong',
          };
          if (wsInstances[0].onmessage) {
            wsInstances[0].onmessage({
              data: JSON.stringify(response),
            } as MessageEvent);
          }
        }, 10);
      });

      await expect(
        globalWS.send({
          type: 'test_request',
        })
      ).rejects.toThrow('Something went wrong');
    });

    it('generates unique request IDs', async () => {
      const requestIds = new Set<string>();

      // Connect first to create the WebSocket instance
      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      // Now override the send method
      wsInstances[0].send = vi.fn((_data: string) => {
        const sentData = JSON.parse(_data);
        requestIds.add(sentData.request_id);
        setTimeout(() => {
          const response = {
            request_id: sentData.request_id,
            status: 'ok',
            payload: {},
          };
          if (wsInstances[0].onmessage) {
            wsInstances[0].onmessage({
              data: JSON.stringify(response),
            } as MessageEvent);
          }
        }, 10);
      });

      await globalWS.send({ type: 'request1' });
      await globalWS.send({ type: 'request2' });
      await globalWS.send({ type: 'request3' });

      expect(requestIds.size).toBe(3);
    });
  });

  describe('message listeners', () => {
    it('notifies message listeners', async () => {
      const listener = vi.fn();
      const unsubscribe = globalWS.addMessageListener(listener);

      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      const testMessage = { type: 'stream_chunk', content: 'test' };
      if (wsInstances[0] && wsInstances[0].onmessage) {
        wsInstances[0].onmessage({
          data: JSON.stringify(testMessage),
        } as MessageEvent);
      }

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(listener).toHaveBeenCalledWith(testMessage);

      unsubscribe();
    });

    it('allows removing message listeners', async () => {
      const listener = vi.fn();
      const unsubscribe = globalWS.addMessageListener(listener);

      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      unsubscribe();

      const testMessage = { type: 'stream_chunk', content: 'test' };
      if (wsInstances[0] && wsInstances[0].onmessage) {
        wsInstances[0].onmessage({
          data: JSON.stringify(testMessage),
        } as MessageEvent);
      }

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(listener).not.toHaveBeenCalled();
    });

    it('supports multiple message listeners', async () => {
      const listener1 = vi.fn();
      const listener2 = vi.fn();

      globalWS.addMessageListener(listener1);
      globalWS.addMessageListener(listener2);

      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      const testMessage = { type: 'stream_chunk', content: 'test' };
      if (wsInstances[0] && wsInstances[0].onmessage) {
        wsInstances[0].onmessage({
          data: JSON.stringify(testMessage),
        } as MessageEvent);
      }

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(listener1).toHaveBeenCalledWith(testMessage);
      expect(listener2).toHaveBeenCalledWith(testMessage);
    });
  });

  describe('status listeners', () => {
    it('notifies status listeners on connection', async () => {
      const statuses: string[] = [];
      const listener = (status: 'connecting' | 'open' | 'closed' | 'error') => {
        statuses.push(status);
      };

      globalWS.addStatusListener(listener);

      // The connect() call will trigger 'connecting' then 'open'
      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 30));

      expect(statuses).toContain('connecting');
      expect(statuses).toContain('open');
    });

    it('notifies status listeners on close', async () => {
      const statuses: string[] = [];
      const listener = (status: 'connecting' | 'open' | 'closed' | 'error') => {
        statuses.push(status);
      };

      globalWS.addStatusListener(listener);
      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      if (wsInstances[0] && wsInstances[0].onclose) {
        wsInstances[0].onclose(new CloseEvent('close'));
      }

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(statuses).toContain('closed');
    });

    it('allows removing status listeners', () => {
      const listener = vi.fn();
      const unsubscribe = globalWS.addStatusListener(listener);

      unsubscribe();

      // Status changes should not call removed listener
      // (we can't easily test this without triggering actual status changes)
      expect(unsubscribe).toBeDefined();
    });
  });

  describe('reconnection', () => {
    it('reconnects after close', async () => {
      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      const initialInstance = wsInstances[0];
      expect(initialInstance).toBeDefined();

      // Close connection
      if (initialInstance && initialInstance.onclose) {
        initialInstance.onclose(new CloseEvent('close'));
      }

      // Wait for reconnection attempt
      await new Promise((resolve) => setTimeout(resolve, 1100));

      // Should have attempted reconnection (new instance or same instance reopened)
      expect(wsInstances.length).toBeGreaterThanOrEqual(1);
    });

    it('handles connection errors', async () => {
      const statuses: string[] = [];
      const listener = (status: 'connecting' | 'open' | 'closed' | 'error') => {
        statuses.push(status);
      };

      globalWS.addStatusListener(listener);

      // Connect and wait for the instance to be created
      const connectPromise = globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 5));

      // Trigger error on the created instance before it opens
      if (wsInstances[0] && wsInstances[0].onerror) {
        wsInstances[0].onerror(new Event('error'));
      }

      // The connect should reject
      await expect(connectPromise).rejects.toBeDefined();

      expect(statuses).toContain('error');
    });
  });

  describe('pending requests on close', () => {
    it('rejects pending requests when connection closes', async () => {
      // Connect first
      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      // Override send to simulate connection close before response
      wsInstances[0].send = vi.fn(() => {
        // Don't send response, simulate connection close
        setTimeout(() => {
          if (wsInstances[0] && wsInstances[0].onclose) {
            wsInstances[0].onclose(new CloseEvent('close'));
          }
        }, 10);
      });

      await expect(
        globalWS.send({
          type: 'test_request',
        })
      ).rejects.toThrow();
    });
  });

  describe('error handling', () => {
    it('handles invalid JSON in messages', async () => {
      const listener = vi.fn();
      globalWS.addMessageListener(listener);

      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      // Send invalid JSON
      if (wsInstances[0] && wsInstances[0].onmessage) {
        try {
          wsInstances[0].onmessage({
            data: 'invalid json',
          } as MessageEvent);
        } catch (e) {
          // Expected to throw
        }
      }

      // Should not crash
      expect(listener).not.toHaveBeenCalled();
    });
  });
});

