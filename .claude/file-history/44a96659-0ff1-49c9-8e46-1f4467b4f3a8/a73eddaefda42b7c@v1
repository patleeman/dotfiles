#!/bin/bash
#
# Claude Code Task Queue Runner
# Reads tasks from a queue file and executes them sequentially
#

set -e

QUEUE_FILE="${CLAUDE_QUEUE_FILE:-./claude-queue.txt}"
COMPLETED_FILE="${QUEUE_FILE%.txt}-completed.txt"
LOG_DIR="${CLAUDE_QUEUE_LOG_DIR:-./claude-queue-logs}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

usage() {
    cat <<EOF
Claude Code Task Queue Runner

Usage: $0 [command] [options]

Commands:
    run         Process tasks from the queue (default)
    add         Add a task to the queue
    list        List pending tasks
    status      Show queue status
    clear       Clear all pending tasks

Options:
    -f, --file FILE     Queue file path (default: ./claude-queue.txt)
    -h, --help          Show this help message

Environment Variables:
    CLAUDE_QUEUE_FILE       Path to queue file
    CLAUDE_QUEUE_LOG_DIR    Directory for task logs

Examples:
    $0 run                              # Process all tasks
    $0 add "Fix the login bug"          # Add a task
    $0 add -f my-queue.txt "Add tests"  # Add to specific queue
    $0 list                             # Show pending tasks
    $0 status                           # Show queue status
EOF
}

# Ensure queue file exists
ensure_queue_file() {
    if [[ ! -f "$QUEUE_FILE" ]]; then
        touch "$QUEUE_FILE"
        log "Created queue file: $QUEUE_FILE"
    fi
}

# Ensure log directory exists
ensure_log_dir() {
    if [[ ! -d "$LOG_DIR" ]]; then
        mkdir -p "$LOG_DIR"
        log "Created log directory: $LOG_DIR"
    fi
}

# Get the next task from the queue
get_next_task() {
    if [[ ! -f "$QUEUE_FILE" ]]; then
        return 1
    fi
    head -n 1 "$QUEUE_FILE"
}

# Remove the first task from the queue
remove_first_task() {
    if [[ ! -f "$QUEUE_FILE" ]]; then
        return 1
    fi
    local temp_file
    temp_file=$(mktemp)
    tail -n +2 "$QUEUE_FILE" > "$temp_file"
    mv "$temp_file" "$QUEUE_FILE"
}

# Mark a task as completed
mark_completed() {
    local task="$1"
    local status="$2"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$status] $task" >> "$COMPLETED_FILE"
}

# Commit and push changes
commit_and_push() {
    local task="$1"

    # Check if there are any changes to commit
    if git diff --quiet && git diff --staged --quiet; then
        warn "No changes to commit"
        return 0
    fi

    log "Staging all changes..."
    git add -A

    # Create commit message from task (truncate if too long)
    local commit_msg
    commit_msg=$(echo "$task" | head -c 72)
    if [[ ${#task} -gt 72 ]]; then
        commit_msg="${commit_msg}..."
    fi

    log "Committing changes..."
    git commit -m "$commit_msg

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"

    log "Pushing to remote..."
    git push

    success "Changes committed and pushed"
}

# Execute a single task
execute_task() {
    local task="$1"
    local task_num="$2"
    local log_file="$LOG_DIR/task-$(date '+%Y%m%d-%H%M%S')-$task_num.log"

    log "Executing task $task_num: $task"
    log "Log file: $log_file"

    echo "Task: $task" > "$log_file"
    echo "Started: $(date)" >> "$log_file"
    echo "---" >> "$log_file"

    # Run claude with dangerous mode
    if claude --dangerously-skip-permissions -p "$task" 2>&1 | tee -a "$log_file"; then
        echo "---" >> "$log_file"
        echo "Completed: $(date)" >> "$log_file"
        echo "Status: SUCCESS" >> "$log_file"

        success "Task completed successfully"

        # Commit and push
        commit_and_push "$task"

        mark_completed "$task" "SUCCESS"
        return 0
    else
        echo "---" >> "$log_file"
        echo "Completed: $(date)" >> "$log_file"
        echo "Status: FAILED" >> "$log_file"

        error "Task failed"
        mark_completed "$task" "FAILED"
        return 1
    fi
}

# Run all tasks in the queue
run_queue() {
    ensure_queue_file
    ensure_log_dir

    local task_num=0
    local success_count=0
    local fail_count=0

    log "Starting queue processing from: $QUEUE_FILE"

    while true; do
        local task
        task=$(get_next_task)

        # Skip empty lines
        while [[ -n "$task" && "$task" =~ ^[[:space:]]*$ ]]; do
            remove_first_task
            task=$(get_next_task)
        done

        # Skip comment lines (starting with #)
        while [[ -n "$task" && "$task" =~ ^[[:space:]]*# ]]; do
            remove_first_task
            task=$(get_next_task)
        done

        if [[ -z "$task" ]]; then
            break
        fi

        ((task_num++))

        echo ""
        echo "========================================"
        log "Processing task $task_num"
        echo "========================================"

        remove_first_task

        if execute_task "$task" "$task_num"; then
            ((success_count++))
        else
            ((fail_count++))
            warn "Task failed, continuing with next task..."
        fi

        echo ""
    done

    echo ""
    echo "========================================"
    log "Queue processing complete"
    echo "========================================"
    success "Completed: $success_count tasks"
    if [[ $fail_count -gt 0 ]]; then
        error "Failed: $fail_count tasks"
    fi
}

# Add a task to the queue
add_task() {
    local task="$1"
    ensure_queue_file
    echo "$task" >> "$QUEUE_FILE"
    success "Added task: $task"
    log "Queue now has $(wc -l < "$QUEUE_FILE" | tr -d ' ') tasks"
}

# List pending tasks
list_tasks() {
    ensure_queue_file

    if [[ ! -s "$QUEUE_FILE" ]]; then
        log "Queue is empty"
        return 0
    fi

    echo "Pending tasks:"
    echo ""
    local num=1
    while IFS= read -r line; do
        # Skip empty lines and comments
        if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*# && ! "$line" =~ ^[[:space:]]*$ ]]; then
            echo "  $num. $line"
            ((num++))
        fi
    done < "$QUEUE_FILE"
}

# Show queue status
show_status() {
    ensure_queue_file

    local pending=0
    local completed=0
    local failed=0

    # Count pending tasks (non-empty, non-comment lines)
    while IFS= read -r line; do
        if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*# && ! "$line" =~ ^[[:space:]]*$ ]]; then
            ((pending++))
        fi
    done < "$QUEUE_FILE"

    # Count completed tasks
    if [[ -f "$COMPLETED_FILE" ]]; then
        completed=$(grep -c '\[SUCCESS\]' "$COMPLETED_FILE" 2>/dev/null || echo 0)
        failed=$(grep -c '\[FAILED\]' "$COMPLETED_FILE" 2>/dev/null || echo 0)
    fi

    echo "Queue Status"
    echo "============"
    echo "Queue file: $QUEUE_FILE"
    echo ""
    echo "  Pending:   $pending"
    echo "  Completed: $completed"
    echo "  Failed:    $failed"
}

# Clear the queue
clear_queue() {
    ensure_queue_file
    > "$QUEUE_FILE"
    success "Queue cleared"
}

# Parse arguments
COMMAND="run"
TASK_TO_ADD=""

while [[ $# -gt 0 ]]; do
    case $1 in
        run|add|list|status|clear)
            COMMAND="$1"
            shift
            ;;
        -f|--file)
            QUEUE_FILE="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            if [[ "$COMMAND" == "add" ]]; then
                TASK_TO_ADD="$1"
            fi
            shift
            ;;
    esac
done

# Execute command
case $COMMAND in
    run)
        run_queue
        ;;
    add)
        if [[ -z "$TASK_TO_ADD" ]]; then
            error "No task provided"
            echo "Usage: $0 add \"Your task description\""
            exit 1
        fi
        add_task "$TASK_TO_ADD"
        ;;
    list)
        list_tasks
        ;;
    status)
        show_status
        ;;
    clear)
        clear_queue
        ;;
    *)
        error "Unknown command: $COMMAND"
        usage
        exit 1
        ;;
esac
