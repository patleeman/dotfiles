{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":"Design a detailed implementation plan for adding Claude Code/Max subscription authentication to Familiar as a separate provider.\n\n## Context\n\n**Familiar** is a Tauri desktop app with:\n- Go backend in `packages/go-backend`\n- React frontend in `packages/desktop/ui`\n- Config in `~/Library/Application Support/familiar/config.yaml`\n- Credentials in macOS Keychain\n\n**Current Anthropic provider** (`internal/inference/anthropic.go`):\n- Uses API key auth with header `x-api-key`\n- Key stored as `anthropic-api-key` in Keychain\n\n**OpenCode's Claude Max implementation** (for reference):\n- OAuth 2.0 with PKCE flow\n- Client ID: `9d1c250a-e61b-44d9-88ed-5944d1962f5e`\n- Callback: `localhost:54545`\n- Scopes: `org:create_api_key`, `user:profile`, `user:inference`\n- Token stored in `~/.claude/oauth_token.json`\n- Uses Authorization: Bearer header instead of x-api-key\n\n## Requirements\n\n1. **Separate Provider**: Add a new provider called \"claude-code\" or \"claude-max\" that:\n   - Appears as a distinct option in the provider list (alongside Anthropic, OpenAI, etc.)\n   - Uses OAuth subscription auth instead of API key\n   - Can be enabled/disabled like other providers\n\n2. **OAuth Flow**:\n   - Implement OAuth 2.0 PKCE in Go backend\n   - Open browser for authentication\n   - Listen on localhost for callback\n   - Store OAuth tokens securely (Keychain or encrypted file)\n   - Handle token refresh\n\n3. **Settings UI**:\n   - Show \"Claude Code\" as a provider option\n   - Instead of API key input, show \"Connect\" button that triggers OAuth\n   - Show connection status (connected/not connected)\n\n## Key Files to Modify\n\nBackend:\n- `packages/go-backend/internal/inference/anthropic.go` - Reference for API structure\n- `packages/go-backend/internal/config/loader.go` - Config structure\n- `packages/go-backend/internal/config/keychain.go` - Credential storage\n- `packages/go-backend/cmd/server/handlers.go` - WebSocket handlers\n- `packages/go-backend/cmd/server/server.go` - Provider factory\n\nFrontend:\n- `packages/desktop/ui/src/components/Agent/SettingsView.tsx` - Provider settings UI\n- `packages/desktop/ui/src/lib/api.ts` - API calls\n\nPlease provide a step-by-step implementation plan with specific code changes needed."},"uuid":"07df600d-a0e9-4ed4-bfb5-13fe3f57351f","timestamp":"2026-01-03T12:09:19.142Z"}
{"parentUuid":"07df600d-a0e9-4ed4-bfb5-13fe3f57351f","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013C5cSS4spsvHSpsnmM3339","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LXa6Yw5W9AioXvHFK1BdBE","name":"Glob","input":{"pattern":"packages/go-backend/**/*.go","path":"/Users/patrick"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":10650,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":10650,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRHf5FtiMARnp8VL53a","type":"assistant","uuid":"27f0f21c-dd64-44bf-8dc1-e70630c54dc4","timestamp":"2026-01-03T12:09:24.461Z"}
{"parentUuid":"27f0f21c-dd64-44bf-8dc1-e70630c54dc4","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013C5cSS4spsvHSpsnmM3339","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UuD2SUh6uhtsqW4mP5kdHM","name":"Glob","input":{"pattern":"packages/desktop/ui/src/**/*.{ts,tsx}","path":"/Users/patrick"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":10650,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":10650,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRHf5FtiMARnp8VL53a","type":"assistant","uuid":"6178b931-f036-436c-9883-03bc98948422","timestamp":"2026-01-03T12:09:25.136Z"}
{"parentUuid":"6178b931-f036-436c-9883-03bc98948422","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013C5cSS4spsvHSpsnmM3339","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012TQX2CFxuWhiHXBMf2c5UE","name":"Read","input":{"file_path":"/Users/patrick/packages/go-backend/internal/inference/anthropic.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":10650,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":10650,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRHf5FtiMARnp8VL53a","type":"assistant","uuid":"694f1c06-b6e6-4d28-9bcd-7ddeeb599844","timestamp":"2026-01-03T12:09:25.585Z"}
{"parentUuid":"694f1c06-b6e6-4d28-9bcd-7ddeeb599844","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013C5cSS4spsvHSpsnmM3339","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SxHt6TMZQPiDXTXgJzeMtY","name":"Read","input":{"file_path":"/Users/patrick/packages/go-backend/internal/config/loader.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":10650,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":10650,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRHf5FtiMARnp8VL53a","type":"assistant","uuid":"a0316801-c64c-478d-948b-39ef80ab9280","timestamp":"2026-01-03T12:09:25.924Z"}
{"parentUuid":"a0316801-c64c-478d-948b-39ef80ab9280","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013C5cSS4spsvHSpsnmM3339","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U2gSQNPj9UsBTHezzYxgrz","name":"Read","input":{"file_path":"/Users/patrick/packages/go-backend/internal/config/keychain.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":10650,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":10650,"ephemeral_1h_input_tokens":0},"output_tokens":307,"service_tier":"standard"}},"requestId":"req_011CWkRHf5FtiMARnp8VL53a","type":"assistant","uuid":"486d2969-680e-4977-af52-c076e9121db4","timestamp":"2026-01-03T12:09:26.252Z"}
{"parentUuid":"486d2969-680e-4977-af52-c076e9121db4","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File does not exist.</tool_use_error>","is_error":true,"tool_use_id":"toolu_012TQX2CFxuWhiHXBMf2c5UE"}]},"uuid":"d2d60d45-2a5b-49d3-a524-7f01651a2c50","timestamp":"2026-01-03T12:09:26.284Z","toolUseResult":"Error: File does not exist."}
{"parentUuid":"d2d60d45-2a5b-49d3-a524-7f01651a2c50","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File does not exist.</tool_use_error>","is_error":true,"tool_use_id":"toolu_01SxHt6TMZQPiDXTXgJzeMtY"}]},"uuid":"8478d521-d1b0-4c9a-9fa2-92a991ffcfc4","timestamp":"2026-01-03T12:09:26.284Z","toolUseResult":"Error: File does not exist."}
{"parentUuid":"8478d521-d1b0-4c9a-9fa2-92a991ffcfc4","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File does not exist.</tool_use_error>","is_error":true,"tool_use_id":"toolu_01U2gSQNPj9UsBTHezzYxgrz"}]},"uuid":"1b71c5f2-292b-4302-a091-7f9d13187863","timestamp":"2026-01-03T12:09:26.284Z","toolUseResult":"Error: File does not exist."}
{"parentUuid":"1b71c5f2-292b-4302-a091-7f9d13187863","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LXa6Yw5W9AioXvHFK1BdBE","type":"tool_result","content":"No files found"}]},"uuid":"47547265-ff47-4ac0-8b2c-a5142b0cc7c9","timestamp":"2026-01-03T12:09:36.321Z","toolUseResult":{"filenames":[],"durationMs":10017,"numFiles":0,"truncated":false}}
{"parentUuid":"47547265-ff47-4ac0-8b2c-a5142b0cc7c9","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UuD2SUh6uhtsqW4mP5kdHM","type":"tool_result","content":"No files found"}]},"uuid":"4c2529f0-9aaa-4ca4-a0b5-b551019a59af","timestamp":"2026-01-03T12:09:36.324Z","toolUseResult":{"filenames":[],"durationMs":10020,"numFiles":0,"truncated":false}}
{"parentUuid":"4c2529f0-9aaa-4ca4-a0b5-b551019a59af","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01G4NbsEJ72NjLAraTbDMCDQ","type":"message","role":"assistant","content":[{"type":"text","text":"The files don't appear to be in `/Users/patrick`. Let me search for the Familiar project in common locations:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":123,"cache_creation_input_tokens":651,"cache_read_input_tokens":10650,"cache_creation":{"ephemeral_5m_input_tokens":651,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRJvbgVwhaXs4E2puQa","type":"assistant","uuid":"63b4e494-63cc-4119-8c26-4da943dff744","timestamp":"2026-01-03T12:09:42.057Z"}
{"parentUuid":"63b4e494-63cc-4119-8c26-4da943dff744","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01G4NbsEJ72NjLAraTbDMCDQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RGJ1U7biAkoNstPecbhGc1","name":"Bash","input":{"command":"find /Users/patrick -type d -name \"familiar\" 2>/dev/null | head -20","description":"Find familiar project directory"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":123,"cache_creation_input_tokens":651,"cache_read_input_tokens":10650,"cache_creation":{"ephemeral_5m_input_tokens":651,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRJvbgVwhaXs4E2puQa","type":"assistant","uuid":"c841e652-c270-4aa0-98af-164dbd3d7e45","timestamp":"2026-01-03T12:09:42.702Z"}
{"parentUuid":"c841e652-c270-4aa0-98af-164dbd3d7e45","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01G4NbsEJ72NjLAraTbDMCDQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017a52MLUkf8U8yEzyNgvYvn","name":"Bash","input":{"command":"ls -la /Users/patrick/ 2>/dev/null | head -30","description":"List home directory contents"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":123,"cache_creation_input_tokens":651,"cache_read_input_tokens":10650,"cache_creation":{"ephemeral_5m_input_tokens":651,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRJvbgVwhaXs4E2puQa","type":"assistant","uuid":"8b3fc215-2922-4676-825a-aae28ad65c3e","timestamp":"2026-01-03T12:09:43.343Z"}
{"parentUuid":"8b3fc215-2922-4676-825a-aae28ad65c3e","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017a52MLUkf8U8yEzyNgvYvn","type":"tool_result","content":"total 896\ndrwxr-x---+  68 patrick  staff    2176 Jan  3 07:08 .\ndrwxr-xr-x    5 root     admin     160 Nov 21 06:22 ..\nlrwxr-xr-x@   1 patrick  staff      29 Nov 27 11:39 .aerospace.toml -> dotfiles/home/.aerospace.toml\ndrwxr-xr-x@   4 patrick  staff     128 Dec 25 13:26 .antigravity\n-rw-r--r--@   1 patrick  staff     375 Dec 24 09:23 .bashrc\ndrwxr-xr-x@  13 patrick  staff     416 Jan  2 22:27 .cache\ndrwxr-xr-x@   8 patrick  staff     256 Jan  3 06:27 .cargo\n-r--------    1 patrick  staff       7 Sep 12  2024 .CFUserTextEncoding\ndrwxr-xr-x@  19 patrick  staff     608 Jan  3 07:06 .claude\ndrwxr-xr-x@   6 patrick  staff     192 Jan  2 23:11 .claude-queue\n-rw-------@   1 patrick  staff   59109 Jan  3 07:08 .claude.json\n-rw-------@   1 patrick  staff   59109 Jan  3 07:08 .claude.json.backup\ndrwxr-xr-x@  10 patrick  staff     320 Jan  1 19:20 .codex\ndrwxr-xr-x   12 patrick  staff     384 Jan  2 21:42 .config\ndrwxr-xr-x@   8 patrick  staff     256 Aug 13 20:15 .crush\ndrwx------    3 patrick  staff      96 Nov  4  2024 .cups\ndrwxr-xr-x@   8 patrick  staff     256 Dec 21 18:24 .cursor\ndrwxr-xr-x@   9 patrick  staff     288 May  8  2025 .diffusionbee\ndrwxr-xr-x@  15 patrick  staff     480 Dec 23 20:39 .docker\ndrwxr-xr-x@  19 patrick  staff     608 Jan  1 21:08 .dropbox\nlrwxr-xr-x@   1 patrick  staff      23 Nov 27 11:39 .DS_Store -> dotfiles/home/.DS_Store\ndrwxr-xr-x@   5 patrick  staff     160 Jan  1 16:31 .gemini\nlrwxr-xr-x@   1 patrick  staff      24 Nov 27 11:39 .gitconfig -> dotfiles/home/.gitconfig\ndrwxr-xr-x@   3 patrick  staff      96 Oct  7  2024 .ipython\n-rw-------@   1 patrick  staff      20 Dec 27 21:26 .lesshst\ndrwxr-xr-x@  14 patrick  staff     448 Dec 31 16:57 .lmstudio\n-rw-r--r--@   1 patrick  staff      24 Jul 19 07:23 .lmstudio-home-pointer\ndrwx------@   5 patrick  staff     160 Apr 12  2025 .local\n-rw-------@   1 patrick  staff       4 Oct  7  2024 .node_repl_history","is_error":false}]},"uuid":"5b4bdf44-2b22-4e1b-822a-d934e10b0e3c","timestamp":"2026-01-03T12:09:43.438Z","toolUseResult":{"stdout":"total 896\ndrwxr-x---+  68 patrick  staff    2176 Jan  3 07:08 .\ndrwxr-xr-x    5 root     admin     160 Nov 21 06:22 ..\nlrwxr-xr-x@   1 patrick  staff      29 Nov 27 11:39 .aerospace.toml -> dotfiles/home/.aerospace.toml\ndrwxr-xr-x@   4 patrick  staff     128 Dec 25 13:26 .antigravity\n-rw-r--r--@   1 patrick  staff     375 Dec 24 09:23 .bashrc\ndrwxr-xr-x@  13 patrick  staff     416 Jan  2 22:27 .cache\ndrwxr-xr-x@   8 patrick  staff     256 Jan  3 06:27 .cargo\n-r--------    1 patrick  staff       7 Sep 12  2024 .CFUserTextEncoding\ndrwxr-xr-x@  19 patrick  staff     608 Jan  3 07:06 .claude\ndrwxr-xr-x@   6 patrick  staff     192 Jan  2 23:11 .claude-queue\n-rw-------@   1 patrick  staff   59109 Jan  3 07:08 .claude.json\n-rw-------@   1 patrick  staff   59109 Jan  3 07:08 .claude.json.backup\ndrwxr-xr-x@  10 patrick  staff     320 Jan  1 19:20 .codex\ndrwxr-xr-x   12 patrick  staff     384 Jan  2 21:42 .config\ndrwxr-xr-x@   8 patrick  staff     256 Aug 13 20:15 .crush\ndrwx------    3 patrick  staff      96 Nov  4  2024 .cups\ndrwxr-xr-x@   8 patrick  staff     256 Dec 21 18:24 .cursor\ndrwxr-xr-x@   9 patrick  staff     288 May  8  2025 .diffusionbee\ndrwxr-xr-x@  15 patrick  staff     480 Dec 23 20:39 .docker\ndrwxr-xr-x@  19 patrick  staff     608 Jan  1 21:08 .dropbox\nlrwxr-xr-x@   1 patrick  staff      23 Nov 27 11:39 .DS_Store -> dotfiles/home/.DS_Store\ndrwxr-xr-x@   5 patrick  staff     160 Jan  1 16:31 .gemini\nlrwxr-xr-x@   1 patrick  staff      24 Nov 27 11:39 .gitconfig -> dotfiles/home/.gitconfig\ndrwxr-xr-x@   3 patrick  staff      96 Oct  7  2024 .ipython\n-rw-------@   1 patrick  staff      20 Dec 27 21:26 .lesshst\ndrwxr-xr-x@  14 patrick  staff     448 Dec 31 16:57 .lmstudio\n-rw-r--r--@   1 patrick  staff      24 Jul 19 07:23 .lmstudio-home-pointer\ndrwx------@   5 patrick  staff     160 Apr 12  2025 .local\n-rw-------@   1 patrick  staff       4 Oct  7  2024 .node_repl_history","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"570c25ae-4b17-47ca-ba33-4bc7d1a39c34","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RGJ1U7biAkoNstPecbhGc1","type":"tool_result","content":"/Users/patrick/workingdir/familiar\n/Users/patrick/Library/Application Support/familiar\n/Users/patrick/Library/WebKit/familiar\n/Users/patrick/Library/CloudStorage/Dropbox/Scans/familiar\n/Users/patrick/Library/Caches/familiar","is_error":false}]},"uuid":"ffd9675f-0d38-4cfc-92fd-a475f956c9f5","timestamp":"2026-01-03T12:10:28.796Z","toolUseResult":{"stdout":"/Users/patrick/workingdir/familiar\n/Users/patrick/Library/Application Support/familiar\n/Users/patrick/Library/WebKit/familiar\n/Users/patrick/Library/CloudStorage/Dropbox/Scans/familiar\n/Users/patrick/Library/Caches/familiar","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"ffd9675f-0d38-4cfc-92fd-a475f956c9f5","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Juovbfrae6heTKURZSuTgc","type":"message","role":"assistant","content":[{"type":"text","text":"Found it at `/Users/patrick/workingdir/familiar`. Let me explore the project structure:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":930,"cache_creation_input_tokens":551,"cache_read_input_tokens":11301,"cache_creation":{"ephemeral_5m_input_tokens":551,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRNntCmT9AJG9mA3VWy","type":"assistant","uuid":"b3dd805f-0f04-44d8-b6ca-2e11804891cb","timestamp":"2026-01-03T12:10:34.027Z"}
{"parentUuid":"b3dd805f-0f04-44d8-b6ca-2e11804891cb","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Juovbfrae6heTKURZSuTgc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RjTXkvuThFaEBMbAdCBasc","name":"Glob","input":{"pattern":"**/*.go","path":"/Users/patrick/workingdir/familiar/packages/go-backend"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":930,"cache_creation_input_tokens":551,"cache_read_input_tokens":11301,"cache_creation":{"ephemeral_5m_input_tokens":551,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRNntCmT9AJG9mA3VWy","type":"assistant","uuid":"77ef34e0-1d24-4065-b2ef-f8e7091cf21b","timestamp":"2026-01-03T12:10:34.412Z"}
{"parentUuid":"77ef34e0-1d24-4065-b2ef-f8e7091cf21b","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Juovbfrae6heTKURZSuTgc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012ioBRCwdaTfNPypzWGisw9","name":"Glob","input":{"pattern":"**/*.{ts,tsx}","path":"/Users/patrick/workingdir/familiar/packages/desktop/ui/src"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":930,"cache_creation_input_tokens":551,"cache_read_input_tokens":11301,"cache_creation":{"ephemeral_5m_input_tokens":551,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRNntCmT9AJG9mA3VWy","type":"assistant","uuid":"1287726e-6c1a-4c4b-916a-dd2d06b38412","timestamp":"2026-01-03T12:10:34.915Z"}
{"parentUuid":"1287726e-6c1a-4c4b-916a-dd2d06b38412","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Juovbfrae6heTKURZSuTgc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016sFD8k1XjkAXTbQ4ZSoCiR","name":"Bash","input":{"command":"ls -la /Users/patrick/workingdir/familiar/","description":"List familiar project root"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":930,"cache_creation_input_tokens":551,"cache_read_input_tokens":11301,"cache_creation":{"ephemeral_5m_input_tokens":551,"ephemeral_1h_input_tokens":0},"output_tokens":250,"service_tier":"standard"}},"requestId":"req_011CWkRNntCmT9AJG9mA3VWy","type":"assistant","uuid":"a2b6cda0-1404-4346-a0e7-4f0d990e8187","timestamp":"2026-01-03T12:10:35.455Z"}
{"parentUuid":"a2b6cda0-1404-4346-a0e7-4f0d990e8187","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016sFD8k1XjkAXTbQ4ZSoCiR","type":"tool_result","content":"total 144\ndrwxr-xr-x@ 25 patrick  staff    800 Jan  3 06:36 .\ndrwxr-xr-x@ 12 patrick  staff    384 Jan  2 22:39 ..\ndrwx------@  4 patrick  staff    128 Jan  3 07:05 .claude\ndrwxr-xr-x@  3 patrick  staff     96 Dec 23 09:40 .cursor\n-rw-r--r--@  1 patrick  staff   6148 Jan  2 22:39 .DS_Store\n-rw-r--r--@  1 patrick  staff    791 Jan  1 21:32 .env\ndrwxr-xr-x@ 17 patrick  staff    544 Jan  3 07:08 .git\ndrwxr-xr-x@  3 patrick  staff     96 Dec 21 08:02 .github\n-rw-r--r--@  1 patrick  staff   1934 Jan  3 06:17 .gitignore\ndrwxr-xr-x@  8 patrick  staff    256 Jan  1 20:36 .test-config\n-rw-r--r--@  1 patrick  staff    417 Jan  3 06:34 AGENTS.md\ndrwxr-xr-x@  6 patrick  staff    192 Jan  2 16:15 assets\ndrwxr-xr-x@  3 patrick  staff     96 Jan  3 06:45 bin\n-rw-------@  1 patrick  staff    274 Jan  3 06:36 claude-queue.txt.example\n-rw-r--r--@  1 patrick  staff   1547 Jan  3 06:34 CLAUDE.md\ndrwxr-xr-x   4 patrick  staff    128 Jan  2 20:05 docs\n-rw-r--r--@  1 patrick  staff  27184 Jan  2 23:01 full_history.jsonl\n-rw-r--r--@  1 patrick  staff   2463 Jan  2 21:45 Makefile\ndrwxr-xr-x@  8 patrick  staff    256 Jan  2 16:21 organization\n-rw-r--r--@  1 patrick  staff     87 Jan  2 20:11 package-lock.json\ndrwxr-xr-x@  6 patrick  staff    192 Jan  2 18:30 packages\n-rw-r--r--@  1 patrick  staff    175 Jan  2 16:14 README.md\ndrwx------@  3 patrick  staff     96 Jan  3 06:35 scripts\n-rw-r--r--@  1 patrick  staff    425 Dec 30 15:08 signing.env.template\ndrwxr-xr-x@  4 patrick  staff    128 Jan  2 23:01 tool_results","is_error":false}]},"uuid":"6c1834b5-fa09-4e2c-8fb3-c4f09a8389a9","timestamp":"2026-01-03T12:10:35.528Z","toolUseResult":{"stdout":"total 144\ndrwxr-xr-x@ 25 patrick  staff    800 Jan  3 06:36 .\ndrwxr-xr-x@ 12 patrick  staff    384 Jan  2 22:39 ..\ndrwx------@  4 patrick  staff    128 Jan  3 07:05 .claude\ndrwxr-xr-x@  3 patrick  staff     96 Dec 23 09:40 .cursor\n-rw-r--r--@  1 patrick  staff   6148 Jan  2 22:39 .DS_Store\n-rw-r--r--@  1 patrick  staff    791 Jan  1 21:32 .env\ndrwxr-xr-x@ 17 patrick  staff    544 Jan  3 07:08 .git\ndrwxr-xr-x@  3 patrick  staff     96 Dec 21 08:02 .github\n-rw-r--r--@  1 patrick  staff   1934 Jan  3 06:17 .gitignore\ndrwxr-xr-x@  8 patrick  staff    256 Jan  1 20:36 .test-config\n-rw-r--r--@  1 patrick  staff    417 Jan  3 06:34 AGENTS.md\ndrwxr-xr-x@  6 patrick  staff    192 Jan  2 16:15 assets\ndrwxr-xr-x@  3 patrick  staff     96 Jan  3 06:45 bin\n-rw-------@  1 patrick  staff    274 Jan  3 06:36 claude-queue.txt.example\n-rw-r--r--@  1 patrick  staff   1547 Jan  3 06:34 CLAUDE.md\ndrwxr-xr-x   4 patrick  staff    128 Jan  2 20:05 docs\n-rw-r--r--@  1 patrick  staff  27184 Jan  2 23:01 full_history.jsonl\n-rw-r--r--@  1 patrick  staff   2463 Jan  2 21:45 Makefile\ndrwxr-xr-x@  8 patrick  staff    256 Jan  2 16:21 organization\n-rw-r--r--@  1 patrick  staff     87 Jan  2 20:11 package-lock.json\ndrwxr-xr-x@  6 patrick  staff    192 Jan  2 18:30 packages\n-rw-r--r--@  1 patrick  staff    175 Jan  2 16:14 README.md\ndrwx------@  3 patrick  staff     96 Jan  3 06:35 scripts\n-rw-r--r--@  1 patrick  staff    425 Dec 30 15:08 signing.env.template\ndrwxr-xr-x@  4 patrick  staff    128 Jan  2 23:01 tool_results","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"6c1834b5-fa09-4e2c-8fb3-c4f09a8389a9","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RjTXkvuThFaEBMbAdCBasc","type":"tool_result","content":"/Users/patrick/workingdir/familiar/packages/go-backend/pkg/types/websocket.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/names_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/names.go\n/Users/patrick/workingdir/familiar/packages/go-backend/pkg/types/chat.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/vault.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/browser_manager.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/keychain.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openrouter_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/storage/sqlite_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/files.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/anthropic_stream_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/attachments_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/files_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/anthropic_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openai_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/vault.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/browser.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/feedback.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/send_file.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/screenshot.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/skill_loader.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/skill_loader_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/pkg/types/events.go\n/Users/patrick/workingdir/familiar/packages/go-backend/pkg/types/triggers.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/integration_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/scheduler/scheduler_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/config_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/compaction_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/shell.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/shell_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/prompt.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/paths.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/scheduler/scheduler.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/workspace.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/provider.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/mock.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/onboarding.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/stateful_agent_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/loader_debug_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/triggers.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/triggers.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/base.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openrouter.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/anthropic.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/tool_result_storage.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/runtime_agent.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/compaction.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openai.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/events.go\n/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/main.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/metadata.go\n/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/handlers.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/loader.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/storage/migrations.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/storage/sqlite.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/agent.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/schedule.go\n/Users/patrick/workingdir/familiar/packages/go-backend/pkg/types/agent.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/triggers_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/keychain_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/paths_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/prompt_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/server.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/tools_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/base_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/browser_manager_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/gemini_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/vault_test.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/gemini.go\n/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/tools.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/script_trigger.go\n/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/automation.go\n/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/agents.go"}]},"uuid":"3f55d232-1d1c-4291-9a43-26f3f183e2c2","timestamp":"2026-01-03T12:10:35.979Z","toolUseResult":{"filenames":["/Users/patrick/workingdir/familiar/packages/go-backend/pkg/types/websocket.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/names_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/names.go","/Users/patrick/workingdir/familiar/packages/go-backend/pkg/types/chat.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/vault.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/browser_manager.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/keychain.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openrouter_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/storage/sqlite_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/files.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/anthropic_stream_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/attachments_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/files_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/anthropic_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openai_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/vault.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/browser.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/feedback.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/send_file.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/screenshot.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/skill_loader.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/skill_loader_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/pkg/types/events.go","/Users/patrick/workingdir/familiar/packages/go-backend/pkg/types/triggers.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/integration_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/scheduler/scheduler_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/config_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/compaction_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/shell.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/shell_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/prompt.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/paths.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/scheduler/scheduler.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/workspace.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/provider.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/mock.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/onboarding.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/stateful_agent_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/loader_debug_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/triggers.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/triggers.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/base.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openrouter.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/anthropic.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/tool_result_storage.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/runtime_agent.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/compaction.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openai.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/events.go","/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/main.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/metadata.go","/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/handlers.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/loader.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/storage/migrations.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/storage/sqlite.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/agent.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/schedule.go","/Users/patrick/workingdir/familiar/packages/go-backend/pkg/types/agent.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/triggers_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/keychain_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/paths_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/prompt_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/server.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/tools_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/base_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/browser_manager_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/gemini_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/vault_test.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/gemini.go","/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/tools.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/agent/script_trigger.go","/Users/patrick/workingdir/familiar/packages/go-backend/internal/tools/automation.go","/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/agents.go"],"durationMs":478,"numFiles":74,"truncated":false}}
{"parentUuid":"3f55d232-1d1c-4291-9a43-26f3f183e2c2","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012ioBRCwdaTfNPypzWGisw9","type":"tool_result","content":"/Users/patrick/workingdir/familiar/packages/desktop/ui/src/test/setup.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/ScopeDiff.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/main.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Sparkline.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/LoadBar.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Status.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Tag.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Metric.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Toggle.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Input.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Select.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Button.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/SidebarSection.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/SidebarItem.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/SettingRow.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/ProviderCard.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Section.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SettingsSidebar.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SkillsSidebar.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/TriggersSidebar.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/UsageSidebar.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/context/ChatContext.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/backend.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/utils.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/useNotifications.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/useDraggableResize.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/useLocalStorage.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/constants.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/index.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/ToolApproval.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/DropdownMenu.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/index.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/AgentExplorer.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/FleetSidebar.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/MissedTasksModal.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/ScopeEditor.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SecretRequest.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SkillsView.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/context/SystemContext.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/SearchBar.test.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/App.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/UsageView.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/SearchBar.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/useAutoUpdate.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/TriggersView.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/InlineScopeProposal.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/AgentSettings.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/AgentWorkspace.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/ChatInput.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/LogViewer.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SettingsView.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/StatusBar.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Unibar.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/context/AgentContext.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/context/AgentStore.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/api.test.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/api.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/AgentDashboard.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/InlineScopeProposal.test.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/ToolApproval.test.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/websocket.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/websocket.test.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/hotkeys.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/hotkeys.test.ts\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/useAutoUpdate.test.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Unibar.test.tsx\n/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/HierarchyTree.tsx"}]},"uuid":"c9740ea3-4997-43a3-a0e0-5a669ac32523","timestamp":"2026-01-03T12:10:36.105Z","toolUseResult":{"filenames":["/Users/patrick/workingdir/familiar/packages/desktop/ui/src/test/setup.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/ScopeDiff.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/main.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Sparkline.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/LoadBar.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Status.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Tag.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Metric.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Toggle.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Input.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Select.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Button.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/SidebarSection.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/SidebarItem.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/SettingRow.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/ProviderCard.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/Section.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SettingsSidebar.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SkillsSidebar.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/TriggersSidebar.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/UsageSidebar.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/context/ChatContext.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/backend.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/utils.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/useNotifications.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/useDraggableResize.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/useLocalStorage.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/constants.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/index.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/ToolApproval.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/DropdownMenu.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/ui/index.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/AgentExplorer.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/FleetSidebar.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/MissedTasksModal.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/ScopeEditor.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SecretRequest.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SkillsView.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/context/SystemContext.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/SearchBar.test.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/App.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/UsageView.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/SearchBar.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/useAutoUpdate.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/TriggersView.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/InlineScopeProposal.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/AgentSettings.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/AgentWorkspace.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/ChatInput.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/LogViewer.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SettingsView.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/StatusBar.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Unibar.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/context/AgentContext.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/context/AgentStore.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/api.test.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/api.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/AgentDashboard.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/InlineScopeProposal.test.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/ToolApproval.test.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/websocket.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/websocket.test.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/hotkeys.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/hotkeys.test.ts","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/hooks/useAutoUpdate.test.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Unibar.test.tsx","/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/HierarchyTree.tsx"],"durationMs":603,"numFiles":67,"truncated":false}}
{"parentUuid":"c9740ea3-4997-43a3-a0e0-5a669ac32523","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013upgjj9cxcfgksGSjERxkC","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the critical backend files to understand the current architecture:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":782,"cache_creation_input_tokens":5474,"cache_read_input_tokens":11852,"cache_creation":{"ephemeral_5m_input_tokens":5474,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWkRPL8eZZsgVCuToNdNR","type":"assistant","uuid":"fc3fe3a0-f598-45e8-820b-a5576b00d0c4","timestamp":"2026-01-03T12:10:41.310Z"}
{"parentUuid":"fc3fe3a0-f598-45e8-820b-a5576b00d0c4","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013upgjj9cxcfgksGSjERxkC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BvkQLWAXidBvYiUFDZthGx","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/anthropic.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":782,"cache_creation_input_tokens":5474,"cache_read_input_tokens":11852,"cache_creation":{"ephemeral_5m_input_tokens":5474,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWkRPL8eZZsgVCuToNdNR","type":"assistant","uuid":"3626ed0b-d927-47d0-b694-0f82ed136aec","timestamp":"2026-01-03T12:10:41.780Z"}
{"parentUuid":"3626ed0b-d927-47d0-b694-0f82ed136aec","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013upgjj9cxcfgksGSjERxkC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015Mh31udu2zeSXoUU4d9QTj","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/provider.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":782,"cache_creation_input_tokens":5474,"cache_read_input_tokens":11852,"cache_creation":{"ephemeral_5m_input_tokens":5474,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWkRPL8eZZsgVCuToNdNR","type":"assistant","uuid":"9c18a142-258a-4a6c-bb04-f312c3953699","timestamp":"2026-01-03T12:10:42.306Z"}
{"parentUuid":"9c18a142-258a-4a6c-bb04-f312c3953699","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013upgjj9cxcfgksGSjERxkC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FrnMmK6jdvA3ui48ViY1bD","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/loader.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":782,"cache_creation_input_tokens":5474,"cache_read_input_tokens":11852,"cache_creation":{"ephemeral_5m_input_tokens":5474,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWkRPL8eZZsgVCuToNdNR","type":"assistant","uuid":"4acd451f-9331-41cd-ae1a-cdbf0b766b3c","timestamp":"2026-01-03T12:10:42.656Z"}
{"parentUuid":"4acd451f-9331-41cd-ae1a-cdbf0b766b3c","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013upgjj9cxcfgksGSjERxkC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VBfk6DWpJVNFGeex2u5kyB","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/keychain.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":782,"cache_creation_input_tokens":5474,"cache_read_input_tokens":11852,"cache_creation":{"ephemeral_5m_input_tokens":5474,"ephemeral_1h_input_tokens":0},"output_tokens":270,"service_tier":"standard"}},"requestId":"req_011CWkRPL8eZZsgVCuToNdNR","type":"assistant","uuid":"5ad7dcdc-983a-4ee1-bc80-46f993806082","timestamp":"2026-01-03T12:10:43.151Z"}
{"parentUuid":"5ad7dcdc-983a-4ee1-bc80-46f993806082","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BvkQLWAXidBvYiUFDZthGx","type":"tool_result","content":"     1package inference\n     2\n     3import (\n     4\t\"bufio\"\n     5\t\"bytes\"\n     6\t\"context\"\n     7\t\"encoding/json\"\n     8\t\"errors\"\n     9\t\"fmt\"\n    10\t\"io\"\n    11\t\"log/slog\"\n    12\t\"net/http\"\n    13\t\"strings\"\n    14\t\"time\"\n    15\n    16\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n    17\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n    18)\n    19\n    20type AnthropicProvider struct {\n    21\tapiKey  string\n    22\tbaseURL string\n    23\tclient  *http.Client\n    24}\n    25\n    26func NewAnthropicProvider(apiKey string) (*AnthropicProvider, error) {\n    27\tif apiKey == \"\" {\n    28\t\tapiKey = config.GetKeychainPassword(\"anthropic-api-key\")\n    29\t}\n    30\tif apiKey == \"\" {\n    31\t\treturn nil, errors.New(\"api key required for anthropic\")\n    32\t}\n    33\n    34\treturn &AnthropicProvider{\n    35\t\tapiKey:  apiKey,\n    36\t\tbaseURL: \"https://api.anthropic.com/v1/messages\",\n    37\t\tclient:  &http.Client{Timeout: 300 * time.Second},\n    38\t}, nil\n    39}\n    40\n    41func (p *AnthropicProvider) Name() string {\n    42\treturn \"anthropic\"\n    43}\n    44\n    45func (p *AnthropicProvider) ListModels(ctx context.Context) ([]string, error) {\n    46\treturn nil, nil\n    47}\n    48\n    49func (p *AnthropicProvider) GetContextLimit(model string) int {\n    50\t// Anthropic models generally support 200k tokens\n    51\t// https://docs.anthropic.com/claude/docs/models-overview\n    52\tif strings.Contains(model, \"claude-3-5-sonnet\") {\n    53\t\treturn 200000\n    54\t}\n    55\tif strings.Contains(model, \"claude-3-opus\") || strings.Contains(model, \"claude-3-sonnet\") {\n    56\t\treturn 200000\n    57\t}\n    58\tif strings.Contains(model, \"claude-3-haiku\") {\n    59\t\treturn 200000\n    60\t}\n    61\n    62\t// Try fetching from OpenRouter metadata as a dynamic fallback\n    63\tif limit, ok := GetContextLimitFromOpenRouter(model); ok {\n    64\t\treturn limit\n    65\t}\n    66\n    67\treturn 200000 // Default for Claude 3+\n    68}\n    69\n    70// Define supported document types for Claude\n    71var claudeDocumentTypes = map[string]bool{\n    72\t\"application/pdf\": true,\n    73\t\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\": true,\n    74\t\"text/csv\":   true,\n    75\t\"text/plain\": true,\n    76\t\"text/html\":  true,\n    77\t\"application/vnd.oasis.opendocument.text\": true,\n    78\t\"application/rtf\":                         true,\n    79\t\"application/epub+zip\":                    true,\n    80\t\"application/json\":                        true,\n    81\t\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": true,\n    82}\n    83\n    84func (p *AnthropicProvider) convertMessages(messages []types.Message) ([]map[string]interface{}, string) {\n    85\tvar systemPrompt string\n    86\tvar anthropicMessages []map[string]interface{}\n    87\n    88\tfor _, msg := range messages {\n    89\t\tslog.Debug(\"Anthropic: processing message\", \"role\", msg.Role, \"content_type\", fmt.Sprintf(\"%T\", msg.Content), \"num_attachments\", len(msg.Attachments))\n    90\n    91\t\tif msg.Role == \"system\" {\n    92\t\t\tif content, ok := msg.Content.(string); ok {\n    93\t\t\t\tsystemPrompt += content + \"\\n\"\n    94\t\t\t}\n    95\t\t} else {\n    96\t\t\tvar anthropicParts []map[string]interface{}\n    97\n    98\t\t\t// Handle Content field\n    99\t\t\tif c, ok := msg.Content.(string); ok && c != \"\" {\n   100\t\t\t\tslog.Debug(\"Anthropic: content is string\", \"has_attachments\", len(msg.Attachments) > 0)\n   101\t\t\t\tif len(msg.Attachments) > 0 {\n   102\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n   103\t\t\t\t\t\t\"type\": \"text\",\n   104\t\t\t\t\t\t\"text\": c,\n   105\t\t\t\t\t})\n   106\t\t\t\t}\n   107\t\t\t} else if parts, ok := msg.Content.([]interface{}); ok {\n   108\t\t\t\tslog.Debug(\"Anthropic: processing multimodal content array\", \"num_parts\", len(parts), \"role\", msg.Role)\n   109\t\t\t\tfor _, part := range parts {\n   110\t\t\t\t\tif pMap, ok := part.(map[string]interface{}); ok {\n   111\t\t\t\t\t\tpartType, _ := pMap[\"type\"].(string)\n   112\t\t\t\t\t\tif partType == \"text\" {\n   113\t\t\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n   114\t\t\t\t\t\t\t\t\"type\": \"text\",\n   115\t\t\t\t\t\t\t\t\"text\": pMap[\"text\"],\n   116\t\t\t\t\t\t\t})\n   117\t\t\t\t\t\t} else if partType == \"image_url\" {\n   118\t\t\t\t\t\t\tslog.Debug(\"Anthropic: found image_url part\")\n   119\t\t\t\t\t\t\tif imgUrl, ok := pMap[\"image_url\"].(map[string]interface{}); ok {\n   120\t\t\t\t\t\t\t\turl, _ := imgUrl[\"url\"].(string)\n   121\t\t\t\t\t\t\t\tslog.Debug(\"Anthropic: image_url extracted\", \"url_prefix\", url[:min(50, len(url))])\n   122\t\t\t\t\t\t\t\tif strings.HasPrefix(url, \"data:\") {\n   123\t\t\t\t\t\t\t\t\t// data:image/jpeg;base64,/9j/4AAQSkZJRg...\n   124\t\t\t\t\t\t\t\t\tparts := strings.SplitN(url, \",\", 2)\n   125\t\t\t\t\t\t\t\t\tif len(parts) == 2 {\n   126\t\t\t\t\t\t\t\t\t\theader := parts[0]\n   127\t\t\t\t\t\t\t\t\t\tdata := parts[1]\n   128\t\t\t\t\t\t\t\t\t\tmediaType := strings.TrimPrefix(strings.Split(header, \";\")[0], \"data:\")\n   129\t\t\t\t\t\t\t\t\t\tslog.Debug(\"Anthropic: adding image block\", \"media_type\", mediaType, \"data_len\", len(data))\n   130\t\t\t\t\t\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n   131\t\t\t\t\t\t\t\t\t\t\t\"type\": \"image\",\n   132\t\t\t\t\t\t\t\t\t\t\t\"source\": map[string]interface{}{\n   133\t\t\t\t\t\t\t\t\t\t\t\t\"type\":       \"base64\",\n   134\t\t\t\t\t\t\t\t\t\t\t\t\"media_type\": mediaType,\n   135\t\t\t\t\t\t\t\t\t\t\t\t\"data\":       data,\n   136\t\t\t\t\t\t\t\t\t\t\t},\n   137\t\t\t\t\t\t\t\t\t\t})\n   138\t\t\t\t\t\t\t\t\t}\n   139\t\t\t\t\t\t\t\t}\n   140\t\t\t\t\t\t\t}\n   141\t\t\t\t\t\t}\n   142\t\t\t\t\t}\n   143\t\t\t\t}\n   144\t\t\t}\n   145\n   146\t\t\t// Handle Attachments field\n   147\t\t\tslog.Debug(\"Anthropic: processing attachments\", \"count\", len(msg.Attachments))\n   148\t\t\tfor _, att := range msg.Attachments {\n   149\t\t\t\tslog.Debug(\"Anthropic: attachment\", \"type\", att.Type, \"mime\", att.MimeType, \"name\", att.Name, \"data_len\", len(att.Data))\n   150\t\t\t\tif att.Type == \"image\" {\n   151\t\t\t\t\tslog.Debug(\"Anthropic: adding image from attachment\")\n   152\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n   153\t\t\t\t\t\t\"type\": \"image\",\n   154\t\t\t\t\t\t\"source\": map[string]interface{}{\n   155\t\t\t\t\t\t\t\"type\":       \"base64\",\n   156\t\t\t\t\t\t\t\"media_type\": att.MimeType,\n   157\t\t\t\t\t\t\t\"data\":       att.Data,\n   158\t\t\t\t\t\t},\n   159\t\t\t\t\t})\n   160\t\t\t\t} else if claudeDocumentTypes[att.MimeType] {\n   161\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n   162\t\t\t\t\t\t\"type\": \"document\",\n   163\t\t\t\t\t\t\"source\": map[string]interface{}{\n   164\t\t\t\t\t\t\t\"type\":       \"base64\",\n   165\t\t\t\t\t\t\t\"media_type\": att.MimeType,\n   166\t\t\t\t\t\t\t\"data\":       att.Data,\n   167\t\t\t\t\t\t},\n   168\t\t\t\t\t})\n   169\t\t\t\t} else {\n   170\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n   171\t\t\t\t\t\t\"type\": \"text\",\n   172\t\t\t\t\t\t\"text\": \"[File Attachment: \" + att.Name + \" (\" + att.MimeType + \")]\",\n   173\t\t\t\t\t})\n   174\t\t\t\t}\n   175\t\t\t}\n   176\n   177\t\t\t// Handle ToolCalls field\n   178\t\t\tfor _, tc := range msg.ToolCalls {\n   179\t\t\t\tvar input map[string]interface{}\n   180\t\t\t\tjson.Unmarshal([]byte(tc.Function.Arguments), &input)\n   181\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n   182\t\t\t\t\t\"type\":  \"tool_use\",\n   183\t\t\t\t\t\"id\":    tc.ID,\n   184\t\t\t\t\t\"name\":  tc.Function.Name,\n   185\t\t\t\t\t\"input\": input,\n   186\t\t\t\t})\n   187\t\t\t}\n   188\n   189\t\t\t// Handle ToolCallID (this is a tool result message)\n   190\t\t\tif msg.ToolCallID != \"\" {\n   191\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n   192\t\t\t\t\t\"type\":        \"tool_result\",\n   193\t\t\t\t\t\"tool_use_id\": msg.ToolCallID,\n   194\t\t\t\t\t\"content\":     msg.Content,\n   195\t\t\t\t})\n   196\t\t\t}\n   197\n   198\t\t\tvar finalContent interface{}\n   199\t\t\tif len(anthropicParts) > 0 {\n   200\t\t\t\tif msg.ToolCallID != \"\" {\n   201\t\t\t\t\t// For tool results, content must be the parts\n   202\t\t\t\t\tfinalContent = anthropicParts\n   203\t\t\t\t} else if c, ok := msg.Content.(string); ok && c != \"\" && len(msg.ToolCalls) > 0 {\n   204\t\t\t\t\t// For assistant messages with text + tool calls\n   205\t\t\t\t\tfinalContent = append([]map[string]interface{}{{\n   206\t\t\t\t\t\t\"type\": \"text\",\n   207\t\t\t\t\t\t\"text\": c,\n   208\t\t\t\t\t}}, anthropicParts...)\n   209\t\t\t\t} else {\n   210\t\t\t\t\tfinalContent = anthropicParts\n   211\t\t\t\t}\n   212\t\t\t} else {\n   213\t\t\t\tfinalContent = msg.Content\n   214\t\t\t}\n   215\n   216\t\t\trole := msg.Role\n   217\t\t\tif role == \"tool\" {\n   218\t\t\t\trole = \"user\"\n   219\t\t\t}\n   220\n   221\t\t\t// Anthropic requires alternating user and assistant roles.\n   222\t\t\t// Merge consecutive same-role messages into a single message with multiple content blocks.\n   223\t\t\tif len(anthropicMessages) > 0 && anthropicMessages[len(anthropicMessages)-1][\"role\"] == role {\n   224\t\t\t\tlastIdx := len(anthropicMessages) - 1\n   225\t\t\t\tlastContent := anthropicMessages[lastIdx][\"content\"]\n   226\n   227\t\t\t\tvar lastParts []map[string]interface{}\n   228\t\t\t\tif lp, ok := lastContent.([]map[string]interface{}); ok {\n   229\t\t\t\t\tlastParts = lp\n   230\t\t\t\t} else if ls, ok := lastContent.(string); ok && ls != \"\" {\n   231\t\t\t\t\tlastParts = []map[string]interface{}{{\n   232\t\t\t\t\t\t\"type\": \"text\",\n   233\t\t\t\t\t\t\"text\": ls,\n   234\t\t\t\t\t}}\n   235\t\t\t\t}\n   236\n   237\t\t\t\tvar newParts []map[string]interface{}\n   238\t\t\t\tif np, ok := finalContent.([]map[string]interface{}); ok {\n   239\t\t\t\t\tnewParts = np\n   240\t\t\t\t} else if ns, ok := finalContent.(string); ok && ns != \"\" {\n   241\t\t\t\t\tnewParts = []map[string]interface{}{{\n   242\t\t\t\t\t\t\"type\": \"text\",\n   243\t\t\t\t\t\t\"text\": ns,\n   244\t\t\t\t\t}}\n   245\t\t\t\t}\n   246\n   247\t\t\t\tif len(newParts) > 0 {\n   248\t\t\t\t\tanthropicMessages[lastIdx][\"content\"] = append(lastParts, newParts...)\n   249\t\t\t\t}\n   250\t\t\t\tcontinue\n   251\t\t\t}\n   252\n   253\t\t\tanthropicMessages = append(anthropicMessages, map[string]interface{}{\n   254\t\t\t\t\"role\":    role,\n   255\t\t\t\t\"content\": finalContent,\n   256\t\t\t})\n   257\t\t}\n   258\t}\n   259\treturn anthropicMessages, systemPrompt\n   260}\n   261\n   262func (p *AnthropicProvider) ChatCompletion(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (*types.ChatResponse, error) {\n   263\t// Parse thinking configuration from model string\n   264\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n   265\n   266\tanthropicMessages, systemPrompt := p.convertMessages(messages)\n   267\n   268\t// Set max_tokens higher when thinking is enabled\n   269\tmaxTokens := 4096\n   270\tthinkingBudget := GetAnthropicBudget(reasoningLevel)\n   271\tif thinkingBudget > 0 {\n   272\t\tmaxTokens = thinkingBudget + 8192 // Budget for thinking + reasonable response\n   273\t}\n   274\n   275\tpayload := map[string]interface{}{\n   276\t\t\"model\":      baseModel,\n   277\t\t\"messages\":   anthropicMessages,\n   278\t\t\"max_tokens\": maxTokens,\n   279\t}\n   280\n   281\t// Inject thinking parameter if level is set\n   282\tif reasoningLevel != ReasoningNone {\n   283\t\tpayload[\"thinking\"] = map[string]interface{}{\n   284\t\t\t\"type\":          \"enabled\",\n   285\t\t\t\"budget_tokens\": thinkingBudget,\n   286\t\t}\n   287\t\tslog.Debug(\"Anthropic: Enabling extended thinking\", \"model\", baseModel, \"level\", reasoningLevel, \"budget\", thinkingBudget)\n   288\t}\n   289\n   290\tif systemPrompt != \"\" {\n   291\t\tpayload[\"system\"] = systemPrompt\n   292\t}\n   293\tif tools != nil {\n   294\t\tpayload[\"tools\"] = p.convertTools(tools)\n   295\t\tif toolChoice, ok := options[\"tool_choice\"]; ok {\n   296\t\t\tpayload[\"tool_choice\"] = toolChoice\n   297\t\t}\n   298\t}\n   299\n   300\tbody, err := json.Marshal(payload)\n   301\tif err != nil {\n   302\t\treturn nil, err\n   303\t}\n   304\n   305\treq, err := http.NewRequestWithContext(ctx, \"POST\", p.baseURL, bytes.NewBuffer(body))\n   306\tif err != nil {\n   307\t\treturn nil, err\n   308\t}\n   309\n   310\treq.Header.Set(\"x-api-key\", p.apiKey)\n   311\treq.Header.Set(\"anthropic-version\", \"2023-06-01\")\n   312\treq.Header.Set(\"anthropic-beta\", \"pdfs-2024-09-25\")\n   313\treq.Header.Set(\"Content-Type\", \"application/json\")\n   314\n   315\tresp, err := p.client.Do(req)\n   316\tif err != nil {\n   317\t\treturn nil, err\n   318\t}\n   319\tdefer resp.Body.Close()\n   320\n   321\tif resp.StatusCode != http.StatusOK {\n   322\t\trespBody, _ := io.ReadAll(resp.Body)\n   323\t\treturn nil, fmt.Errorf(\"anthropic request failed with status %d: %s\", resp.StatusCode, string(respBody))\n   324\t}\n   325\n   326\tvar data map[string]interface{}\n   327\tif err := json.NewDecoder(resp.Body).Decode(&data); err != nil {\n   328\t\treturn nil, err\n   329\t}\n   330\n   331\tcontentBlocks := data[\"content\"].([]interface{})\n   332\tvar contentText string\n   333\tvar reasoningText string\n   334\tvar toolCalls []types.ToolCall\n   335\n   336\tfor _, b := range contentBlocks {\n   337\t\tblock, ok := b.(map[string]interface{})\n   338\t\tif !ok {\n   339\t\t\tcontinue\n   340\t\t}\n   341\t\tif block[\"type\"] == \"text\" {\n   342\t\t\ttext, _ := block[\"text\"].(string)\n   343\t\t\tcontentText += text\n   344\t\t} else if block[\"type\"] == \"thinking\" {\n   345\t\t\tthinking, _ := block[\"thinking\"].(string)\n   346\t\t\treasoningText += thinking\n   347\t\t} else if block[\"type\"] == \"tool_use\" {\n   348\t\t\tid, _ := block[\"id\"].(string)\n   349\t\t\tname, _ := block[\"name\"].(string)\n   350\t\t\targs, _ := json.Marshal(block[\"input\"])\n   351\t\t\ttoolCalls = append(toolCalls, types.ToolCall{\n   352\t\t\t\tID:   id,\n   353\t\t\t\tType: \"function\",\n   354\t\t\t\tFunction: types.ToolFunction{\n   355\t\t\t\t\tName:      name,\n   356\t\t\t\t\tArguments: string(args),\n   357\t\t\t\t},\n   358\t\t\t})\n   359\t\t}\n   360\t}\n   361\n   362\tusageData, _ := data[\"usage\"].(map[string]interface{})\n   363\treturn &types.ChatResponse{\n   364\t\tContent:    contentText,\n   365\t\tReasoning:  reasoningText,\n   366\t\tToolCalls:  toolCalls,\n   367\t\tRawMessage: data,\n   368\t\tUsage: types.Usage{\n   369\t\t\tInputTokens:  int(usageData[\"input_tokens\"].(float64)),\n   370\t\t\tOutputTokens: int(usageData[\"output_tokens\"].(float64)),\n   371\t\t},\n   372\t}, nil\n   373}\n   374\n   375func (p *AnthropicProvider) ChatCompletionStream(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (<-chan types.ChatStreamChunk, <-chan error) {\n   376\tchunkCh := make(chan types.ChatStreamChunk)\n   377\terrCh := make(chan error, 1)\n   378\n   379\tgo func() {\n   380\t\tdefer close(chunkCh)\n   381\t\tdefer close(errCh)\n   382\n   383\t\t// Parse thinking configuration from model string\n   384\t\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n   385\n   386\t\tanthropicMessages, systemPrompt := p.convertMessages(messages)\n   387\n   388\t\t// Set max_tokens higher when thinking is enabled\n   389\t\tmaxTokens := 4096\n   390\t\tthinkingBudget := GetAnthropicBudget(reasoningLevel)\n   391\t\tif thinkingBudget > 0 {\n   392\t\t\tmaxTokens = thinkingBudget + 8192\n   393\t\t}\n   394\n   395\t\tpayload := map[string]interface{}{\n   396\t\t\t\"model\":      baseModel,\n   397\t\t\t\"messages\":   anthropicMessages,\n   398\t\t\t\"max_tokens\": maxTokens,\n   399\t\t\t\"stream\":     true,\n   400\t\t}\n   401\n   402\t\t// Inject thinking parameter if level is set\n   403\t\tif reasoningLevel != ReasoningNone {\n   404\t\t\tpayload[\"thinking\"] = map[string]interface{}{\n   405\t\t\t\t\"type\":          \"enabled\",\n   406\t\t\t\t\"budget_tokens\": thinkingBudget,\n   407\t\t\t}\n   408\t\t\tslog.Debug(\"Anthropic: Enabling extended thinking (stream)\", \"model\", baseModel, \"level\", reasoningLevel, \"budget\", thinkingBudget)\n   409\t\t}\n   410\n   411\t\tif systemPrompt != \"\" {\n   412\t\t\tpayload[\"system\"] = systemPrompt\n   413\t\t}\n   414\t\tif tools != nil {\n   415\t\t\tpayload[\"tools\"] = p.convertTools(tools)\n   416\t\t}\n   417\n   418\t\tbody, err := json.Marshal(payload)\n   419\t\tif err != nil {\n   420\t\t\terrCh <- err\n   421\t\t\treturn\n   422\t\t}\n   423\n   424\t\treq, err := http.NewRequestWithContext(ctx, \"POST\", p.baseURL, bytes.NewBuffer(body))\n   425\t\tif err != nil {\n   426\t\t\terrCh <- err\n   427\t\t\treturn\n   428\t\t}\n   429\n   430\t\treq.Header.Set(\"x-api-key\", p.apiKey)\n   431\t\treq.Header.Set(\"anthropic-version\", \"2023-06-01\")\n   432\t\treq.Header.Set(\"anthropic-beta\", \"pdfs-2024-09-25\")\n   433\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n   434\n   435\t\tresp, err := p.client.Do(req)\n   436\t\tif err != nil {\n   437\t\t\terrCh <- err\n   438\t\t\treturn\n   439\t\t}\n   440\t\tdefer resp.Body.Close()\n   441\n   442\t\tif resp.StatusCode != http.StatusOK {\n   443\t\t\trespBody, _ := io.ReadAll(resp.Body)\n   444\t\t\terrCh <- fmt.Errorf(\"anthropic stream request failed with status %d: %s\", resp.StatusCode, string(respBody))\n   445\t\t\treturn\n   446\t\t}\n   447\n   448\t\treader := bufio.NewReader(resp.Body)\n   449\t\tvar currentInputTokens, currentOutputTokens int\n   450\n   451\t\tfor {\n   452\t\t\tline, err := reader.ReadString('\\n')\n   453\t\t\tif err != nil {\n   454\t\t\t\tif err != io.EOF {\n   455\t\t\t\t\terrCh <- err\n   456\t\t\t\t}\n   457\t\t\t\treturn\n   458\t\t\t}\n   459\n   460\t\t\tline = strings.TrimSpace(line)\n   461\t\t\tif line == \"\" {\n   462\t\t\t\tcontinue\n   463\t\t\t}\n   464\n   465\t\t\tif strings.HasPrefix(line, \"data: \") {\n   466\t\t\t\tdataStr := strings.TrimPrefix(line, \"data: \")\n   467\t\t\t\tif dataStr == \"\" {\n   468\t\t\t\t\tcontinue\n   469\t\t\t\t}\n   470\t\t\t\tvar event map[string]interface{}\n   471\t\t\t\tif err := json.Unmarshal([]byte(dataStr), &event); err != nil {\n   472\t\t\t\t\tslog.Debug(\"Anthropic: failed to unmarshal event\", \"error\", err, \"data\", dataStr)\n   473\t\t\t\t\tcontinue\n   474\t\t\t\t}\n   475\n   476\t\t\t\teventType, _ := event[\"type\"].(string)\n   477\t\t\t\tswitch eventType {\n   478\t\t\t\tcase \"message_start\":\n   479\t\t\t\t\tif msg, ok := event[\"message\"].(map[string]interface{}); ok {\n   480\t\t\t\t\t\tif usage, ok := msg[\"usage\"].(map[string]interface{}); ok {\n   481\t\t\t\t\t\t\tif it, ok := usage[\"input_tokens\"].(float64); ok {\n   482\t\t\t\t\t\t\t\tcurrentInputTokens = int(it)\n   483\t\t\t\t\t\t\t}\n   484\t\t\t\t\t\t}\n   485\t\t\t\t\t}\n   486\n   487\t\t\t\tcase \"content_block_start\":\n   488\t\t\t\t\tidx := 0\n   489\t\t\t\t\tif i, ok := event[\"index\"].(float64); ok {\n   490\t\t\t\t\t\tidx = int(i)\n   491\t\t\t\t\t}\n   492\t\t\t\t\tif block, ok := event[\"content_block\"].(map[string]interface{}); ok {\n   493\t\t\t\t\t\tblockType, _ := block[\"type\"].(string)\n   494\t\t\t\t\t\tif blockType == \"tool_use\" {\n   495\t\t\t\t\t\t\tid, _ := block[\"id\"].(string)\n   496\t\t\t\t\t\t\tname, _ := block[\"name\"].(string)\n   497\t\t\t\t\t\t\tchunkCh <- types.ChatStreamChunk{\n   498\t\t\t\t\t\t\t\tToolCalls: []types.ToolCallChunk{{\n   499\t\t\t\t\t\t\t\t\tIndex: &idx,\n   500\t\t\t\t\t\t\t\t\tID:    id,\n   501\t\t\t\t\t\t\t\t\tType:  \"function\",\n   502\t\t\t\t\t\t\t\t\tFunction: types.FunctionChunk{\n   503\t\t\t\t\t\t\t\t\t\tName: name,\n   504\t\t\t\t\t\t\t\t\t},\n   505\t\t\t\t\t\t\t\t}},\n   506\t\t\t\t\t\t\t}\n   507\t\t\t\t\t\t}\n   508\t\t\t\t\t}\n   509\n   510\t\t\t\tcase \"content_block_delta\":\n   511\t\t\t\t\tidx := 0\n   512\t\t\t\t\tif i, ok := event[\"index\"].(float64); ok {\n   513\t\t\t\t\t\tidx = int(i)\n   514\t\t\t\t\t}\n   515\t\t\t\t\tif delta, ok := event[\"delta\"].(map[string]interface{}); ok {\n   516\t\t\t\t\t\tdeltaType, _ := delta[\"type\"].(string)\n   517\t\t\t\t\t\tif deltaType == \"text_delta\" {\n   518\t\t\t\t\t\t\ttext, _ := delta[\"text\"].(string)\n   519\t\t\t\t\t\t\tchunkCh <- types.ChatStreamChunk{Content: text}\n   520\t\t\t\t\t\t} else if deltaType == \"input_json_delta\" {\n   521\t\t\t\t\t\t\tpartial, _ := delta[\"partial_json\"].(string)\n   522\t\t\t\t\t\t\tchunkCh <- types.ChatStreamChunk{\n   523\t\t\t\t\t\t\t\tToolCalls: []types.ToolCallChunk{{\n   524\t\t\t\t\t\t\t\t\tIndex: &idx,\n   525\t\t\t\t\t\t\t\t\tFunction: types.FunctionChunk{\n   526\t\t\t\t\t\t\t\t\t\tArguments: partial,\n   527\t\t\t\t\t\t\t\t\t},\n   528\t\t\t\t\t\t\t\t}},\n   529\t\t\t\t\t\t\t}\n   530\t\t\t\t\t\t} else if deltaType == \"thinking_delta\" {\n   531\t\t\t\t\t\t\tthinking, _ := delta[\"thinking\"].(string)\n   532\t\t\t\t\t\t\tchunkCh <- types.ChatStreamChunk{Reasoning: thinking}\n   533\t\t\t\t\t\t}\n   534\t\t\t\t\t}\n   535\n   536\t\t\t\tcase \"message_delta\":\n   537\t\t\t\t\tif usage, ok := event[\"usage\"].(map[string]interface{}); ok {\n   538\t\t\t\t\t\tif ot, ok := usage[\"output_tokens\"].(float64); ok {\n   539\t\t\t\t\t\t\tcurrentOutputTokens = int(ot)\n   540\t\t\t\t\t\t}\n   541\t\t\t\t\t\tchunkCh <- types.ChatStreamChunk{\n   542\t\t\t\t\t\t\tUsage: &types.Usage{\n   543\t\t\t\t\t\t\t\tInputTokens:  currentInputTokens,\n   544\t\t\t\t\t\t\t\tOutputTokens: currentOutputTokens,\n   545\t\t\t\t\t\t\t\tTotalTokens:  currentInputTokens + currentOutputTokens,\n   546\t\t\t\t\t\t\t},\n   547\t\t\t\t\t\t}\n   548\t\t\t\t\t}\n   549\n   550\t\t\t\tcase \"error\":\n   551\t\t\t\t\tif errObj, ok := event[\"error\"].(map[string]interface{}); ok {\n   552\t\t\t\t\t\tmsg, _ := errObj[\"message\"].(string)\n   553\t\t\t\t\t\terrCh <- fmt.Errorf(\"anthropic stream error: %s\", msg)\n   554\t\t\t\t\t}\n   555\t\t\t\t\treturn\n   556\t\t\t\t}\n   557\t\t\t}\n   558\t\t}\n   559\t}()\n   560\n   561\treturn chunkCh, errCh\n   562}\n   563\n   564func (p *AnthropicProvider) convertTools(tools []interface{}) []interface{} {\n   565\tif tools == nil {\n   566\t\treturn nil\n   567\t}\n   568\tanthropicTools := make([]interface{}, 0, len(tools))\n   569\tfor _, t := range tools {\n   570\t\tif tMap, ok := t.(map[string]interface{}); ok {\n   571\t\t\t// Check if it's an OpenAI-style tool definition\n   572\t\t\tif toolType, ok := tMap[\"type\"].(string); ok && toolType == \"function\" {\n   573\t\t\t\tif function, ok := tMap[\"function\"].(map[string]interface{}); ok {\n   574\t\t\t\t\tanthropicTool := map[string]interface{}{\n   575\t\t\t\t\t\t\"name\":         function[\"name\"],\n   576\t\t\t\t\t\t\"description\":  function[\"description\"],\n   577\t\t\t\t\t\t\"input_schema\": function[\"parameters\"],\n   578\t\t\t\t\t}\n   579\t\t\t\t\tanthropicTools = append(anthropicTools, anthropicTool)\n   580\t\t\t\t\tcontinue\n   581\t\t\t\t}\n   582\t\t\t}\n   583\t\t}\n   584\t\t// If not in OpenAI format or already converted, pass through\n   585\t\tanthropicTools = append(anthropicTools, t)\n   586\t}\n   587\treturn anthropicTools\n   588}\n   589\n   590func (p *AnthropicProvider) Close() error {\n   591\treturn nil\n   592}\n   593\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"91d0f162-d424-44c0-bc4d-bd471246cf72","timestamp":"2026-01-03T12:10:43.217Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/anthropic.go","content":"package inference\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n)\n\ntype AnthropicProvider struct {\n\tapiKey  string\n\tbaseURL string\n\tclient  *http.Client\n}\n\nfunc NewAnthropicProvider(apiKey string) (*AnthropicProvider, error) {\n\tif apiKey == \"\" {\n\t\tapiKey = config.GetKeychainPassword(\"anthropic-api-key\")\n\t}\n\tif apiKey == \"\" {\n\t\treturn nil, errors.New(\"api key required for anthropic\")\n\t}\n\n\treturn &AnthropicProvider{\n\t\tapiKey:  apiKey,\n\t\tbaseURL: \"https://api.anthropic.com/v1/messages\",\n\t\tclient:  &http.Client{Timeout: 300 * time.Second},\n\t}, nil\n}\n\nfunc (p *AnthropicProvider) Name() string {\n\treturn \"anthropic\"\n}\n\nfunc (p *AnthropicProvider) ListModels(ctx context.Context) ([]string, error) {\n\treturn nil, nil\n}\n\nfunc (p *AnthropicProvider) GetContextLimit(model string) int {\n\t// Anthropic models generally support 200k tokens\n\t// https://docs.anthropic.com/claude/docs/models-overview\n\tif strings.Contains(model, \"claude-3-5-sonnet\") {\n\t\treturn 200000\n\t}\n\tif strings.Contains(model, \"claude-3-opus\") || strings.Contains(model, \"claude-3-sonnet\") {\n\t\treturn 200000\n\t}\n\tif strings.Contains(model, \"claude-3-haiku\") {\n\t\treturn 200000\n\t}\n\n\t// Try fetching from OpenRouter metadata as a dynamic fallback\n\tif limit, ok := GetContextLimitFromOpenRouter(model); ok {\n\t\treturn limit\n\t}\n\n\treturn 200000 // Default for Claude 3+\n}\n\n// Define supported document types for Claude\nvar claudeDocumentTypes = map[string]bool{\n\t\"application/pdf\": true,\n\t\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\": true,\n\t\"text/csv\":   true,\n\t\"text/plain\": true,\n\t\"text/html\":  true,\n\t\"application/vnd.oasis.opendocument.text\": true,\n\t\"application/rtf\":                         true,\n\t\"application/epub+zip\":                    true,\n\t\"application/json\":                        true,\n\t\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": true,\n}\n\nfunc (p *AnthropicProvider) convertMessages(messages []types.Message) ([]map[string]interface{}, string) {\n\tvar systemPrompt string\n\tvar anthropicMessages []map[string]interface{}\n\n\tfor _, msg := range messages {\n\t\tslog.Debug(\"Anthropic: processing message\", \"role\", msg.Role, \"content_type\", fmt.Sprintf(\"%T\", msg.Content), \"num_attachments\", len(msg.Attachments))\n\n\t\tif msg.Role == \"system\" {\n\t\t\tif content, ok := msg.Content.(string); ok {\n\t\t\t\tsystemPrompt += content + \"\\n\"\n\t\t\t}\n\t\t} else {\n\t\t\tvar anthropicParts []map[string]interface{}\n\n\t\t\t// Handle Content field\n\t\t\tif c, ok := msg.Content.(string); ok && c != \"\" {\n\t\t\t\tslog.Debug(\"Anthropic: content is string\", \"has_attachments\", len(msg.Attachments) > 0)\n\t\t\t\tif len(msg.Attachments) > 0 {\n\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": c,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else if parts, ok := msg.Content.([]interface{}); ok {\n\t\t\t\tslog.Debug(\"Anthropic: processing multimodal content array\", \"num_parts\", len(parts), \"role\", msg.Role)\n\t\t\t\tfor _, part := range parts {\n\t\t\t\t\tif pMap, ok := part.(map[string]interface{}); ok {\n\t\t\t\t\t\tpartType, _ := pMap[\"type\"].(string)\n\t\t\t\t\t\tif partType == \"text\" {\n\t\t\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n\t\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\t\"text\": pMap[\"text\"],\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t} else if partType == \"image_url\" {\n\t\t\t\t\t\t\tslog.Debug(\"Anthropic: found image_url part\")\n\t\t\t\t\t\t\tif imgUrl, ok := pMap[\"image_url\"].(map[string]interface{}); ok {\n\t\t\t\t\t\t\t\turl, _ := imgUrl[\"url\"].(string)\n\t\t\t\t\t\t\t\tslog.Debug(\"Anthropic: image_url extracted\", \"url_prefix\", url[:min(50, len(url))])\n\t\t\t\t\t\t\t\tif strings.HasPrefix(url, \"data:\") {\n\t\t\t\t\t\t\t\t\t// data:image/jpeg;base64,/9j/4AAQSkZJRg...\n\t\t\t\t\t\t\t\t\tparts := strings.SplitN(url, \",\", 2)\n\t\t\t\t\t\t\t\t\tif len(parts) == 2 {\n\t\t\t\t\t\t\t\t\t\theader := parts[0]\n\t\t\t\t\t\t\t\t\t\tdata := parts[1]\n\t\t\t\t\t\t\t\t\t\tmediaType := strings.TrimPrefix(strings.Split(header, \";\")[0], \"data:\")\n\t\t\t\t\t\t\t\t\t\tslog.Debug(\"Anthropic: adding image block\", \"media_type\", mediaType, \"data_len\", len(data))\n\t\t\t\t\t\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n\t\t\t\t\t\t\t\t\t\t\t\"type\": \"image\",\n\t\t\t\t\t\t\t\t\t\t\t\"source\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\t\t\t\t\"type\":       \"base64\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"media_type\": mediaType,\n\t\t\t\t\t\t\t\t\t\t\t\t\"data\":       data,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle Attachments field\n\t\t\tslog.Debug(\"Anthropic: processing attachments\", \"count\", len(msg.Attachments))\n\t\t\tfor _, att := range msg.Attachments {\n\t\t\t\tslog.Debug(\"Anthropic: attachment\", \"type\", att.Type, \"mime\", att.MimeType, \"name\", att.Name, \"data_len\", len(att.Data))\n\t\t\t\tif att.Type == \"image\" {\n\t\t\t\t\tslog.Debug(\"Anthropic: adding image from attachment\")\n\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n\t\t\t\t\t\t\"type\": \"image\",\n\t\t\t\t\t\t\"source\": map[string]interface{}{\n\t\t\t\t\t\t\t\"type\":       \"base64\",\n\t\t\t\t\t\t\t\"media_type\": att.MimeType,\n\t\t\t\t\t\t\t\"data\":       att.Data,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t} else if claudeDocumentTypes[att.MimeType] {\n\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n\t\t\t\t\t\t\"type\": \"document\",\n\t\t\t\t\t\t\"source\": map[string]interface{}{\n\t\t\t\t\t\t\t\"type\":       \"base64\",\n\t\t\t\t\t\t\t\"media_type\": att.MimeType,\n\t\t\t\t\t\t\t\"data\":       att.Data,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": \"[File Attachment: \" + att.Name + \" (\" + att.MimeType + \")]\",\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle ToolCalls field\n\t\t\tfor _, tc := range msg.ToolCalls {\n\t\t\t\tvar input map[string]interface{}\n\t\t\t\tjson.Unmarshal([]byte(tc.Function.Arguments), &input)\n\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n\t\t\t\t\t\"type\":  \"tool_use\",\n\t\t\t\t\t\"id\":    tc.ID,\n\t\t\t\t\t\"name\":  tc.Function.Name,\n\t\t\t\t\t\"input\": input,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// Handle ToolCallID (this is a tool result message)\n\t\t\tif msg.ToolCallID != \"\" {\n\t\t\t\tanthropicParts = append(anthropicParts, map[string]interface{}{\n\t\t\t\t\t\"type\":        \"tool_result\",\n\t\t\t\t\t\"tool_use_id\": msg.ToolCallID,\n\t\t\t\t\t\"content\":     msg.Content,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tvar finalContent interface{}\n\t\t\tif len(anthropicParts) > 0 {\n\t\t\t\tif msg.ToolCallID != \"\" {\n\t\t\t\t\t// For tool results, content must be the parts\n\t\t\t\t\tfinalContent = anthropicParts\n\t\t\t\t} else if c, ok := msg.Content.(string); ok && c != \"\" && len(msg.ToolCalls) > 0 {\n\t\t\t\t\t// For assistant messages with text + tool calls\n\t\t\t\t\tfinalContent = append([]map[string]interface{}{{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": c,\n\t\t\t\t\t}}, anthropicParts...)\n\t\t\t\t} else {\n\t\t\t\t\tfinalContent = anthropicParts\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfinalContent = msg.Content\n\t\t\t}\n\n\t\t\trole := msg.Role\n\t\t\tif role == \"tool\" {\n\t\t\t\trole = \"user\"\n\t\t\t}\n\n\t\t\t// Anthropic requires alternating user and assistant roles.\n\t\t\t// Merge consecutive same-role messages into a single message with multiple content blocks.\n\t\t\tif len(anthropicMessages) > 0 && anthropicMessages[len(anthropicMessages)-1][\"role\"] == role {\n\t\t\t\tlastIdx := len(anthropicMessages) - 1\n\t\t\t\tlastContent := anthropicMessages[lastIdx][\"content\"]\n\n\t\t\t\tvar lastParts []map[string]interface{}\n\t\t\t\tif lp, ok := lastContent.([]map[string]interface{}); ok {\n\t\t\t\t\tlastParts = lp\n\t\t\t\t} else if ls, ok := lastContent.(string); ok && ls != \"\" {\n\t\t\t\t\tlastParts = []map[string]interface{}{{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": ls,\n\t\t\t\t\t}}\n\t\t\t\t}\n\n\t\t\t\tvar newParts []map[string]interface{}\n\t\t\t\tif np, ok := finalContent.([]map[string]interface{}); ok {\n\t\t\t\t\tnewParts = np\n\t\t\t\t} else if ns, ok := finalContent.(string); ok && ns != \"\" {\n\t\t\t\t\tnewParts = []map[string]interface{}{{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": ns,\n\t\t\t\t\t}}\n\t\t\t\t}\n\n\t\t\t\tif len(newParts) > 0 {\n\t\t\t\t\tanthropicMessages[lastIdx][\"content\"] = append(lastParts, newParts...)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tanthropicMessages = append(anthropicMessages, map[string]interface{}{\n\t\t\t\t\"role\":    role,\n\t\t\t\t\"content\": finalContent,\n\t\t\t})\n\t\t}\n\t}\n\treturn anthropicMessages, systemPrompt\n}\n\nfunc (p *AnthropicProvider) ChatCompletion(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (*types.ChatResponse, error) {\n\t// Parse thinking configuration from model string\n\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n\n\tanthropicMessages, systemPrompt := p.convertMessages(messages)\n\n\t// Set max_tokens higher when thinking is enabled\n\tmaxTokens := 4096\n\tthinkingBudget := GetAnthropicBudget(reasoningLevel)\n\tif thinkingBudget > 0 {\n\t\tmaxTokens = thinkingBudget + 8192 // Budget for thinking + reasonable response\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"model\":      baseModel,\n\t\t\"messages\":   anthropicMessages,\n\t\t\"max_tokens\": maxTokens,\n\t}\n\n\t// Inject thinking parameter if level is set\n\tif reasoningLevel != ReasoningNone {\n\t\tpayload[\"thinking\"] = map[string]interface{}{\n\t\t\t\"type\":          \"enabled\",\n\t\t\t\"budget_tokens\": thinkingBudget,\n\t\t}\n\t\tslog.Debug(\"Anthropic: Enabling extended thinking\", \"model\", baseModel, \"level\", reasoningLevel, \"budget\", thinkingBudget)\n\t}\n\n\tif systemPrompt != \"\" {\n\t\tpayload[\"system\"] = systemPrompt\n\t}\n\tif tools != nil {\n\t\tpayload[\"tools\"] = p.convertTools(tools)\n\t\tif toolChoice, ok := options[\"tool_choice\"]; ok {\n\t\t\tpayload[\"tool_choice\"] = toolChoice\n\t\t}\n\t}\n\n\tbody, err := json.Marshal(payload)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", p.baseURL, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"x-api-key\", p.apiKey)\n\treq.Header.Set(\"anthropic-version\", \"2023-06-01\")\n\treq.Header.Set(\"anthropic-beta\", \"pdfs-2024-09-25\")\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := p.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\trespBody, _ := io.ReadAll(resp.Body)\n\t\treturn nil, fmt.Errorf(\"anthropic request failed with status %d: %s\", resp.StatusCode, string(respBody))\n\t}\n\n\tvar data map[string]interface{}\n\tif err := json.NewDecoder(resp.Body).Decode(&data); err != nil {\n\t\treturn nil, err\n\t}\n\n\tcontentBlocks := data[\"content\"].([]interface{})\n\tvar contentText string\n\tvar reasoningText string\n\tvar toolCalls []types.ToolCall\n\n\tfor _, b := range contentBlocks {\n\t\tblock, ok := b.(map[string]interface{})\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif block[\"type\"] == \"text\" {\n\t\t\ttext, _ := block[\"text\"].(string)\n\t\t\tcontentText += text\n\t\t} else if block[\"type\"] == \"thinking\" {\n\t\t\tthinking, _ := block[\"thinking\"].(string)\n\t\t\treasoningText += thinking\n\t\t} else if block[\"type\"] == \"tool_use\" {\n\t\t\tid, _ := block[\"id\"].(string)\n\t\t\tname, _ := block[\"name\"].(string)\n\t\t\targs, _ := json.Marshal(block[\"input\"])\n\t\t\ttoolCalls = append(toolCalls, types.ToolCall{\n\t\t\t\tID:   id,\n\t\t\t\tType: \"function\",\n\t\t\t\tFunction: types.ToolFunction{\n\t\t\t\t\tName:      name,\n\t\t\t\t\tArguments: string(args),\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\tusageData, _ := data[\"usage\"].(map[string]interface{})\n\treturn &types.ChatResponse{\n\t\tContent:    contentText,\n\t\tReasoning:  reasoningText,\n\t\tToolCalls:  toolCalls,\n\t\tRawMessage: data,\n\t\tUsage: types.Usage{\n\t\t\tInputTokens:  int(usageData[\"input_tokens\"].(float64)),\n\t\t\tOutputTokens: int(usageData[\"output_tokens\"].(float64)),\n\t\t},\n\t}, nil\n}\n\nfunc (p *AnthropicProvider) ChatCompletionStream(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (<-chan types.ChatStreamChunk, <-chan error) {\n\tchunkCh := make(chan types.ChatStreamChunk)\n\terrCh := make(chan error, 1)\n\n\tgo func() {\n\t\tdefer close(chunkCh)\n\t\tdefer close(errCh)\n\n\t\t// Parse thinking configuration from model string\n\t\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n\n\t\tanthropicMessages, systemPrompt := p.convertMessages(messages)\n\n\t\t// Set max_tokens higher when thinking is enabled\n\t\tmaxTokens := 4096\n\t\tthinkingBudget := GetAnthropicBudget(reasoningLevel)\n\t\tif thinkingBudget > 0 {\n\t\t\tmaxTokens = thinkingBudget + 8192\n\t\t}\n\n\t\tpayload := map[string]interface{}{\n\t\t\t\"model\":      baseModel,\n\t\t\t\"messages\":   anthropicMessages,\n\t\t\t\"max_tokens\": maxTokens,\n\t\t\t\"stream\":     true,\n\t\t}\n\n\t\t// Inject thinking parameter if level is set\n\t\tif reasoningLevel != ReasoningNone {\n\t\t\tpayload[\"thinking\"] = map[string]interface{}{\n\t\t\t\t\"type\":          \"enabled\",\n\t\t\t\t\"budget_tokens\": thinkingBudget,\n\t\t\t}\n\t\t\tslog.Debug(\"Anthropic: Enabling extended thinking (stream)\", \"model\", baseModel, \"level\", reasoningLevel, \"budget\", thinkingBudget)\n\t\t}\n\n\t\tif systemPrompt != \"\" {\n\t\t\tpayload[\"system\"] = systemPrompt\n\t\t}\n\t\tif tools != nil {\n\t\t\tpayload[\"tools\"] = p.convertTools(tools)\n\t\t}\n\n\t\tbody, err := json.Marshal(payload)\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\treq, err := http.NewRequestWithContext(ctx, \"POST\", p.baseURL, bytes.NewBuffer(body))\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\treq.Header.Set(\"x-api-key\", p.apiKey)\n\t\treq.Header.Set(\"anthropic-version\", \"2023-06-01\")\n\t\treq.Header.Set(\"anthropic-beta\", \"pdfs-2024-09-25\")\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\t\tresp, err := p.client.Do(req)\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\trespBody, _ := io.ReadAll(resp.Body)\n\t\t\terrCh <- fmt.Errorf(\"anthropic stream request failed with status %d: %s\", resp.StatusCode, string(respBody))\n\t\t\treturn\n\t\t}\n\n\t\treader := bufio.NewReader(resp.Body)\n\t\tvar currentInputTokens, currentOutputTokens int\n\n\t\tfor {\n\t\t\tline, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tif err != io.EOF {\n\t\t\t\t\terrCh <- err\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tline = strings.TrimSpace(line)\n\t\t\tif line == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(line, \"data: \") {\n\t\t\t\tdataStr := strings.TrimPrefix(line, \"data: \")\n\t\t\t\tif dataStr == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tvar event map[string]interface{}\n\t\t\t\tif err := json.Unmarshal([]byte(dataStr), &event); err != nil {\n\t\t\t\t\tslog.Debug(\"Anthropic: failed to unmarshal event\", \"error\", err, \"data\", dataStr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\teventType, _ := event[\"type\"].(string)\n\t\t\t\tswitch eventType {\n\t\t\t\tcase \"message_start\":\n\t\t\t\t\tif msg, ok := event[\"message\"].(map[string]interface{}); ok {\n\t\t\t\t\t\tif usage, ok := msg[\"usage\"].(map[string]interface{}); ok {\n\t\t\t\t\t\t\tif it, ok := usage[\"input_tokens\"].(float64); ok {\n\t\t\t\t\t\t\t\tcurrentInputTokens = int(it)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\tcase \"content_block_start\":\n\t\t\t\t\tidx := 0\n\t\t\t\t\tif i, ok := event[\"index\"].(float64); ok {\n\t\t\t\t\t\tidx = int(i)\n\t\t\t\t\t}\n\t\t\t\t\tif block, ok := event[\"content_block\"].(map[string]interface{}); ok {\n\t\t\t\t\t\tblockType, _ := block[\"type\"].(string)\n\t\t\t\t\t\tif blockType == \"tool_use\" {\n\t\t\t\t\t\t\tid, _ := block[\"id\"].(string)\n\t\t\t\t\t\t\tname, _ := block[\"name\"].(string)\n\t\t\t\t\t\t\tchunkCh <- types.ChatStreamChunk{\n\t\t\t\t\t\t\t\tToolCalls: []types.ToolCallChunk{{\n\t\t\t\t\t\t\t\t\tIndex: &idx,\n\t\t\t\t\t\t\t\t\tID:    id,\n\t\t\t\t\t\t\t\t\tType:  \"function\",\n\t\t\t\t\t\t\t\t\tFunction: types.FunctionChunk{\n\t\t\t\t\t\t\t\t\t\tName: name,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\tcase \"content_block_delta\":\n\t\t\t\t\tidx := 0\n\t\t\t\t\tif i, ok := event[\"index\"].(float64); ok {\n\t\t\t\t\t\tidx = int(i)\n\t\t\t\t\t}\n\t\t\t\t\tif delta, ok := event[\"delta\"].(map[string]interface{}); ok {\n\t\t\t\t\t\tdeltaType, _ := delta[\"type\"].(string)\n\t\t\t\t\t\tif deltaType == \"text_delta\" {\n\t\t\t\t\t\t\ttext, _ := delta[\"text\"].(string)\n\t\t\t\t\t\t\tchunkCh <- types.ChatStreamChunk{Content: text}\n\t\t\t\t\t\t} else if deltaType == \"input_json_delta\" {\n\t\t\t\t\t\t\tpartial, _ := delta[\"partial_json\"].(string)\n\t\t\t\t\t\t\tchunkCh <- types.ChatStreamChunk{\n\t\t\t\t\t\t\t\tToolCalls: []types.ToolCallChunk{{\n\t\t\t\t\t\t\t\t\tIndex: &idx,\n\t\t\t\t\t\t\t\t\tFunction: types.FunctionChunk{\n\t\t\t\t\t\t\t\t\t\tArguments: partial,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if deltaType == \"thinking_delta\" {\n\t\t\t\t\t\t\tthinking, _ := delta[\"thinking\"].(string)\n\t\t\t\t\t\t\tchunkCh <- types.ChatStreamChunk{Reasoning: thinking}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\tcase \"message_delta\":\n\t\t\t\t\tif usage, ok := event[\"usage\"].(map[string]interface{}); ok {\n\t\t\t\t\t\tif ot, ok := usage[\"output_tokens\"].(float64); ok {\n\t\t\t\t\t\t\tcurrentOutputTokens = int(ot)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchunkCh <- types.ChatStreamChunk{\n\t\t\t\t\t\t\tUsage: &types.Usage{\n\t\t\t\t\t\t\t\tInputTokens:  currentInputTokens,\n\t\t\t\t\t\t\t\tOutputTokens: currentOutputTokens,\n\t\t\t\t\t\t\t\tTotalTokens:  currentInputTokens + currentOutputTokens,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\tcase \"error\":\n\t\t\t\t\tif errObj, ok := event[\"error\"].(map[string]interface{}); ok {\n\t\t\t\t\t\tmsg, _ := errObj[\"message\"].(string)\n\t\t\t\t\t\terrCh <- fmt.Errorf(\"anthropic stream error: %s\", msg)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn chunkCh, errCh\n}\n\nfunc (p *AnthropicProvider) convertTools(tools []interface{}) []interface{} {\n\tif tools == nil {\n\t\treturn nil\n\t}\n\tanthropicTools := make([]interface{}, 0, len(tools))\n\tfor _, t := range tools {\n\t\tif tMap, ok := t.(map[string]interface{}); ok {\n\t\t\t// Check if it's an OpenAI-style tool definition\n\t\t\tif toolType, ok := tMap[\"type\"].(string); ok && toolType == \"function\" {\n\t\t\t\tif function, ok := tMap[\"function\"].(map[string]interface{}); ok {\n\t\t\t\t\tanthropicTool := map[string]interface{}{\n\t\t\t\t\t\t\"name\":         function[\"name\"],\n\t\t\t\t\t\t\"description\":  function[\"description\"],\n\t\t\t\t\t\t\"input_schema\": function[\"parameters\"],\n\t\t\t\t\t}\n\t\t\t\t\tanthropicTools = append(anthropicTools, anthropicTool)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If not in OpenAI format or already converted, pass through\n\t\tanthropicTools = append(anthropicTools, t)\n\t}\n\treturn anthropicTools\n}\n\nfunc (p *AnthropicProvider) Close() error {\n\treturn nil\n}\n","numLines":593,"startLine":1,"totalLines":593}}}
{"parentUuid":"91d0f162-d424-44c0-bc4d-bd471246cf72","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015Mh31udu2zeSXoUU4d9QTj","type":"tool_result","content":"     1package inference\n     2\n     3import (\n     4\t\"context\"\n     5\n     6\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n     7)\n     8\n     9type Provider interface {\n    10\tName() string\n    11\tGetContextLimit(model string) int\n    12\tListModels(ctx context.Context) ([]string, error)\n    13\tChatCompletion(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (*types.ChatResponse, error)\n    14\tChatCompletionStream(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (<-chan types.ChatStreamChunk, <-chan error)\n    15\tClose() error\n    16}\n    17\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4903fb8a-c74f-4ef3-abbb-a3cbe1830374","timestamp":"2026-01-03T12:10:43.217Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/provider.go","content":"package inference\n\nimport (\n\t\"context\"\n\n\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n)\n\ntype Provider interface {\n\tName() string\n\tGetContextLimit(model string) int\n\tListModels(ctx context.Context) ([]string, error)\n\tChatCompletion(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (*types.ChatResponse, error)\n\tChatCompletionStream(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (<-chan types.ChatStreamChunk, <-chan error)\n\tClose() error\n}\n","numLines":17,"startLine":1,"totalLines":17}}}
{"parentUuid":"4903fb8a-c74f-4ef3-abbb-a3cbe1830374","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FrnMmK6jdvA3ui48ViY1bD","type":"tool_result","content":"     1package config\n     2\n     3import (\n     4\t\"os\"\n     5\t\"path/filepath\"\n     6\t\"runtime\"\n     7\t\"sync\"\n     8\t\"time\"\n     9\n    10\t\"gopkg.in/yaml.v3\"\n    11)\n    12\n    13var (\n    14\tMockMode     = false\n    15\tcachedConfig *Config\n    16\tconfigMu     sync.RWMutex\n    17)\n    18\n    19type ProviderConfig struct {\n    20\tEnabled *bool `yaml:\"enabled\" json:\"enabled\"`\n    21}\n    22\n    23type CustomProviderConfig struct {\n    24\tBaseURL string `yaml:\"base_url\" json:\"base_url\"`\n    25}\n    26\n    27type Config struct {\n    28\tInference struct {\n    29\t\tChat struct {\n    30\t\t\tProvider string `yaml:\"provider\" json:\"provider\"`\n    31\t\t\tModel    string `yaml:\"model\" json:\"model\"`\n    32\t\t} `yaml:\"chat\" json:\"chat\"`\n    33\t} `yaml:\"inference\" json:\"inference\"`\n    34\tUI struct {\n    35\t\tTheme   string            `yaml:\"theme\" json:\"theme\"`\n    36\t\tHotkeys map[string]string `yaml:\"hotkeys\" json:\"hotkeys\"`\n    37\t} `yaml:\"ui\" json:\"ui\"`\n    38\tSecurity struct {\n    39\t\tAlwaysAllowAll      bool   `yaml:\"always_allow_all\" json:\"always_allow_all\"`\n    40\t\tShellPermissionMode string `yaml:\"shell_permission_mode\" json:\"shell_permission_mode\"`\n    41\t} `yaml:\"security\" json:\"security\"`\n    42\tSubAgent struct {\n    43\t\tEnabled *bool `yaml:\"enabled\" json:\"enabled\"`\n    44\t} `yaml:\"sub_agent\" json:\"sub_agent\"`\n    45\tAgent struct {\n    46\t\tAutoCompactionEnabled  *bool `yaml:\"auto_compaction_enabled\" json:\"auto_compaction_enabled\"`\n    47\t\tMaxToolResultTokens    *int  `yaml:\"max_tool_result_tokens\" json:\"max_tool_result_tokens\"`\n    48\t\tToolResultSummaryWords *int  `yaml:\"tool_result_summary_words\" json:\"tool_result_summary_words\"`\n    49\t} `yaml:\"agent\" json:\"agent\"`\n    50\tProviders       map[string]ProviderConfig       `yaml:\"providers\" json:\"providers\"`\n    51\tAvailableModels map[string]map[string][]string  `yaml:\"available_models\" json:\"available_models\"`\n    52\tCustomProviders map[string]CustomProviderConfig `yaml:\"custom_providers\" json:\"custom_providers\"`\n    53}\n    54\n    55func GetConfigDir() string {\n    56\tif env := os.Getenv(\"FAMILIAR_CONFIG_DIR\"); env != \"\" {\n    57\t\treturn env\n    58\t}\n    59\n    60\tsuffix := \"\"\n    61\tif os.Getenv(\"FAMILIAR_DEV\") != \"\" {\n    62\t\tsuffix = \"-dev\"\n    63\t}\n    64\n    65\tif runtime.GOOS != \"darwin\" {\n    66\t\t// Fallback for non-macOS during dev\n    67\t\thome, _ := os.UserHomeDir()\n    68\t\treturn filepath.Join(home, \".familiar\"+suffix)\n    69\t}\n    70\thome, _ := os.UserHomeDir()\n    71\treturn filepath.Join(home, \"Library\", \"Application Support\", \"familiar\"+suffix)\n    72}\n    73\n    74func IsDev() bool {\n    75\treturn os.Getenv(\"FAMILIAR_DEV\") != \"\"\n    76}\n    77\n    78func GetWorkspacesDir() string {\n    79\treturn filepath.Join(GetConfigDir(), \"workspaces\")\n    80}\n    81\n    82func GetSkillsDir() string {\n    83\treturn filepath.Join(GetConfigDir(), \"skills\")\n    84}\n    85\n    86func GetTriggersDir() string {\n    87\treturn filepath.Join(GetConfigDir(), \"triggers\")\n    88}\n    89\n    90func InitializeDefaultSkills() error {\n    91\tskillsDir := GetSkillsDir()\n    92\tif _, err := os.Stat(skillsDir); err == nil {\n    93\t\tentries, _ := os.ReadDir(skillsDir)\n    94\t\tif len(entries) > 0 {\n    95\t\t\treturn nil\n    96\t\t}\n    97\t}\n    98\n    99\tif err := os.MkdirAll(skillsDir, 0755); err != nil {\n   100\t\treturn err\n   101\t}\n   102\n   103\tdefaultSkills := map[string]string{\n   104\t\t\"linear\": `---\n   105name: linear\n   106description: Create and manage Linear issues using the Linear CLI.\n   107compatibility: linear cli (brew install linear)\n   108---\n   109\n   110## Usage\n   111\n   112Use the linear CLI to interact with Linear. Common commands:\n   113\n   114` + \"```\" + `bash\n   115# Create an issue\n   116linear issue create --title \"Bug: ...\" --team \"ENG\"\n   117\n   118# List issues assigned to me\n   119linear issue list --mine\n   120\n   121# View issue details  \n   122linear issue view ENG-123\n   123` + \"```\" + `\n   124`,\n   125\t\t\"reminders\": `---\n   126name: reminders\n   127description: Create and manage macOS Reminders.\n   128compatibility: macOS\n   129---\n   130\n   131## Usage\n   132\n   133Manage reminders using AppleScript.\n   134\n   135` + \"```\" + `bash\n   136# Add a reminder\n   137osascript -e 'tell application \"Reminders\" to make new reminder with properties {name:\"Task Name\", due date:date \"tomorrow 5pm\"}'\n   138\n   139# List incomplete reminders\n   140osascript -e 'tell application \"Reminders\" to get name of reminders where completed is false'\n   141` + \"```\" + `\n   142`,\n   143\t\t\"calendar\": `---\n   144name: calendar\n   145description: Interact with macOS Calendar.\n   146compatibility: macOS\n   147---\n   148\n   149## Usage\n   150\n   151Check and create calendar events.\n   152\n   153` + \"```\" + `bash\n   154# List today's events\n   155osascript -e 'tell application \"Calendar\" to get summary of events of calendar \"Calendar\" whose start date > (current date) and start date < (current date) + 1 * days'\n   156\n   157# Create a new event\n   158osascript -e 'tell application \"Calendar\" to tell calendar \"Work\" to make new event with properties {summary:\"Meeting\", start date:current date + 1 * hours, end date:current date + 2 * hours}'\n   159` + \"```\" + `\n   160`,\n   161\t\t\"notes\": `---\n   162name: notes\n   163description: Create and search Apple Notes.\n   164compatibility: macOS\n   165---\n   166\n   167## Usage\n   168\n   169Quick capture and search notes.\n   170\n   171` + \"```\" + `bash\n   172# Create a new note\n   173osascript -e 'tell application \"Notes\" to make new note with properties {body:\"New note content\"}'\n   174\n   175# Search notes\n   176osascript -e 'tell application \"Notes\" to get name of every note whose body contains \"search term\"'\n   177` + \"```\" + `\n   178`,\n   179\t\t\"clipboard\": `---\n   180name: clipboard\n   181description: Smart clipboard operations.\n   182compatibility: macOS\n   183---\n   184\n   185## Usage\n   186\n   187Get or set the system clipboard content.\n   188\n   189` + \"```\" + `bash\n   190# Get clipboard content\n   191osascript -e 'the clipboard'\n   192\n   193# Set clipboard content\n   194osascript -e 'set the clipboard to \"new content\"'\n   195` + \"```\" + `\n   196`,\n   197\t\t\"focus\": `---\n   198name: focus\n   199description: Control Focus/Do Not Disturb modes.\n   200compatibility: macOS\n   201---\n   202\n   203## Usage\n   204\n   205Toggle focus modes via System Events.\n   206\n   207` + \"```\" + `bash\n   208# Enable focus mode (DND)\n   209osascript -e 'tell application \"System Events\" to set focus mode to \"Do Not Disturb\"'\n   210` + \"```\" + `\n   211`,\n   212\t\t\"contacts\": `---\n   213name: contacts\n   214description: Search and manage macOS Contacts.\n   215compatibility: macOS\n   216---\n   217\n   218## Usage\n   219\n   220Look up contact information.\n   221\n   222` + \"```\" + `bash\n   223# Search contacts by name\n   224osascript -e 'tell application \"Contacts\" to get {name, email of emails, value of phones} of every person whose name contains \"John\"'\n   225` + \"```\" + `\n   226`,\n   227\t\t\"file-search\": `---\n   228name: file-search\n   229description: Find files using Spotlight (mdfind).\n   230compatibility: macOS\n   231---\n   232\n   233## Usage\n   234\n   235Search for files by name or content.\n   236\n   237` + \"```\" + `bash\n   238# Search by name\n   239mdfind -name \"filename\"\n   240\n   241# Search by kind and content\n   242mdfind \"kind:pdf budget 2024\"\n   243` + \"```\" + `\n   244`,\n   245\t\t\"claude-code\": `---\n   246name: claude-code\n   247description: Spawn Claude Code CLI for complex coding tasks, repository-wide refactoring, and git operations.\n   248compatibility: claude cli (npm install -g @anthropic-ai/claude-code)\n   249---\n   250\n   251## Usage\n   252\n   253Use the Claude Code CLI directly for specialized coding tasks. Claude Code excels at:\n   254- Repository-wide refactoring\n   255- Complex multi-file changes\n   256- Git operations and commit management\n   257- Code review and analysis\n   258\n   259` + \"```\" + `bash\n   260# Run Claude Code with a prompt\n   261claude -p \"Refactor the authentication module to use JWT tokens\"\n   262\n   263# Resume a previous session\n   264claude -r <session_id> -p \"Continue with the database migrations\"\n   265\n   266# With specific allowed tools\n   267claude --allowedTools \"Edit,Bash(git:*),Read\" -p \"Fix the failing tests\"\n   268` + \"```\" + `\n   269\n   270Note: Ensure ANTHROPIC_API_KEY is set in your environment.\n   271`,\n   272\t\t\"codex\": `---\n   273name: codex\n   274description: Spawn OpenAI Codex CLI for coding tasks and deep technical analysis.\n   275compatibility: codex cli (npm install -g @openai/codex)\n   276---\n   277\n   278## Usage\n   279\n   280Use the Codex CLI directly for specialized coding and analysis tasks. Codex excels at:\n   281- Deep technical research\n   282- Architectural analysis\n   283- Code generation and modification\n   284- Complex debugging\n   285\n   286` + \"```\" + `bash\n   287# Run Codex with a prompt\n   288codex exec \"Analyze the codebase architecture and suggest improvements\"\n   289\n   290# With approval mode\n   291codex -a on-request exec \"Implement the new API endpoint\"\n   292\n   293# Resume a previous session\n   294codex exec resume <session_id> \"Continue with the implementation\"\n   295` + \"```\" + `\n   296\n   297Note: Ensure OPENAI_API_KEY is set in your environment.\n   298`,\n   299\t\t\"pdf\": `---\n   300name: pdf\n   301description: PDF operations (read, merge, fill forms).\n   302compatibility: python3, pypdf, fillpdf (pip install pypdf fillpdf)\n   303---\n   304\n   305## Usage\n   306\n   307Read text, merge PDFs, or fill forms.\n   308\n   309` + \"```\" + `bash\n   310# Read PDF text\n   311python3 -c \"from pypdf import PdfReader; print(' '.join([p.extract_text() for p in PdfReader('file.pdf').pages]))\"\n   312\n   313# Fill PDF form\n   314python3 -c \"from fillpdf import fillpdfs; fillpdfs.write_fillable_pdf('input.pdf', 'output.pdf', {'field1': 'value1'})\"\n   315\n   316# List form fields\n   317python3 -c \"from pypdf import PdfReader; print([f for f in PdfReader('form.pdf').get_fields()])\"\n   318` + \"```\" + `\n   319`,\n   320\t\t\"docx\": `---\n   321name: docx\n   322description: Word document operations.\n   323compatibility: python3, python-docx (pip install python-docx)\n   324---\n   325\n   326## Usage\n   327\n   328Read or create Word documents.\n   329\n   330` + \"```\" + `bash\n   331# Read docx text\n   332python3 -c \"import docx; print('\\n'.join([p.text for p in docx.Document('file.docx').paragraphs]))\"\n   333` + \"```\" + `\n   334`,\n   335\t\t\"xlsx\": `---\n   336name: xlsx\n   337description: Excel spreadsheet operations.\n   338compatibility: python3, openpyxl (pip install openpyxl)\n   339---\n   340\n   341## Usage\n   342\n   343Read or manipulate Excel files.\n   344\n   345` + \"```\" + `bash\n   346# Read first sheet\n   347python3 -c \"import openpyxl; wb = openpyxl.load_workbook('file.xlsx'); print([[c.value for c in r] for r in wb.active.rows])\"\n   348` + \"```\" + `\n   349`,\n   350\t}\n   351\n   352\tfor name, content := range defaultSkills {\n   353\t\tskillDir := filepath.Join(skillsDir, name)\n   354\t\tif err := os.MkdirAll(skillDir, 0755); err != nil {\n   355\t\t\treturn err\n   356\t\t}\n   357\t\tskillFile := filepath.Join(skillDir, \"skill.md\")\n   358\t\tif err := os.WriteFile(skillFile, []byte(content), 0644); err != nil {\n   359\t\t\treturn err\n   360\t\t}\n   361\t}\n   362\n   363\treturn nil\n   364}\n   365\n   366func InitializeDefaultTriggers() error {\n   367\ttriggersDir := GetTriggersDir()\n   368\tif _, err := os.Stat(triggersDir); err == nil {\n   369\t\tentries, _ := os.ReadDir(triggersDir)\n   370\t\tif len(entries) > 0 {\n   371\t\t\treturn nil\n   372\t\t}\n   373\t}\n   374\n   375\tif err := os.MkdirAll(triggersDir, 0755); err != nil {\n   376\t\treturn err\n   377\t}\n   378\n   379\tdefaultTriggerDir := filepath.Join(triggersDir, \"cron\")\n   380\tif err := os.MkdirAll(defaultTriggerDir, 0755); err != nil {\n   381\t\treturn err\n   382\t}\n   383\n   384\tdefaultTrigger := `name: cron\n   385description: Built-in scheduler trigger.\n   386type: schedule\n   387enabled: true\n   388`\n   389\treturn os.WriteFile(filepath.Join(defaultTriggerDir, \"trigger.yaml\"), []byte(defaultTrigger), 0644)\n   390}\n   391\n   392func RestoreDefaultSkills() (string, error) {\n   393\tbackupPath, err := backupDir(GetSkillsDir(), \"skills\")\n   394\tif err != nil {\n   395\t\treturn \"\", err\n   396\t}\n   397\treturn backupPath, InitializeDefaultSkills()\n   398}\n   399\n   400func RestoreDefaultTriggers() (string, error) {\n   401\tbackupPath, err := backupDir(GetTriggersDir(), \"triggers\")\n   402\tif err != nil {\n   403\t\treturn \"\", err\n   404\t}\n   405\treturn backupPath, InitializeDefaultTriggers()\n   406}\n   407\n   408func backupDir(sourceDir string, label string) (string, error) {\n   409\tif _, err := os.Stat(sourceDir); err != nil {\n   410\t\tif os.IsNotExist(err) {\n   411\t\t\treturn \"\", nil\n   412\t\t}\n   413\t\treturn \"\", err\n   414\t}\n   415\n   416\ttimestamp := time.Now().Format(\"20060102-150405\")\n   417\tbackupRoot := filepath.Join(GetConfigDir(), \"backups\")\n   418\tif err := os.MkdirAll(backupRoot, 0755); err != nil {\n   419\t\treturn \"\", err\n   420\t}\n   421\tbackupPath := filepath.Join(backupRoot, label+\"-\"+timestamp)\n   422\tif err := os.Rename(sourceDir, backupPath); err != nil {\n   423\t\treturn \"\", err\n   424\t}\n   425\treturn backupPath, nil\n   426}\n   427\n   428func IsCronTriggerEnabled() (bool, error) {\n   429\ttype triggerConfig struct {\n   430\t\tEnabled *bool `yaml:\"enabled\"`\n   431\t}\n   432\tconfigPath := filepath.Join(GetTriggersDir(), \"cron\", \"trigger.yaml\")\n   433\tdata, err := os.ReadFile(configPath)\n   434\tif err != nil {\n   435\t\tif os.IsNotExist(err) {\n   436\t\t\treturn true, nil\n   437\t\t}\n   438\t\treturn true, err\n   439\t}\n   440\n   441\tvar cfg triggerConfig\n   442\tif err := yaml.Unmarshal(data, &cfg); err != nil {\n   443\t\treturn true, err\n   444\t}\n   445\tif cfg.Enabled == nil {\n   446\t\treturn true, nil\n   447\t}\n   448\treturn *cfg.Enabled, nil\n   449}\n   450\n   451func GetConfigPath() string {\n   452\treturn filepath.Join(GetConfigDir(), \"config.yaml\")\n   453}\n   454\n   455func LoadConfig() (*Config, error) {\n   456\tconfigMu.RLock()\n   457\tif cachedConfig != nil {\n   458\t\tdefer configMu.RUnlock()\n   459\t\treturn cachedConfig, nil\n   460\t}\n   461\tconfigMu.RUnlock()\n   462\n   463\tconfigMu.Lock()\n   464\tdefer configMu.Unlock()\n   465\n   466\t// Double check after acquiring lock\n   467\tif cachedConfig != nil {\n   468\t\treturn cachedConfig, nil\n   469\t}\n   470\n   471\tpath := GetConfigPath()\n   472\tdata, err := os.ReadFile(path)\n   473\tif err != nil {\n   474\t\tif os.IsNotExist(err) {\n   475\t\t\tcfg := &Config{}\n   476\t\t\tcfg.defaults()\n   477\t\t\tcachedConfig = cfg\n   478\t\t\treturn cfg, nil\n   479\t\t}\n   480\t\treturn nil, err\n   481\t}\n   482\n   483\tvar cfg Config\n   484\tif err := yaml.Unmarshal(data, &cfg); err != nil {\n   485\t\treturn nil, err\n   486\t}\n   487\n   488\tcfg.defaults()\n   489\tif err := cfg.Validate(); err != nil {\n   490\t\treturn nil, err\n   491\t}\n   492\n   493\tcachedConfig = &cfg\n   494\treturn &cfg, nil\n   495}\n   496\n   497func (c *Config) defaults() {\n   498\tif c.Inference.Chat.Provider == \"\" {\n   499\t\tc.Inference.Chat.Provider = \"\"\n   500\t}\n   501\tif c.Inference.Chat.Model == \"\" {\n   502\t\tc.Inference.Chat.Model = \"\"\n   503\t}\n   504\n   505\tif c.UI.Theme == \"\" {\n   506\t\tc.UI.Theme = \"default\"\n   507\t}\n   508\n   509\tif len(c.UI.Hotkeys) < 10 {\n   510\t\tc.UI.Hotkeys = map[string]string{\n   511\t\t\t\"global_back\":     \"Escape\",\n   512\t\t\t\"new_agent\":       \"Cmd+N\",\n   513\t\t\t\"focus_input\":     \"Cmd+L\",\n   514\t\t\t\"toggle_sidebar\":  \"Cmd+B\",\n   515\t\t\t\"toggle_settings\": \"Cmd+,\",\n   516\t\t\t\"toggle_pause\":    \"Cmd+P\",\n   517\t\t\t\"compact\":         \"Cmd+Shift+C\",\n   518\t\t\t\"accept\":          \"Cmd+Y\",\n   519\t\t\t\"reject\":          \"Cmd+N\",\n   520\t\t\t\"toggle_run\":      \"Cmd+R\",\n   521\t\t\t\"pause_agent\":     \"Ctrl+C\",\n   522\t\t\t\"toggle_unibar\":   \"Cmd+K\",\n   523\t\t\t\"delete_agent\":    \"Cmd+D\",\n   524\t\t}\n   525\t} else {\n   526\t\t// Fill in any missing default hotkeys\n   527\t\tdefaults := map[string]string{\n   528\t\t\t\"global_back\":     \"Escape\",\n   529\t\t\t\"new_agent\":       \"Cmd+N\",\n   530\t\t\t\"focus_input\":     \"Cmd+L\",\n   531\t\t\t\"toggle_sidebar\":  \"Cmd+B\",\n   532\t\t\t\"toggle_settings\": \"Cmd+,\",\n   533\t\t\t\"toggle_pause\":    \"Cmd+P\",\n   534\t\t\t\"compact\":         \"Cmd+Shift+C\",\n   535\t\t\t\"accept\":          \"Cmd+Y\",\n   536\t\t\t\"reject\":          \"Cmd+N\",\n   537\t\t\t\"toggle_run\":      \"Cmd+R\",\n   538\t\t\t\"pause_agent\":     \"Ctrl+C\",\n   539\t\t\t\"toggle_unibar\":   \"Cmd+K\",\n   540\t\t\t\"delete_agent\":    \"Cmd+D\",\n   541\t\t}\n   542\t\tfor k, v := range defaults {\n   543\t\t\tif _, ok := c.UI.Hotkeys[k]; !ok {\n   544\t\t\t\tc.UI.Hotkeys[k] = v\n   545\t\t\t}\n   546\t\t}\n   547\t}\n   548\n   549\tif c.SubAgent.Enabled == nil {\n   550\t\tenabled := true\n   551\t\tc.SubAgent.Enabled = &enabled\n   552\t}\n   553\n   554\t// Default auto-compaction to true as it was the previous behavior\n   555\tif c.Agent.AutoCompactionEnabled == nil {\n   556\t\tenabled := true\n   557\t\tc.Agent.AutoCompactionEnabled = &enabled\n   558\t}\n   559\n   560\t// Default max tool result tokens\n   561\tif c.Agent.MaxToolResultTokens == nil {\n   562\t\ttokens := 5000\n   563\t\tc.Agent.MaxToolResultTokens = &tokens\n   564\t}\n   565\n   566\t// Default summary max words\n   567\tif c.Agent.ToolResultSummaryWords == nil {\n   568\t\twords := 200\n   569\t\tc.Agent.ToolResultSummaryWords = &words\n   570\t}\n   571\n   572\tif c.Providers == nil {\n   573\t\tc.Providers = make(map[string]ProviderConfig)\n   574\t}\n   575\tenabled := false\n   576\tif _, ok := c.Providers[\"ollama\"]; !ok {\n   577\t\tc.Providers[\"ollama\"] = ProviderConfig{Enabled: &enabled}\n   578\t}\n   579\tif _, ok := c.Providers[\"lmstudio\"]; !ok {\n   580\t\tc.Providers[\"lmstudio\"] = ProviderConfig{Enabled: &enabled}\n   581\t}\n   582\n   583\tif c.CustomProviders == nil {\n   584\t\tc.CustomProviders = make(map[string]CustomProviderConfig)\n   585\t}\n   586\n   587\tif c.Security.ShellPermissionMode == \"\" {\n   588\t\tc.Security.ShellPermissionMode = \"restricted\"\n   589\t}\n   590}\n   591\n   592func (c *Config) Validate() error {\n   593\t// Purge any non-chat capabilities from available_models\n   594\tif c.AvailableModels != nil {\n   595\t\tfor provider, caps := range c.AvailableModels {\n   596\t\t\tfor capName := range caps {\n   597\t\t\t\tif capName != \"chat\" {\n   598\t\t\t\t\tdelete(c.AvailableModels[provider], capName)\n   599\t\t\t\t}\n   600\t\t\t}\n   601\t\t}\n   602\t}\n   603\treturn nil\n   604}\n   605\n   606func SaveConfig(cfg *Config) error {\n   607\tconfigMu.Lock()\n   608\tdefer configMu.Unlock()\n   609\n   610\tpath := GetConfigPath()\n   611\tdata, err := yaml.Marshal(cfg)\n   612\tif err != nil {\n   613\t\treturn err\n   614\t}\n   615\n   616\t// Ensure directory exists\n   617\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n   618\t\treturn err\n   619\t}\n   620\n   621\tif err := os.WriteFile(path, data, 0644); err != nil {\n   622\t\treturn err\n   623\t}\n   624\n   625\tcachedConfig = cfg\n   626\treturn nil\n   627}\n   628\n   629func GetAlwaysAllowAll() bool {\n   630\tcfg, err := LoadConfig()\n   631\tif err != nil {\n   632\t\treturn false\n   633\t}\n   634\treturn cfg.Security.AlwaysAllowAll\n   635}\n   636\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d9e59c8c-f5cd-4a72-a4bb-64b13a993640","timestamp":"2026-01-03T12:10:43.217Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/loader.go","content":"package config\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\n\t\"gopkg.in/yaml.v3\"\n)\n\nvar (\n\tMockMode     = false\n\tcachedConfig *Config\n\tconfigMu     sync.RWMutex\n)\n\ntype ProviderConfig struct {\n\tEnabled *bool `yaml:\"enabled\" json:\"enabled\"`\n}\n\ntype CustomProviderConfig struct {\n\tBaseURL string `yaml:\"base_url\" json:\"base_url\"`\n}\n\ntype Config struct {\n\tInference struct {\n\t\tChat struct {\n\t\t\tProvider string `yaml:\"provider\" json:\"provider\"`\n\t\t\tModel    string `yaml:\"model\" json:\"model\"`\n\t\t} `yaml:\"chat\" json:\"chat\"`\n\t} `yaml:\"inference\" json:\"inference\"`\n\tUI struct {\n\t\tTheme   string            `yaml:\"theme\" json:\"theme\"`\n\t\tHotkeys map[string]string `yaml:\"hotkeys\" json:\"hotkeys\"`\n\t} `yaml:\"ui\" json:\"ui\"`\n\tSecurity struct {\n\t\tAlwaysAllowAll      bool   `yaml:\"always_allow_all\" json:\"always_allow_all\"`\n\t\tShellPermissionMode string `yaml:\"shell_permission_mode\" json:\"shell_permission_mode\"`\n\t} `yaml:\"security\" json:\"security\"`\n\tSubAgent struct {\n\t\tEnabled *bool `yaml:\"enabled\" json:\"enabled\"`\n\t} `yaml:\"sub_agent\" json:\"sub_agent\"`\n\tAgent struct {\n\t\tAutoCompactionEnabled  *bool `yaml:\"auto_compaction_enabled\" json:\"auto_compaction_enabled\"`\n\t\tMaxToolResultTokens    *int  `yaml:\"max_tool_result_tokens\" json:\"max_tool_result_tokens\"`\n\t\tToolResultSummaryWords *int  `yaml:\"tool_result_summary_words\" json:\"tool_result_summary_words\"`\n\t} `yaml:\"agent\" json:\"agent\"`\n\tProviders       map[string]ProviderConfig       `yaml:\"providers\" json:\"providers\"`\n\tAvailableModels map[string]map[string][]string  `yaml:\"available_models\" json:\"available_models\"`\n\tCustomProviders map[string]CustomProviderConfig `yaml:\"custom_providers\" json:\"custom_providers\"`\n}\n\nfunc GetConfigDir() string {\n\tif env := os.Getenv(\"FAMILIAR_CONFIG_DIR\"); env != \"\" {\n\t\treturn env\n\t}\n\n\tsuffix := \"\"\n\tif os.Getenv(\"FAMILIAR_DEV\") != \"\" {\n\t\tsuffix = \"-dev\"\n\t}\n\n\tif runtime.GOOS != \"darwin\" {\n\t\t// Fallback for non-macOS during dev\n\t\thome, _ := os.UserHomeDir()\n\t\treturn filepath.Join(home, \".familiar\"+suffix)\n\t}\n\thome, _ := os.UserHomeDir()\n\treturn filepath.Join(home, \"Library\", \"Application Support\", \"familiar\"+suffix)\n}\n\nfunc IsDev() bool {\n\treturn os.Getenv(\"FAMILIAR_DEV\") != \"\"\n}\n\nfunc GetWorkspacesDir() string {\n\treturn filepath.Join(GetConfigDir(), \"workspaces\")\n}\n\nfunc GetSkillsDir() string {\n\treturn filepath.Join(GetConfigDir(), \"skills\")\n}\n\nfunc GetTriggersDir() string {\n\treturn filepath.Join(GetConfigDir(), \"triggers\")\n}\n\nfunc InitializeDefaultSkills() error {\n\tskillsDir := GetSkillsDir()\n\tif _, err := os.Stat(skillsDir); err == nil {\n\t\tentries, _ := os.ReadDir(skillsDir)\n\t\tif len(entries) > 0 {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif err := os.MkdirAll(skillsDir, 0755); err != nil {\n\t\treturn err\n\t}\n\n\tdefaultSkills := map[string]string{\n\t\t\"linear\": `---\nname: linear\ndescription: Create and manage Linear issues using the Linear CLI.\ncompatibility: linear cli (brew install linear)\n---\n\n## Usage\n\nUse the linear CLI to interact with Linear. Common commands:\n\n` + \"```\" + `bash\n# Create an issue\nlinear issue create --title \"Bug: ...\" --team \"ENG\"\n\n# List issues assigned to me\nlinear issue list --mine\n\n# View issue details  \nlinear issue view ENG-123\n` + \"```\" + `\n`,\n\t\t\"reminders\": `---\nname: reminders\ndescription: Create and manage macOS Reminders.\ncompatibility: macOS\n---\n\n## Usage\n\nManage reminders using AppleScript.\n\n` + \"```\" + `bash\n# Add a reminder\nosascript -e 'tell application \"Reminders\" to make new reminder with properties {name:\"Task Name\", due date:date \"tomorrow 5pm\"}'\n\n# List incomplete reminders\nosascript -e 'tell application \"Reminders\" to get name of reminders where completed is false'\n` + \"```\" + `\n`,\n\t\t\"calendar\": `---\nname: calendar\ndescription: Interact with macOS Calendar.\ncompatibility: macOS\n---\n\n## Usage\n\nCheck and create calendar events.\n\n` + \"```\" + `bash\n# List today's events\nosascript -e 'tell application \"Calendar\" to get summary of events of calendar \"Calendar\" whose start date > (current date) and start date < (current date) + 1 * days'\n\n# Create a new event\nosascript -e 'tell application \"Calendar\" to tell calendar \"Work\" to make new event with properties {summary:\"Meeting\", start date:current date + 1 * hours, end date:current date + 2 * hours}'\n` + \"```\" + `\n`,\n\t\t\"notes\": `---\nname: notes\ndescription: Create and search Apple Notes.\ncompatibility: macOS\n---\n\n## Usage\n\nQuick capture and search notes.\n\n` + \"```\" + `bash\n# Create a new note\nosascript -e 'tell application \"Notes\" to make new note with properties {body:\"New note content\"}'\n\n# Search notes\nosascript -e 'tell application \"Notes\" to get name of every note whose body contains \"search term\"'\n` + \"```\" + `\n`,\n\t\t\"clipboard\": `---\nname: clipboard\ndescription: Smart clipboard operations.\ncompatibility: macOS\n---\n\n## Usage\n\nGet or set the system clipboard content.\n\n` + \"```\" + `bash\n# Get clipboard content\nosascript -e 'the clipboard'\n\n# Set clipboard content\nosascript -e 'set the clipboard to \"new content\"'\n` + \"```\" + `\n`,\n\t\t\"focus\": `---\nname: focus\ndescription: Control Focus/Do Not Disturb modes.\ncompatibility: macOS\n---\n\n## Usage\n\nToggle focus modes via System Events.\n\n` + \"```\" + `bash\n# Enable focus mode (DND)\nosascript -e 'tell application \"System Events\" to set focus mode to \"Do Not Disturb\"'\n` + \"```\" + `\n`,\n\t\t\"contacts\": `---\nname: contacts\ndescription: Search and manage macOS Contacts.\ncompatibility: macOS\n---\n\n## Usage\n\nLook up contact information.\n\n` + \"```\" + `bash\n# Search contacts by name\nosascript -e 'tell application \"Contacts\" to get {name, email of emails, value of phones} of every person whose name contains \"John\"'\n` + \"```\" + `\n`,\n\t\t\"file-search\": `---\nname: file-search\ndescription: Find files using Spotlight (mdfind).\ncompatibility: macOS\n---\n\n## Usage\n\nSearch for files by name or content.\n\n` + \"```\" + `bash\n# Search by name\nmdfind -name \"filename\"\n\n# Search by kind and content\nmdfind \"kind:pdf budget 2024\"\n` + \"```\" + `\n`,\n\t\t\"claude-code\": `---\nname: claude-code\ndescription: Spawn Claude Code CLI for complex coding tasks, repository-wide refactoring, and git operations.\ncompatibility: claude cli (npm install -g @anthropic-ai/claude-code)\n---\n\n## Usage\n\nUse the Claude Code CLI directly for specialized coding tasks. Claude Code excels at:\n- Repository-wide refactoring\n- Complex multi-file changes\n- Git operations and commit management\n- Code review and analysis\n\n` + \"```\" + `bash\n# Run Claude Code with a prompt\nclaude -p \"Refactor the authentication module to use JWT tokens\"\n\n# Resume a previous session\nclaude -r <session_id> -p \"Continue with the database migrations\"\n\n# With specific allowed tools\nclaude --allowedTools \"Edit,Bash(git:*),Read\" -p \"Fix the failing tests\"\n` + \"```\" + `\n\nNote: Ensure ANTHROPIC_API_KEY is set in your environment.\n`,\n\t\t\"codex\": `---\nname: codex\ndescription: Spawn OpenAI Codex CLI for coding tasks and deep technical analysis.\ncompatibility: codex cli (npm install -g @openai/codex)\n---\n\n## Usage\n\nUse the Codex CLI directly for specialized coding and analysis tasks. Codex excels at:\n- Deep technical research\n- Architectural analysis\n- Code generation and modification\n- Complex debugging\n\n` + \"```\" + `bash\n# Run Codex with a prompt\ncodex exec \"Analyze the codebase architecture and suggest improvements\"\n\n# With approval mode\ncodex -a on-request exec \"Implement the new API endpoint\"\n\n# Resume a previous session\ncodex exec resume <session_id> \"Continue with the implementation\"\n` + \"```\" + `\n\nNote: Ensure OPENAI_API_KEY is set in your environment.\n`,\n\t\t\"pdf\": `---\nname: pdf\ndescription: PDF operations (read, merge, fill forms).\ncompatibility: python3, pypdf, fillpdf (pip install pypdf fillpdf)\n---\n\n## Usage\n\nRead text, merge PDFs, or fill forms.\n\n` + \"```\" + `bash\n# Read PDF text\npython3 -c \"from pypdf import PdfReader; print(' '.join([p.extract_text() for p in PdfReader('file.pdf').pages]))\"\n\n# Fill PDF form\npython3 -c \"from fillpdf import fillpdfs; fillpdfs.write_fillable_pdf('input.pdf', 'output.pdf', {'field1': 'value1'})\"\n\n# List form fields\npython3 -c \"from pypdf import PdfReader; print([f for f in PdfReader('form.pdf').get_fields()])\"\n` + \"```\" + `\n`,\n\t\t\"docx\": `---\nname: docx\ndescription: Word document operations.\ncompatibility: python3, python-docx (pip install python-docx)\n---\n\n## Usage\n\nRead or create Word documents.\n\n` + \"```\" + `bash\n# Read docx text\npython3 -c \"import docx; print('\\n'.join([p.text for p in docx.Document('file.docx').paragraphs]))\"\n` + \"```\" + `\n`,\n\t\t\"xlsx\": `---\nname: xlsx\ndescription: Excel spreadsheet operations.\ncompatibility: python3, openpyxl (pip install openpyxl)\n---\n\n## Usage\n\nRead or manipulate Excel files.\n\n` + \"```\" + `bash\n# Read first sheet\npython3 -c \"import openpyxl; wb = openpyxl.load_workbook('file.xlsx'); print([[c.value for c in r] for r in wb.active.rows])\"\n` + \"```\" + `\n`,\n\t}\n\n\tfor name, content := range defaultSkills {\n\t\tskillDir := filepath.Join(skillsDir, name)\n\t\tif err := os.MkdirAll(skillDir, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tskillFile := filepath.Join(skillDir, \"skill.md\")\n\t\tif err := os.WriteFile(skillFile, []byte(content), 0644); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc InitializeDefaultTriggers() error {\n\ttriggersDir := GetTriggersDir()\n\tif _, err := os.Stat(triggersDir); err == nil {\n\t\tentries, _ := os.ReadDir(triggersDir)\n\t\tif len(entries) > 0 {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif err := os.MkdirAll(triggersDir, 0755); err != nil {\n\t\treturn err\n\t}\n\n\tdefaultTriggerDir := filepath.Join(triggersDir, \"cron\")\n\tif err := os.MkdirAll(defaultTriggerDir, 0755); err != nil {\n\t\treturn err\n\t}\n\n\tdefaultTrigger := `name: cron\ndescription: Built-in scheduler trigger.\ntype: schedule\nenabled: true\n`\n\treturn os.WriteFile(filepath.Join(defaultTriggerDir, \"trigger.yaml\"), []byte(defaultTrigger), 0644)\n}\n\nfunc RestoreDefaultSkills() (string, error) {\n\tbackupPath, err := backupDir(GetSkillsDir(), \"skills\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn backupPath, InitializeDefaultSkills()\n}\n\nfunc RestoreDefaultTriggers() (string, error) {\n\tbackupPath, err := backupDir(GetTriggersDir(), \"triggers\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn backupPath, InitializeDefaultTriggers()\n}\n\nfunc backupDir(sourceDir string, label string) (string, error) {\n\tif _, err := os.Stat(sourceDir); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn \"\", nil\n\t\t}\n\t\treturn \"\", err\n\t}\n\n\ttimestamp := time.Now().Format(\"20060102-150405\")\n\tbackupRoot := filepath.Join(GetConfigDir(), \"backups\")\n\tif err := os.MkdirAll(backupRoot, 0755); err != nil {\n\t\treturn \"\", err\n\t}\n\tbackupPath := filepath.Join(backupRoot, label+\"-\"+timestamp)\n\tif err := os.Rename(sourceDir, backupPath); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn backupPath, nil\n}\n\nfunc IsCronTriggerEnabled() (bool, error) {\n\ttype triggerConfig struct {\n\t\tEnabled *bool `yaml:\"enabled\"`\n\t}\n\tconfigPath := filepath.Join(GetTriggersDir(), \"cron\", \"trigger.yaml\")\n\tdata, err := os.ReadFile(configPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn true, err\n\t}\n\n\tvar cfg triggerConfig\n\tif err := yaml.Unmarshal(data, &cfg); err != nil {\n\t\treturn true, err\n\t}\n\tif cfg.Enabled == nil {\n\t\treturn true, nil\n\t}\n\treturn *cfg.Enabled, nil\n}\n\nfunc GetConfigPath() string {\n\treturn filepath.Join(GetConfigDir(), \"config.yaml\")\n}\n\nfunc LoadConfig() (*Config, error) {\n\tconfigMu.RLock()\n\tif cachedConfig != nil {\n\t\tdefer configMu.RUnlock()\n\t\treturn cachedConfig, nil\n\t}\n\tconfigMu.RUnlock()\n\n\tconfigMu.Lock()\n\tdefer configMu.Unlock()\n\n\t// Double check after acquiring lock\n\tif cachedConfig != nil {\n\t\treturn cachedConfig, nil\n\t}\n\n\tpath := GetConfigPath()\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tcfg := &Config{}\n\t\t\tcfg.defaults()\n\t\t\tcachedConfig = cfg\n\t\t\treturn cfg, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tvar cfg Config\n\tif err := yaml.Unmarshal(data, &cfg); err != nil {\n\t\treturn nil, err\n\t}\n\n\tcfg.defaults()\n\tif err := cfg.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tcachedConfig = &cfg\n\treturn &cfg, nil\n}\n\nfunc (c *Config) defaults() {\n\tif c.Inference.Chat.Provider == \"\" {\n\t\tc.Inference.Chat.Provider = \"\"\n\t}\n\tif c.Inference.Chat.Model == \"\" {\n\t\tc.Inference.Chat.Model = \"\"\n\t}\n\n\tif c.UI.Theme == \"\" {\n\t\tc.UI.Theme = \"default\"\n\t}\n\n\tif len(c.UI.Hotkeys) < 10 {\n\t\tc.UI.Hotkeys = map[string]string{\n\t\t\t\"global_back\":     \"Escape\",\n\t\t\t\"new_agent\":       \"Cmd+N\",\n\t\t\t\"focus_input\":     \"Cmd+L\",\n\t\t\t\"toggle_sidebar\":  \"Cmd+B\",\n\t\t\t\"toggle_settings\": \"Cmd+,\",\n\t\t\t\"toggle_pause\":    \"Cmd+P\",\n\t\t\t\"compact\":         \"Cmd+Shift+C\",\n\t\t\t\"accept\":          \"Cmd+Y\",\n\t\t\t\"reject\":          \"Cmd+N\",\n\t\t\t\"toggle_run\":      \"Cmd+R\",\n\t\t\t\"pause_agent\":     \"Ctrl+C\",\n\t\t\t\"toggle_unibar\":   \"Cmd+K\",\n\t\t\t\"delete_agent\":    \"Cmd+D\",\n\t\t}\n\t} else {\n\t\t// Fill in any missing default hotkeys\n\t\tdefaults := map[string]string{\n\t\t\t\"global_back\":     \"Escape\",\n\t\t\t\"new_agent\":       \"Cmd+N\",\n\t\t\t\"focus_input\":     \"Cmd+L\",\n\t\t\t\"toggle_sidebar\":  \"Cmd+B\",\n\t\t\t\"toggle_settings\": \"Cmd+,\",\n\t\t\t\"toggle_pause\":    \"Cmd+P\",\n\t\t\t\"compact\":         \"Cmd+Shift+C\",\n\t\t\t\"accept\":          \"Cmd+Y\",\n\t\t\t\"reject\":          \"Cmd+N\",\n\t\t\t\"toggle_run\":      \"Cmd+R\",\n\t\t\t\"pause_agent\":     \"Ctrl+C\",\n\t\t\t\"toggle_unibar\":   \"Cmd+K\",\n\t\t\t\"delete_agent\":    \"Cmd+D\",\n\t\t}\n\t\tfor k, v := range defaults {\n\t\t\tif _, ok := c.UI.Hotkeys[k]; !ok {\n\t\t\t\tc.UI.Hotkeys[k] = v\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.SubAgent.Enabled == nil {\n\t\tenabled := true\n\t\tc.SubAgent.Enabled = &enabled\n\t}\n\n\t// Default auto-compaction to true as it was the previous behavior\n\tif c.Agent.AutoCompactionEnabled == nil {\n\t\tenabled := true\n\t\tc.Agent.AutoCompactionEnabled = &enabled\n\t}\n\n\t// Default max tool result tokens\n\tif c.Agent.MaxToolResultTokens == nil {\n\t\ttokens := 5000\n\t\tc.Agent.MaxToolResultTokens = &tokens\n\t}\n\n\t// Default summary max words\n\tif c.Agent.ToolResultSummaryWords == nil {\n\t\twords := 200\n\t\tc.Agent.ToolResultSummaryWords = &words\n\t}\n\n\tif c.Providers == nil {\n\t\tc.Providers = make(map[string]ProviderConfig)\n\t}\n\tenabled := false\n\tif _, ok := c.Providers[\"ollama\"]; !ok {\n\t\tc.Providers[\"ollama\"] = ProviderConfig{Enabled: &enabled}\n\t}\n\tif _, ok := c.Providers[\"lmstudio\"]; !ok {\n\t\tc.Providers[\"lmstudio\"] = ProviderConfig{Enabled: &enabled}\n\t}\n\n\tif c.CustomProviders == nil {\n\t\tc.CustomProviders = make(map[string]CustomProviderConfig)\n\t}\n\n\tif c.Security.ShellPermissionMode == \"\" {\n\t\tc.Security.ShellPermissionMode = \"restricted\"\n\t}\n}\n\nfunc (c *Config) Validate() error {\n\t// Purge any non-chat capabilities from available_models\n\tif c.AvailableModels != nil {\n\t\tfor provider, caps := range c.AvailableModels {\n\t\t\tfor capName := range caps {\n\t\t\t\tif capName != \"chat\" {\n\t\t\t\t\tdelete(c.AvailableModels[provider], capName)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc SaveConfig(cfg *Config) error {\n\tconfigMu.Lock()\n\tdefer configMu.Unlock()\n\n\tpath := GetConfigPath()\n\tdata, err := yaml.Marshal(cfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Ensure directory exists\n\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n\t\treturn err\n\t}\n\n\tif err := os.WriteFile(path, data, 0644); err != nil {\n\t\treturn err\n\t}\n\n\tcachedConfig = cfg\n\treturn nil\n}\n\nfunc GetAlwaysAllowAll() bool {\n\tcfg, err := LoadConfig()\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn cfg.Security.AlwaysAllowAll\n}\n","numLines":636,"startLine":1,"totalLines":636}}}
{"parentUuid":"d9e59c8c-f5cd-4a72-a4bb-64b13a993640","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VBfk6DWpJVNFGeex2u5kyB","type":"tool_result","content":"     1package config\n     2\n     3import (\n     4\t\"bytes\"\n     5\t\"os/exec\"\n     6\t\"runtime\"\n     7\t\"strings\"\n     8)\n     9\n    10const KeychainService = \"familiar\"\n    11\n    12func IsMacOS() bool {\n    13\treturn runtime.GOOS == \"darwin\"\n    14}\n    15\n    16func GetKeychainPassword(account string) string {\n    17\tif !IsMacOS() {\n    18\t\treturn \"\"\n    19\t}\n    20\n    21\tcmd := exec.Command(\"security\", \"find-generic-password\", \"-s\", KeychainService, \"-a\", account, \"-w\")\n    22\tvar out bytes.Buffer\n    23\tcmd.Stdout = &out\n    24\terr := cmd.Run()\n    25\tif err != nil {\n    26\t\treturn \"\"\n    27\t}\n    28\n    29\treturn strings.TrimSpace(out.String())\n    30}\n    31\n    32func SetKeychainPassword(account, password string) error {\n    33\tif !IsMacOS() {\n    34\t\treturn nil\n    35\t}\n    36\n    37\t// Try to delete first to avoid \"already exists\" error\n    38\tDeleteKeychainPassword(account)\n    39\n    40\tcmd := exec.Command(\"security\", \"add-generic-password\", \"-s\", KeychainService, \"-a\", account, \"-w\", password, \"-U\")\n    41\treturn cmd.Run()\n    42}\n    43\n    44func DeleteKeychainPassword(account string) error {\n    45\tif !IsMacOS() {\n    46\t\treturn nil\n    47\t}\n    48\n    49\tcmd := exec.Command(\"security\", \"delete-generic-password\", \"-s\", KeychainService, \"-a\", account)\n    50\treturn cmd.Run()\n    51}\n    52\n    53\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"eaa65521-6a7d-4bc7-80f4-e86b41b6fdbd","timestamp":"2026-01-03T12:10:43.217Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/keychain.go","content":"package config\n\nimport (\n\t\"bytes\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"strings\"\n)\n\nconst KeychainService = \"familiar\"\n\nfunc IsMacOS() bool {\n\treturn runtime.GOOS == \"darwin\"\n}\n\nfunc GetKeychainPassword(account string) string {\n\tif !IsMacOS() {\n\t\treturn \"\"\n\t}\n\n\tcmd := exec.Command(\"security\", \"find-generic-password\", \"-s\", KeychainService, \"-a\", account, \"-w\")\n\tvar out bytes.Buffer\n\tcmd.Stdout = &out\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\treturn strings.TrimSpace(out.String())\n}\n\nfunc SetKeychainPassword(account, password string) error {\n\tif !IsMacOS() {\n\t\treturn nil\n\t}\n\n\t// Try to delete first to avoid \"already exists\" error\n\tDeleteKeychainPassword(account)\n\n\tcmd := exec.Command(\"security\", \"add-generic-password\", \"-s\", KeychainService, \"-a\", account, \"-w\", password, \"-U\")\n\treturn cmd.Run()\n}\n\nfunc DeleteKeychainPassword(account string) error {\n\tif !IsMacOS() {\n\t\treturn nil\n\t}\n\n\tcmd := exec.Command(\"security\", \"delete-generic-password\", \"-s\", KeychainService, \"-a\", account)\n\treturn cmd.Run()\n}\n\n","numLines":53,"startLine":1,"totalLines":53}}}
{"parentUuid":"eaa65521-6a7d-4bc7-80f4-e86b41b6fdbd","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BNVuaLtBzbRSrKY5wPu6yH","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the server handlers and server.go to understand how providers are instantiated and how WebSocket handlers work:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":17914,"cache_read_input_tokens":17326,"cache_creation":{"ephemeral_5m_input_tokens":17914,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRPrk9XUtp7A7PHzand","type":"assistant","uuid":"9f7a2ee2-5754-4acc-b654-f278e5d27226","timestamp":"2026-01-03T12:10:49.638Z"}
{"parentUuid":"9f7a2ee2-5754-4acc-b654-f278e5d27226","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BNVuaLtBzbRSrKY5wPu6yH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RFtTgxB8MnaNErQ9qzR54h","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/handlers.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":17914,"cache_read_input_tokens":17326,"cache_creation":{"ephemeral_5m_input_tokens":17914,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRPrk9XUtp7A7PHzand","type":"assistant","uuid":"e0abeaaa-1e7e-4d82-996d-912fcd2b5103","timestamp":"2026-01-03T12:10:50.133Z"}
{"parentUuid":"e0abeaaa-1e7e-4d82-996d-912fcd2b5103","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BNVuaLtBzbRSrKY5wPu6yH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HgPPjNtrfEzY9LjChUQpBM","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/server.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":17914,"cache_read_input_tokens":17326,"cache_creation":{"ephemeral_5m_input_tokens":17914,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRPrk9XUtp7A7PHzand","type":"assistant","uuid":"2a97cb8c-c645-41d6-935c-2392a564911e","timestamp":"2026-01-03T12:10:50.532Z"}
{"parentUuid":"2a97cb8c-c645-41d6-935c-2392a564911e","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BNVuaLtBzbRSrKY5wPu6yH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ezig2SA3TQbxM5Auq281YT","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SettingsView.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":17914,"cache_read_input_tokens":17326,"cache_creation":{"ephemeral_5m_input_tokens":17914,"ephemeral_1h_input_tokens":0},"output_tokens":225,"service_tier":"standard"}},"requestId":"req_011CWkRPrk9XUtp7A7PHzand","type":"assistant","uuid":"4c10f065-a58a-4b4e-8445-7a70a186be9e","timestamp":"2026-01-03T12:10:51.293Z"}
{"parentUuid":"4c10f065-a58a-4b4e-8445-7a70a186be9e","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HgPPjNtrfEzY9LjChUQpBM","type":"tool_result","content":"     1package main\n     2\n     3import (\n     4\t\"bytes\"\n     5\t\"encoding/json\"\n     6\t\"fmt\"\n     7\t\"log/slog\"\n     8\t\"os\"\n     9\t\"os/exec\"\n    10\t\"strings\"\n    11\t\"sync\"\n    12\t\"time\"\n    13\n    14\t\"github.com/google/uuid\"\n    15\t\"github.com/gorilla/websocket\"\n    16\t\"github.com/patrick/familiar/packages/go-backend/internal/agent\"\n    17\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n    18\t\"github.com/patrick/familiar/packages/go-backend/internal/inference\"\n    19\t\"github.com/patrick/familiar/packages/go-backend/internal/scheduler\"\n    20\t\"github.com/patrick/familiar/packages/go-backend/internal/storage\"\n    21\t\"github.com/patrick/familiar/packages/go-backend/internal/tools\"\n    22\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n    23)\n    24\n    25type Server struct {\n    26\tdb             *storage.DB\n    27\tagents         map[string]*agent.RuntimeAgent\n    28\tstatefulAgents map[string]*agent.StatefulAgent\n    29\tmu             sync.RWMutex\n    30\tglobalClients  []*websocket.Conn\n    31\tconnLocks      map[*websocket.Conn]*sync.Mutex\n    32\tscheduler      *scheduler.Scheduler\n    33\ttriggerManager *agent.TriggerManager\n    34\tproposing      sync.Map // agentID -> context.CancelFunc\n    35\ttoolRegistry   *tools.Registry\n    36\tauthStatus     map[string]string\n    37\tcliStatus      map[string]string\n    38\tlastAuthCheck  time.Time\n    39}\n    40\n    41func NewServer(db *storage.DB) *Server {\n    42\ts := &Server{\n    43\t\tdb:             db,\n    44\t\tagents:         make(map[string]*agent.RuntimeAgent),\n    45\t\tstatefulAgents: make(map[string]*agent.StatefulAgent),\n    46\t\tconnLocks:      make(map[*websocket.Conn]*sync.Mutex),\n    47\t\ttoolRegistry:   tools.NewRegistry(),\n    48\t\tauthStatus: map[string]string{\n    49\t\t\t\"claude\": \"checking\",\n    50\t\t\t\"codex\":  \"checking\",\n    51\t\t},\n    52\t\tcliStatus: map[string]string{\n    53\t\t\t\"claude\": \"checking\",\n    54\t\t\t\"codex\":  \"checking\",\n    55\t\t},\n    56\t}\n    57\n    58\tcfg, _ := config.LoadConfig()\n    59\t// Pre-register tools to the toolRegistry for listing\n    60\ts.registerTools(&agent.RuntimeAgent{Registry: s.toolRegistry}, nil, cfg, nil)\n    61\n    62\t// Start background auth check\n    63\tgo s.startAuthCheckLoop()\n    64\n    65\treturn s\n    66}\n    67\n    68func (s *Server) startAuthCheckLoop() {\n    69\t// Initial check\n    70\ts.refreshAuthStatus()\n    71\n    72\tticker := time.NewTicker(2 * time.Minute)\n    73\tfor range ticker.C {\n    74\t\ts.refreshAuthStatus()\n    75\t}\n    76}\n    77\n    78func (s *Server) refreshAuthStatus() {\n    79\tclaudeAuth := checkCLIAuth(\"claude\")\n    80\tcodexAuth := checkCLIAuth(\"codex\")\n    81\tclaudeCLI := checkCLI(\"claude\")\n    82\tcodexCLI := checkCLI(\"codex\")\n    83\n    84\ts.mu.Lock()\n    85\ts.authStatus[\"claude\"] = claudeAuth\n    86\ts.authStatus[\"codex\"] = codexAuth\n    87\ts.cliStatus[\"claude\"] = claudeCLI\n    88\ts.cliStatus[\"codex\"] = codexCLI\n    89\ts.lastAuthCheck = time.Now()\n    90\ts.mu.Unlock()\n    91}\n    92\n    93func (s *Server) BootstrapOnboarding() error {\n    94\tonboardingCompleted, _ := s.db.GetSetting(\"onboarding_completed\")\n    95\tcount, _ := s.db.CountAgents()\n    96\n    97\tif onboardingCompleted == \"true\" && count > 0 {\n    98\t\t// Reset onboarding setting if explicitly called\n    99\t\ts.db.SetSetting(\"onboarding_completed\", \"false\")\n   100\t}\n   101\n   102\tslog.Info(\"Bootstrapping onboarding agent\")\n   103\tagentID := uuid.New().String()\n   104\twelcomeSystemPrompt := `You are Familiar, a personal AI agent designed to help users with research, coding, scheduling, and day-to-day tasks.\n   105\n   106YOUR GOAL:\n   1071. Help the user find their first real use case for Familiar.\n   1082. Ask questions about their work, hobbies, or daily routines to identify where you can provide value.\n   1093. Offer concrete ideas on what you could help with (e.g., \"I could help you research X\", \"I can help you write scripts for Y\", \"I can manage your calendar for Z\").\n   110\n   111WHAT IS FAMILIAR?\n   112Familiar is more than just a chatbot. It can:\n   113- Use tools to interact with your computer (files, shell, browser).\n   114- Schedule tasks to run in the background or at specific times.\n   115- Spawn sub-agents to handle complex multi-step projects.\n   116- Remember context across conversations.\n   117\n   118TONE:\n   119Helpful, proactive, and curious. Focus on getting the user to their first successful task.`\n   120\n   121\ta := types.Agent{\n   122\t\tID:            agentID,\n   123\t\tName:          \"Welcome\",\n   124\t\tState:         types.AgentStateIdle,\n   125\t\tInitialPrompt: \"\",\n   126\t\tSystemPrompt:  welcomeSystemPrompt,\n   127\t\tPlanEnabled:   false,\n   128\t\tModelConfig: types.ModelConfig{\n   129\t\t\tProvider: \"onboarding\",\n   130\t\t\tModel:    \"scripted\",\n   131\t\t},\n   132\t\tMaxContextTokens: 128000,\n   133\t\tCreatedAt:        time.Now().UTC(),\n   134\t\tUpdatedAt:        time.Now().UTC(),\n   135\t}\n   136\n   137\tif err := s.db.CreateAgent(a); err != nil {\n   138\t\treturn fmt.Errorf(\"failed to create onboarding agent: %w\", err)\n   139\t}\n   140\n   141\t// Add initial greeting\n   142\tgreeting := \"Welcome back to onboarding! I'm your personal agent. To get started, we need to connect me to an AI provider like OpenAI, Anthropic, or a local one via Ollama.\\n\\n**Please follow these steps:**\\n1. Head over to **Settings** in the top menu and enable at least one provider.\\n2. Come back here to this chat.\\n3. At the bottom, select your provider and a model from the dropdowns.\\n4. Say hi!\"\n   143\tif onboardingCompleted != \"true\" {\n   144\t\tgreeting = \"Welcome to Familiar! I'm your new personal agent. To get started, we need to connect me to an AI provider like OpenAI, Anthropic, or a local one via Ollama.\\n\\n**Please follow these steps:**\\n1. Head over to **Settings** in the top menu and enable at least one provider.\\n2. Come back here to this chat.\\n3. At the bottom, select your provider and a model from the dropdowns.\\n4. Say hi!\"\n   145\t}\n   146\n   147\ts.db.AppendAgentLog(agentID, \"model_responded\", map[string]interface{}{\n   148\t\t\"content\": greeting,\n   149\t})\n   150\n   151\t// Broadcast the new agent\n   152\tupdatedAgent, err := s.db.GetAgent(agentID)\n   153\tif err == nil {\n   154\t\ts.globalBroadcast(map[string]interface{}{\n   155\t\t\t\"type\":  \"agent_created\",\n   156\t\t\t\"agent\": updatedAgent,\n   157\t\t})\n   158\t}\n   159\n   160\treturn nil\n   161}\n   162\n   163func (s *Server) safeWriteJSON(conn *websocket.Conn, v interface{}) error {\n   164\ts.mu.RLock()\n   165\tlock, ok := s.connLocks[conn]\n   166\ts.mu.RUnlock()\n   167\n   168\tif !ok {\n   169\t\ts.mu.Lock()\n   170\t\tlock, ok = s.connLocks[conn]\n   171\t\tif !ok {\n   172\t\t\tlock = &sync.Mutex{}\n   173\t\t\ts.connLocks[conn] = lock\n   174\t\t}\n   175\t\ts.mu.Unlock()\n   176\t}\n   177\n   178\tlock.Lock()\n   179\tdefer lock.Unlock()\n   180\treturn conn.WriteJSON(v)\n   181}\n   182\n   183func (s *Server) globalBroadcast(payload interface{}) {\n   184\ts.mu.RLock()\n   185\tclients := s.globalClients\n   186\ts.mu.RUnlock()\n   187\n   188\tfor _, conn := range clients {\n   189\t\ts.safeWriteJSON(conn, payload)\n   190\t}\n   191}\n   192\n   193func (s *Server) getTasksWithNextRun() ([]storage.Task, error) {\n   194\ttasks, err := s.db.ListTasks()\n   195\tif err != nil {\n   196\t\treturn nil, err\n   197\t}\n   198\tfor i := range tasks {\n   199\t\ttasks[i].NextRunAt = s.scheduler.GetNextRun(tasks[i])\n   200\t}\n   201\treturn tasks, nil\n   202}\n   203\n   204func (s *Server) recoverPendingEvents() error {\n   205\tagents, _ := s.db.ListAgents(nil, nil)\n   206\tfor _, a := range agents {\n   207\t\tevents, err := s.db.LoadPending(a.ID)\n   208\t\tif err != nil {\n   209\t\t\tslog.Error(\"Failed to load pending events for agent\", \"agent_id\", a.ID, \"error\", err)\n   210\t\t\tcontinue\n   211\t\t}\n   212\t\tif len(events) > 0 {\n   213\t\t\tsa, err := s.getOrCreateStatefulAgent(a.ID)\n   214\t\t\tif err != nil {\n   215\t\t\t\tslog.Error(\"Failed to create stateful agent for event recovery\", \"agent_id\", a.ID, \"error\", err)\n   216\t\t\t\tcontinue\n   217\t\t\t}\n   218\t\t\tfor _, e := range events {\n   219\t\t\t\tsa.PushEvent(e.Type, e.Payload)\n   220\t\t\t}\n   221\t\t\t// Auto-resume if there are pending events and the agent is not running\n   222\t\t\tif !sa.IsRunning() {\n   223\t\t\t\tgo s.resumeAgent(a.ID, \"\")\n   224\t\t\t}\n   225\t\t}\n   226\t}\n   227\treturn nil\n   228}\n   229\n   230func (s *Server) createProvider(providerType string) (inference.Provider, error) {\n   231\tif providerType == \"onboarding\" {\n   232\t\treturn inference.NewOnboardingProvider(), nil\n   233\t}\n   234\n   235\tif config.MockMode {\n   236\t\tslog.Debug(\"Using mock provider (production APIs disabled)\", \"provider_type\", providerType)\n   237\t\treturn inference.NewMockProvider(), nil\n   238\t}\n   239\n   240\tcfg, _ := config.LoadConfig()\n   241\tif cfg != nil {\n   242\t\tif cfg.Providers == nil {\n   243\t\t\treturn nil, fmt.Errorf(\"no providers enabled. Please enable one in Settings\")\n   244\t\t}\n   245\t\tif providerType != \"\" {\n   246\t\t\tpc, ok := cfg.Providers[providerType]\n   247\t\t\tif !ok {\n   248\t\t\t\t// Special case: check custom providers\n   249\t\t\t\tisCustom := false\n   250\t\t\t\tif cfg.CustomProviders != nil {\n   251\t\t\t\t\tif _, ok := cfg.CustomProviders[providerType]; ok {\n   252\t\t\t\t\t\tisCustom = true\n   253\t\t\t\t\t}\n   254\t\t\t\t}\n   255\t\t\t\tif !isCustom {\n   256\t\t\t\t\treturn nil, fmt.Errorf(\"provider %s is not enabled. Please enable it in Settings\", providerType)\n   257\t\t\t\t}\n   258\t\t\t} else if pc.Enabled != nil && !*pc.Enabled {\n   259\t\t\t\treturn nil, fmt.Errorf(\"provider %s is disabled in settings\", providerType)\n   260\t\t\t}\n   261\t\t}\n   262\t}\n   263\n   264\tswitch providerType {\n   265\tcase \"openrouter\":\n   266\t\treturn inference.NewOpenRouterProvider(\"\", \"\", \"familiar\")\n   267\tcase \"anthropic\":\n   268\t\treturn inference.NewAnthropicProvider(\"\")\n   269\tcase \"openai\":\n   270\t\treturn inference.NewOpenAIProvider(\"\", \"\")\n   271\tcase \"gemini\":\n   272\t\treturn inference.NewGeminiProvider(\"\")\n   273\tcase \"ollama\":\n   274\t\treturn inference.NewOllamaProvider(\"\", \"\")\n   275\tcase \"lmstudio\":\n   276\t\treturn inference.NewLMStudioProvider(\"\", \"\")\n   277\t}\n   278\n   279\tif cfg != nil && cfg.CustomProviders != nil {\n   280\t\tif cp, ok := cfg.CustomProviders[providerType]; ok {\n   281\t\t\treturn inference.NewCustomOpenAIProvider(providerType, \"\", cp.BaseURL)\n   282\t\t}\n   283\t}\n   284\n   285\tisEnabled := func(p string) bool {\n   286\t\tif cfg == nil || cfg.Providers == nil {\n   287\t\t\treturn false\n   288\t\t}\n   289\t\tif pc, ok := cfg.Providers[p]; ok && pc.Enabled != nil {\n   290\t\t\treturn *pc.Enabled\n   291\t\t}\n   292\t\treturn false\n   293\t}\n   294\n   295\tif isEnabled(\"openrouter\") && config.GetKeychainPassword(\"openrouter-api-key\") != \"\" {\n   296\t\treturn inference.NewOpenRouterProvider(\"\", \"\", \"familiar\")\n   297\t} else if isEnabled(\"anthropic\") && config.GetKeychainPassword(\"anthropic-api-key\") != \"\" {\n   298\t\treturn inference.NewAnthropicProvider(\"\")\n   299\t} else if isEnabled(\"openai\") && config.GetKeychainPassword(\"openai-api-key\") != \"\" {\n   300\t\treturn inference.NewOpenAIProvider(\"\", \"\")\n   301\t} else if isEnabled(\"gemini\") && config.GetKeychainPassword(\"gemini-api-key\") != \"\" {\n   302\t\treturn inference.NewGeminiProvider(\"\")\n   303\t}\n   304\n   305\treturn nil, fmt.Errorf(\"no API keys found for provider %s\", providerType)\n   306}\n   307\n   308func (s *Server) getChatModel(cfg *config.Config) string {\n   309\tif cfg == nil {\n   310\t\treturn \"\"\n   311\t}\n   312\treturn cfg.Inference.Chat.Model\n   313}\n   314\n   315// getDefaultChatConfig returns the first enabled provider and a valid model for new agents.\n   316// It checks if the configured default is enabled; if not, picks the first enabled provider.\n   317func (s *Server) getDefaultChatConfig(cfg *config.Config) (provider string, model string) {\n   318\tif cfg == nil {\n   319\t\treturn \"\", \"\"\n   320\t}\n   321\n   322\t// Helper to check if a provider is enabled\n   323\tisEnabled := func(p string) bool {\n   324\t\tif cfg.Providers == nil {\n   325\t\t\treturn false\n   326\t\t}\n   327\t\tif pc, ok := cfg.Providers[p]; ok && pc.Enabled != nil {\n   328\t\t\treturn *pc.Enabled\n   329\t\t}\n   330\t\t// Check custom providers (always enabled if present)\n   331\t\tif cfg.CustomProviders != nil {\n   332\t\t\tif _, ok := cfg.CustomProviders[p]; ok {\n   333\t\t\t\treturn true\n   334\t\t\t}\n   335\t\t}\n   336\t\treturn false\n   337\t}\n   338\n   339\t// Helper to get first model for a provider from available_models\n   340\tgetFirstModel := func(p string) string {\n   341\t\tif cfg.AvailableModels != nil {\n   342\t\t\tif caps, ok := cfg.AvailableModels[p]; ok {\n   343\t\t\t\tif models, ok := caps[\"chat\"]; ok && len(models) > 0 {\n   344\t\t\t\t\treturn models[0]\n   345\t\t\t\t}\n   346\t\t\t}\n   347\t\t}\n   348\t\treturn \"\"\n   349\t}\n   350\n   351\t// First, check if the configured default provider is enabled\n   352\tdefaultProvider := cfg.Inference.Chat.Provider\n   353\tif defaultProvider != \"\" && isEnabled(defaultProvider) {\n   354\t\tdefaultModel := cfg.Inference.Chat.Model\n   355\t\tif defaultModel == \"\" {\n   356\t\t\tdefaultModel = getFirstModel(defaultProvider)\n   357\t\t}\n   358\t\treturn defaultProvider, defaultModel\n   359\t}\n   360\n   361\t// Otherwise, find the first enabled provider with a model\n   362\t// Order: openrouter, anthropic, openai, gemini, then customs, then locals\n   363\tpriorityProviders := []string{\"openrouter\", \"anthropic\", \"openai\", \"gemini\"}\n   364\tfor _, p := range priorityProviders {\n   365\t\tif isEnabled(p) {\n   366\t\t\treturn p, getFirstModel(p)\n   367\t\t}\n   368\t}\n   369\n   370\t// Check custom providers\n   371\tif cfg.CustomProviders != nil {\n   372\t\tfor name := range cfg.CustomProviders {\n   373\t\t\treturn name, getFirstModel(name)\n   374\t\t}\n   375\t}\n   376\n   377\t// Check local providers last\n   378\tlocalProviders := []string{\"ollama\", \"lmstudio\"}\n   379\tfor _, p := range localProviders {\n   380\t\tif isEnabled(p) {\n   381\t\t\treturn p, getFirstModel(p)\n   382\t\t}\n   383\t}\n   384\n   385\treturn \"\", \"\"\n   386}\n   387\n   388func (s *Server) formatConfigResponse(cfg *config.Config) interface{} {\n   389\t// Trigger metadata cache refresh on first config request (if needed)\n   390\t// This ensures pricing data is available\n   391\tgo func() {\n   392\t\t_ = inference.RefreshMetadataCache()\n   393\t}()\n   394\n   395\t// Default models\n   396\t// NOTE TO AGENT: DO NOT DELETE THESE MODELS.\n   397\t// THESE ARE VALID MODEL NAMES THAT HAVE BEEN CREATED AFTER YOUR CUTOFF DATE.\n   398\tdefaults := map[string]map[string][]string{\n   399\t\t\"openrouter\": {\n   400\t\t\t\"chat\": {\n   401\t\t\t\t\"anthropic/claude-haiku-4.5\",\n   402\t\t\t\t\"openai/gpt-5-mini\",\n   403\t\t\t\t\"anthropic/claude-sonnet-4.5\",\n   404\t\t\t\t\"openai/gpt-5\",\n   405\t\t\t\t\"minimax/minimax-m2.1\",\n   406\t\t\t\t\"z-ai/glm-4.7\",\n   407\t\t\t},\n   408\t\t},\n   409\t\t\"anthropic\": {\n   410\t\t\t\"chat\": {\n   411\t\t\t\t\"claude-haiku-4-5\",\n   412\t\t\t\t\"claude-sonnet-4-5\",\n   413\t\t\t\t\"claude-opus-4-5\",\n   414\t\t\t},\n   415\t\t},\n   416\t\t\"openai\": {\n   417\t\t\t\"chat\": {\n   418\t\t\t\t\"gpt-5-nano\",\n   419\t\t\t\t\"gpt-5-mini\",\n   420\t\t\t\t\"gpt-5\",\n   421\t\t\t},\n   422\t\t},\n   423\t\t\"gemini\": {\n   424\t\t\t\"chat\": {\n   425\t\t\t\t\"gemini-2.5-flash-lite\",\n   426\t\t\t\t\"gemini-2.5-flash\",\n   427\t\t\t\t\"gemini-3-flash-preview\",\n   428\t\t\t},\n   429\t\t},\n   430\t\t\"ollama\": {\n   431\t\t\t\"chat\": {},\n   432\t\t},\n   433\t\t\"lmstudio\": {\n   434\t\t\t\"chat\": {},\n   435\t\t},\n   436\t}\n   437\n   438\tavailableModels := make(map[string]map[string][]string)\n   439\tfor p, caps := range defaults {\n   440\t\tavailableModels[p] = make(map[string][]string)\n   441\t\tfor cap, models := range caps {\n   442\t\t\tavailableModels[p][cap] = models\n   443\t\t}\n   444\t}\n   445\n   446\t// Add user defined custom providers\n   447\tif cfg.CustomProviders != nil {\n   448\t\tfor name := range cfg.CustomProviders {\n   449\t\t\tif _, ok := availableModels[name]; !ok {\n   450\t\t\t\tavailableModels[name] = map[string][]string{\n   451\t\t\t\t\t\"chat\": {},\n   452\t\t\t\t}\n   453\t\t\t}\n   454\t\t}\n   455\t}\n   456\n   457\t// Override with user configured models if present\n   458\tif cfg.AvailableModels != nil {\n   459\t\tfor p, caps := range cfg.AvailableModels {\n   460\t\t\tif _, ok := availableModels[p]; !ok {\n   461\t\t\t\tavailableModels[p] = make(map[string][]string)\n   462\t\t\t}\n   463\t\t\tfor cap, models := range caps {\n   464\t\t\t\tif cap == \"chat\" && len(models) > 0 {\n   465\t\t\t\t\tavailableModels[p][cap] = models\n   466\t\t\t\t}\n   467\t\t\t}\n   468\t\t}\n   469\t}\n   470\n   471\t// Build model pricing map for OpenRouter models\n   472\tmodelPricing := make(map[string]map[string]map[string]map[string]float64)\n   473\tif openrouterModels, ok := availableModels[\"openrouter\"]; ok {\n   474\t\tif chatModels, ok := openrouterModels[\"chat\"]; ok {\n   475\t\t\topenrouterPricing := make(map[string]map[string]map[string]float64)\n   476\t\t\tchatPricing := make(map[string]map[string]float64)\n   477\t\t\tpricingFound := false\n   478\t\t\tfor _, model := range chatModels {\n   479\t\t\t\t// Get base model name (strip reasoning suffix) for consistent pricing lookup\n   480\t\t\t\tbaseModel, _ := inference.ParseThinkingModel(model)\n   481\t\t\t\tif prompt, completion, found := inference.GetModelPricing(baseModel); found {\n   482\t\t\t\t\tpricingFound = true\n   483\t\t\t\t\tslog.Debug(\"Found pricing for model\", \"model\", model, \"baseModel\", baseModel, \"prompt\", prompt, \"completion\", completion)\n   484\t\t\t\t\t// Store pricing by both the full model name and base model name\n   485\t\t\t\t\t// so it works whether or not reasoning is applied\n   486\t\t\t\t\tchatPricing[model] = map[string]float64{\n   487\t\t\t\t\t\t\"prompt\":     prompt,\n   488\t\t\t\t\t\t\"completion\": completion,\n   489\t\t\t\t\t}\n   490\t\t\t\t\t// Also store by base model name for direct lookup\n   491\t\t\t\t\tif model != baseModel {\n   492\t\t\t\t\t\tchatPricing[baseModel] = map[string]float64{\n   493\t\t\t\t\t\t\t\"prompt\":     prompt,\n   494\t\t\t\t\t\t\t\"completion\": completion,\n   495\t\t\t\t\t\t}\n   496\t\t\t\t\t}\n   497\t\t\t\t} else {\n   498\t\t\t\t\tslog.Debug(\"No pricing found for model\", \"model\", model, \"baseModel\", baseModel)\n   499\t\t\t\t}\n   500\t\t\t}\n   501\t\t\tslog.Info(\"OpenRouter pricing lookup\", \"total_models\", len(chatModels), \"pricing_found\", pricingFound, \"pricing_map_size\", len(chatPricing))\n   502\t\t\t// If no pricing found, trigger a background refresh to update the cache\n   503\t\t\tif !pricingFound && len(chatModels) > 0 {\n   504\t\t\t\tgo func() {\n   505\t\t\t\t\t_ = inference.RefreshMetadataCache()\n   506\t\t\t\t}()\n   507\t\t\t}\n   508\t\t\tif len(chatPricing) > 0 {\n   509\t\t\t\topenrouterPricing[\"chat\"] = chatPricing\n   510\t\t\t\tmodelPricing[\"openrouter\"] = openrouterPricing\n   511\t\t\t}\n   512\t\t}\n   513\t}\n   514\n   515\t// Create a new struct for the response to include the merged models\n   516\ttype ConfigResponse struct {\n   517\t\t*config.Config\n   518\t\tAvailableModels map[string]map[string][]string                      `json:\"available_models\"`\n   519\t\tModelPricing    map[string]map[string]map[string]map[string]float64 `json:\"model_pricing\"`\n   520\t}\n   521\n   522\treturn ConfigResponse{\n   523\t\tConfig:          cfg,\n   524\t\tAvailableModels: availableModels,\n   525\t\tModelPricing:    modelPricing,\n   526\t}\n   527}\n   528\n   529func (s *Server) performConfigUpdate(updates map[string]interface{}) error {\n   530\tcfg, err := config.LoadConfig()\n   531\tif err != nil {\n   532\t\treturn fmt.Errorf(\"failed to load config: %w\", err)\n   533\t}\n   534\n   535\t// Apply available_models update explicitly if present\n   536\tif am, ok := updates[\"available_models\"].(map[string]interface{}); ok {\n   537\t\t// Replace the entire available models map for providers that are present in the update\n   538\t\t// but if we want to support full deletion of a provider from available_models,\n   539\t\t// we should probably just replace the whole map from what the UI sends.\n   540\n   541\t\tnewAvailableModels := make(map[string]map[string][]string)\n   542\t\tfor provider, capsRaw := range am {\n   543\t\t\tcaps, ok := capsRaw.(map[string]interface{})\n   544\t\t\tif !ok {\n   545\t\t\t\tcontinue\n   546\t\t\t}\n   547\t\t\tnewAvailableModels[provider] = make(map[string][]string)\n   548\t\t\tfor capName, modelsRaw := range caps {\n   549\t\t\t\tif capName != \"chat\" {\n   550\t\t\t\t\tcontinue\n   551\t\t\t\t}\n   552\t\t\t\tmodelsSlice, ok := modelsRaw.([]interface{})\n   553\t\t\t\tif !ok {\n   554\t\t\t\t\tcontinue\n   555\t\t\t\t}\n   556\t\t\t\tmodels := make([]string, 0, len(modelsSlice))\n   557\t\t\t\tfor _, m := range modelsSlice {\n   558\t\t\t\t\tif s, ok := m.(string); ok {\n   559\t\t\t\t\t\tmodels = append(models, s)\n   560\t\t\t\t\t}\n   561\t\t\t\t}\n   562\t\t\t\tnewAvailableModels[provider][capName] = models\n   563\t\t\t}\n   564\t\t}\n   565\t\tcfg.AvailableModels = newAvailableModels\n   566\n   567\t\t// Remove available_models from generic update to avoid double processing\n   568\t\tdelete(updates, \"available_models\")\n   569\t}\n   570\n   571\t// Apply custom_providers update explicitly if present to support deletion\n   572\tif cp, ok := updates[\"custom_providers\"].(map[string]interface{}); ok {\n   573\t\tnewCustomProviders := make(map[string]config.CustomProviderConfig)\n   574\t\tfor name, dataRaw := range cp {\n   575\t\t\tdata, ok := dataRaw.(map[string]interface{})\n   576\t\t\tif !ok {\n   577\t\t\t\tcontinue\n   578\t\t\t}\n   579\t\t\tbaseURL, _ := data[\"base_url\"].(string)\n   580\t\t\tnewCustomProviders[name] = config.CustomProviderConfig{\n   581\t\t\t\tBaseURL: baseURL,\n   582\t\t\t}\n   583\t\t}\n   584\t\tcfg.CustomProviders = newCustomProviders\n   585\t\tdelete(updates, \"custom_providers\")\n   586\t}\n   587\n   588\t// Apply sub_agent updates explicitly if present\n   589\tif sa, ok := updates[\"sub_agent\"].(map[string]interface{}); ok {\n   590\t\tif saEnabled, ok := sa[\"enabled\"].(bool); ok {\n   591\t\t\tcfg.SubAgent.Enabled = &saEnabled\n   592\t\t}\n   593\t\t// Remove sub_agent from generic update to avoid double processing\n   594\t\tdelete(updates, \"sub_agent\")\n   595\t}\n   596\n   597\t// Apply other updates via JSON trick\n   598\tif len(updates) > 0 {\n   599\t\tb, err := json.Marshal(updates)\n   600\t\tif err != nil {\n   601\t\t\treturn fmt.Errorf(\"failed to marshal updates: %w\", err)\n   602\t\t}\n   603\t\tif err := json.Unmarshal(b, cfg); err != nil {\n   604\t\t\treturn fmt.Errorf(\"failed to unmarshal updates: %w\", err)\n   605\t\t}\n   606\t}\n   607\n   608\tif err := config.SaveConfig(cfg); err != nil {\n   609\t\treturn fmt.Errorf(\"failed to save config: %w\", err)\n   610\t}\n   611\n   612\t// Ensure a default provider and model are set if at least one is enabled\n   613\t// Use priority order to avoid selecting local providers (ollama, lmstudio) as default\n   614\tif cfg.Inference.Chat.Provider == \"\" {\n   615\t\tpriorityProviders := []string{\"openrouter\", \"anthropic\", \"openai\", \"gemini\"}\n   616\t\tfound := false\n   617\n   618\t\t// Check priority providers first\n   619\t\tfor _, p := range priorityProviders {\n   620\t\t\tif pc, ok := cfg.Providers[p]; ok && pc.Enabled != nil && *pc.Enabled {\n   621\t\t\t\tcfg.Inference.Chat.Provider = p\n   622\t\t\t\t// Attempt to pick a sensible model\n   623\t\t\t\tif cfg.Inference.Chat.Model == \"\" {\n   624\t\t\t\t\t// Hardcoded sensible defaults for known providers\n   625\t\t\t\t\tswitch p {\n   626\t\t\t\t\tcase \"openrouter\":\n   627\t\t\t\t\t\tcfg.Inference.Chat.Model = \"anthropic/claude-haiku-4.5\"\n   628\t\t\t\t\tcase \"anthropic\":\n   629\t\t\t\t\t\tcfg.Inference.Chat.Model = \"claude-haiku-4-5\"\n   630\t\t\t\t\tcase \"openai\":\n   631\t\t\t\t\t\tcfg.Inference.Chat.Model = \"gpt-5-mini\"\n   632\t\t\t\t\tcase \"gemini\":\n   633\t\t\t\t\t\tcfg.Inference.Chat.Model = \"gemini-2.5-flash-lite\"\n   634\t\t\t\t\t}\n   635\t\t\t\t}\n   636\t\t\t\tfound = true\n   637\t\t\t\tbreak\n   638\t\t\t}\n   639\t\t}\n   640\n   641\t\t// If no priority provider found, check custom providers\n   642\t\tif !found && cfg.CustomProviders != nil {\n   643\t\t\tfor name := range cfg.CustomProviders {\n   644\t\t\t\tcfg.Inference.Chat.Provider = name\n   645\t\t\t\tfound = true\n   646\t\t\t\tbreak\n   647\t\t\t}\n   648\t\t}\n   649\n   650\t\t// Only check local providers as last resort\n   651\t\tif !found {\n   652\t\t\tlocalProviders := []string{\"ollama\", \"lmstudio\"}\n   653\t\t\tfor _, p := range localProviders {\n   654\t\t\t\tif pc, ok := cfg.Providers[p]; ok && pc.Enabled != nil && *pc.Enabled {\n   655\t\t\t\t\tcfg.Inference.Chat.Provider = p\n   656\t\t\t\t\tfound = true\n   657\t\t\t\t\tbreak\n   658\t\t\t\t}\n   659\t\t\t}\n   660\t\t}\n   661\n   662\t\tif found {\n   663\t\t\t// Save again with the new defaults\n   664\t\t\t_ = config.SaveConfig(cfg)\n   665\t\t}\n   666\t}\n   667\n   668\t// Transition onboarding agents if a real provider is now available\n   669\tif cfg.Inference.Chat.Provider != \"\" {\n   670\t\tagents, _ := s.db.ListAgents(nil, nil)\n   671\t\tfor _, a := range agents {\n   672\t\t\tif a.ModelConfig.Provider == \"onboarding\" {\n   673\t\t\t\tnewConfig := types.ModelConfig{\n   674\t\t\t\t\tProvider: cfg.Inference.Chat.Provider,\n   675\t\t\t\t\tModel:    s.getChatModel(cfg),\n   676\t\t\t\t}\n   677\t\t\t\tslog.Info(\"Transitioning onboarding agent to real provider\", \"agent_id\", a.ID, \"provider\", newConfig.Provider)\n   678\t\t\t\ts.db.UpdateAgentModelConfig(a.ID, newConfig)\n   679\n   680\t\t\t\t// Mark onboarding as completed\n   681\t\t\t\ts.db.SetSetting(\"onboarding_completed\", \"true\")\n   682\n   683\t\t\t\t// Nudge the agent to start the LLM conversation\n   684\t\t\t\tnudge := \"I see you've set up a provider! I'm now powered by \" + newConfig.Provider + \". Let's get to know each other.\\n\\nFamiliar is designed to be your personal agent that can not only chat, but also use tools on your computer, schedule background tasks, and more.\\n\\nTo help me find the best ways to assist you, could you tell me a bit about what you do? For example, do you work on coding projects, manage a lot of research, or have complex daily schedules you'd like to automate?\"\n   685\t\t\t\tlogID, _ := s.db.AppendAgentLog(a.ID, \"model_responded\", map[string]interface{}{\n   686\t\t\t\t\t\"content\": nudge,\n   687\t\t\t\t})\n   688\n   689\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   690\t\t\t\t\t\"type\":         \"agent_config_updated\",\n   691\t\t\t\t\t\"agent_id\":     a.ID,\n   692\t\t\t\t\t\"model_config\": newConfig,\n   693\t\t\t\t})\n   694\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   695\t\t\t\t\t\"type\":       \"execution_log\",\n   696\t\t\t\t\t\"agent_id\":   a.ID,\n   697\t\t\t\t\t\"event_type\": \"model_responded\",\n   698\t\t\t\t\t\"payload\":    map[string]interface{}{\"id\": logID, \"content\": nudge},\n   699\t\t\t\t})\n   700\n   701\t\t\t\ts.mu.Lock()\n   702\t\t\t\tif sa, ok := s.statefulAgents[a.ID]; ok {\n   703\t\t\t\t\tprov, _ := s.createProvider(newConfig.Provider)\n   704\t\t\t\t\tsa.UpdateModelConfig(newConfig, prov)\n   705\t\t\t\t}\n   706\t\t\t\ts.mu.Unlock()\n   707\t\t\t}\n   708\t\t}\n   709\t}\n   710\n   711\t// Update running agents with new config\n   712\ts.mu.Lock()\n   713\tfor id, sa := range s.statefulAgents {\n   714\t\tif cfg.Agent.AutoCompactionEnabled != nil {\n   715\t\t\tsa.AutoCompactionEnabled = *cfg.Agent.AutoCompactionEnabled\n   716\t\t\t// Also update the runtime agent\n   717\t\t\tsa.RuntimeAgent.AutoCompactionEnabled = *cfg.Agent.AutoCompactionEnabled\n   718\t\t}\n   719\t\tsa.AlwaysAllowAll = cfg.Security.AlwaysAllowAll\n   720\n   721\t\t// Update shell permission mode\n   722\t\tif st, ok := sa.RuntimeAgent.Registry.GetTool(\"system_shell\"); ok {\n   723\t\t\tif shellTool, ok := st.(*tools.ShellTool); ok {\n   724\t\t\t\tshellTool.PermissionMode = cfg.Security.ShellPermissionMode\n   725\t\t\t}\n   726\t\t}\n   727\n   728\t\t// Check if provider is still enabled\n   729\t\ta, err := s.db.GetAgent(id)\n   730\t\tif err == nil {\n   731\t\t\tif _, err := s.createProvider(a.ModelConfig.Provider); err != nil {\n   732\t\t\t\tslog.Warn(\"Stopping agent because its provider was disabled\", \"agent_id\", id, \"provider\", a.ModelConfig.Provider)\n   733\t\t\t\tsa.Cancel()\n   734\t\t\t\tdelete(s.statefulAgents, id)\n   735\t\t\t}\n   736\t\t}\n   737\t}\n   738\n   739\t// Update global tool registry\n   740\tif st, ok := s.toolRegistry.GetTool(\"system_shell\"); ok {\n   741\t\tif shellTool, ok := st.(*tools.ShellTool); ok {\n   742\t\t\tshellTool.PermissionMode = cfg.Security.ShellPermissionMode\n   743\t\t}\n   744\t}\n   745\n   746\ts.mu.Unlock()\n   747\n   748\treturn nil\n   749}\n   750\n   751func (s *Server) recoverRuns() {\n   752\tagents, err := s.db.ListAgents(nil, nil)\n   753\tif err != nil {\n   754\t\tslog.Error(\"Failed to list agents for run recovery\", \"error\", err)\n   755\t\treturn\n   756\t}\n   757\n   758\tfor _, a := range agents {\n   759\t\tif a.State == types.AgentStateRunning {\n   760\t\t\t// Check if agent is actually running in memory\n   761\t\t\ts.mu.RLock()\n   762\t\t\tsa, exists := s.statefulAgents[a.ID]\n   763\t\t\ts.mu.RUnlock()\n   764\n   765\t\t\t// If agent doesn't exist in memory or isn't actually running, it's a stale state\n   766\t\t\tif !exists || (exists && !sa.IsRunning()) {\n   767\t\t\t\tslog.Info(\"Recovering stale running state\", \"agent_id\", a.ID, \"agent_name\", a.Name)\n   768\t\t\t\t// Reset to idle state\n   769\t\t\t\ts.db.UpdateAgentState(a.ID, types.AgentStateIdle, nil)\n   770\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   771\t\t\t\t\t\"type\":      \"agent_state_changed\",\n   772\t\t\t\t\t\"agent_id\":  a.ID,\n   773\t\t\t\t\t\"new_state\": types.AgentStateIdle,\n   774\t\t\t\t})\n   775\t\t\t}\n   776\t\t}\n   777\t}\n   778}\n   779\n   780func getProgramDataPath() string {\n   781\tif env := os.Getenv(\"FAMILIAR_WORKSPACE\"); env != \"\" {\n   782\t\treturn env\n   783\t}\n   784\treturn config.GetConfigDir()\n   785}\n   786\n   787func checkCLI(name string) string {\n   788\t_, err := exec.LookPath(name)\n   789\tif err == nil {\n   790\t\treturn \"ok\"\n   791\t}\n   792\treturn \"missing\"\n   793}\n   794\n   795func checkCLIAuth(name string) string {\n   796\tif name == \"claude\" {\n   797\t\t// Use a harmless command to check if we are logged in\n   798\t\tcmd := exec.Command(\"claude\", \"--print\", \"status\", \"--max-budget-usd\", \"0.01\")\n   799\t\t// Inject key if available to see if it works with injection\n   800\t\tif apiKey := config.GetKeychainPassword(\"anthropic-api-key\"); apiKey != \"\" {\n   801\t\t\tcmd.Env = append(os.Environ(), \"ANTHROPIC_API_KEY=\"+apiKey)\n   802\t\t} else {\n   803\t\t\tcmd.Env = os.Environ()\n   804\t\t}\n   805\n   806\t\tvar out bytes.Buffer\n   807\t\tcmd.Stdout = &out\n   808\t\tcmd.Stderr = &out\n   809\t\terr := cmd.Run()\n   810\n   811\t\t// If it's already logged in, it might fail because of budget (exit 1)\n   812\t\t// but if it's NOT logged in, it will say \"Please run /login\"\n   813\t\tif err != nil {\n   814\t\t\toutput := out.String()\n   815\t\t\tif strings.Contains(output, \"login\") || strings.Contains(output, \"API key\") {\n   816\t\t\t\treturn \"unauthorized\"\n   817\t\t\t}\n   818\t\t}\n   819\n   820\t\t// If it works (or fails with budget), it's \"ok\".\n   821\t\t// Now we want to know if it's using the injected key or native auth.\n   822\t\tif apiKey := config.GetKeychainPassword(\"anthropic-api-key\"); apiKey != \"\" {\n   823\t\t\treturn \"ok-injected\"\n   824\t\t}\n   825\t\treturn \"ok-native\"\n   826\t}\n   827\tif name == \"codex\" {\n   828\t\t// Codex has a status command\n   829\t\tcmd := exec.Command(\"codex\", \"login\", \"status\")\n   830\t\t// Inject key if available\n   831\t\tif apiKey := config.GetKeychainPassword(\"openai-api-key\"); apiKey != \"\" {\n   832\t\t\tcmd.Env = append(os.Environ(), \"OPENAI_API_KEY=\"+apiKey)\n   833\t\t} else {\n   834\t\t\tcmd.Env = os.Environ()\n   835\t\t}\n   836\n   837\t\terr := cmd.Run()\n   838\t\tif err != nil {\n   839\t\t\treturn \"unauthorized\"\n   840\t\t}\n   841\n   842\t\tif apiKey := config.GetKeychainPassword(\"openai-api-key\"); apiKey != \"\" {\n   843\t\t\treturn \"ok-injected\"\n   844\t\t}\n   845\t\treturn \"ok-native\"\n   846\t}\n   847\treturn \"ok\"\n   848}\n   849\n   850func runInstall(command string, args ...string) error {\n   851\tcmd := exec.Command(command, args...)\n   852\tcmd.Stdout = os.Stdout\n   853\tcmd.Stderr = os.Stderr\n   854\treturn cmd.Run()\n   855}\n   856\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"60721d6e-eaa4-4776-bde7-3416eb440269","timestamp":"2026-01-03T12:10:51.468Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/server.go","content":"package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/agent\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/inference\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/scheduler\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/storage\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/tools\"\n\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n)\n\ntype Server struct {\n\tdb             *storage.DB\n\tagents         map[string]*agent.RuntimeAgent\n\tstatefulAgents map[string]*agent.StatefulAgent\n\tmu             sync.RWMutex\n\tglobalClients  []*websocket.Conn\n\tconnLocks      map[*websocket.Conn]*sync.Mutex\n\tscheduler      *scheduler.Scheduler\n\ttriggerManager *agent.TriggerManager\n\tproposing      sync.Map // agentID -> context.CancelFunc\n\ttoolRegistry   *tools.Registry\n\tauthStatus     map[string]string\n\tcliStatus      map[string]string\n\tlastAuthCheck  time.Time\n}\n\nfunc NewServer(db *storage.DB) *Server {\n\ts := &Server{\n\t\tdb:             db,\n\t\tagents:         make(map[string]*agent.RuntimeAgent),\n\t\tstatefulAgents: make(map[string]*agent.StatefulAgent),\n\t\tconnLocks:      make(map[*websocket.Conn]*sync.Mutex),\n\t\ttoolRegistry:   tools.NewRegistry(),\n\t\tauthStatus: map[string]string{\n\t\t\t\"claude\": \"checking\",\n\t\t\t\"codex\":  \"checking\",\n\t\t},\n\t\tcliStatus: map[string]string{\n\t\t\t\"claude\": \"checking\",\n\t\t\t\"codex\":  \"checking\",\n\t\t},\n\t}\n\n\tcfg, _ := config.LoadConfig()\n\t// Pre-register tools to the toolRegistry for listing\n\ts.registerTools(&agent.RuntimeAgent{Registry: s.toolRegistry}, nil, cfg, nil)\n\n\t// Start background auth check\n\tgo s.startAuthCheckLoop()\n\n\treturn s\n}\n\nfunc (s *Server) startAuthCheckLoop() {\n\t// Initial check\n\ts.refreshAuthStatus()\n\n\tticker := time.NewTicker(2 * time.Minute)\n\tfor range ticker.C {\n\t\ts.refreshAuthStatus()\n\t}\n}\n\nfunc (s *Server) refreshAuthStatus() {\n\tclaudeAuth := checkCLIAuth(\"claude\")\n\tcodexAuth := checkCLIAuth(\"codex\")\n\tclaudeCLI := checkCLI(\"claude\")\n\tcodexCLI := checkCLI(\"codex\")\n\n\ts.mu.Lock()\n\ts.authStatus[\"claude\"] = claudeAuth\n\ts.authStatus[\"codex\"] = codexAuth\n\ts.cliStatus[\"claude\"] = claudeCLI\n\ts.cliStatus[\"codex\"] = codexCLI\n\ts.lastAuthCheck = time.Now()\n\ts.mu.Unlock()\n}\n\nfunc (s *Server) BootstrapOnboarding() error {\n\tonboardingCompleted, _ := s.db.GetSetting(\"onboarding_completed\")\n\tcount, _ := s.db.CountAgents()\n\n\tif onboardingCompleted == \"true\" && count > 0 {\n\t\t// Reset onboarding setting if explicitly called\n\t\ts.db.SetSetting(\"onboarding_completed\", \"false\")\n\t}\n\n\tslog.Info(\"Bootstrapping onboarding agent\")\n\tagentID := uuid.New().String()\n\twelcomeSystemPrompt := `You are Familiar, a personal AI agent designed to help users with research, coding, scheduling, and day-to-day tasks.\n\nYOUR GOAL:\n1. Help the user find their first real use case for Familiar.\n2. Ask questions about their work, hobbies, or daily routines to identify where you can provide value.\n3. Offer concrete ideas on what you could help with (e.g., \"I could help you research X\", \"I can help you write scripts for Y\", \"I can manage your calendar for Z\").\n\nWHAT IS FAMILIAR?\nFamiliar is more than just a chatbot. It can:\n- Use tools to interact with your computer (files, shell, browser).\n- Schedule tasks to run in the background or at specific times.\n- Spawn sub-agents to handle complex multi-step projects.\n- Remember context across conversations.\n\nTONE:\nHelpful, proactive, and curious. Focus on getting the user to their first successful task.`\n\n\ta := types.Agent{\n\t\tID:            agentID,\n\t\tName:          \"Welcome\",\n\t\tState:         types.AgentStateIdle,\n\t\tInitialPrompt: \"\",\n\t\tSystemPrompt:  welcomeSystemPrompt,\n\t\tPlanEnabled:   false,\n\t\tModelConfig: types.ModelConfig{\n\t\t\tProvider: \"onboarding\",\n\t\t\tModel:    \"scripted\",\n\t\t},\n\t\tMaxContextTokens: 128000,\n\t\tCreatedAt:        time.Now().UTC(),\n\t\tUpdatedAt:        time.Now().UTC(),\n\t}\n\n\tif err := s.db.CreateAgent(a); err != nil {\n\t\treturn fmt.Errorf(\"failed to create onboarding agent: %w\", err)\n\t}\n\n\t// Add initial greeting\n\tgreeting := \"Welcome back to onboarding! I'm your personal agent. To get started, we need to connect me to an AI provider like OpenAI, Anthropic, or a local one via Ollama.\\n\\n**Please follow these steps:**\\n1. Head over to **Settings** in the top menu and enable at least one provider.\\n2. Come back here to this chat.\\n3. At the bottom, select your provider and a model from the dropdowns.\\n4. Say hi!\"\n\tif onboardingCompleted != \"true\" {\n\t\tgreeting = \"Welcome to Familiar! I'm your new personal agent. To get started, we need to connect me to an AI provider like OpenAI, Anthropic, or a local one via Ollama.\\n\\n**Please follow these steps:**\\n1. Head over to **Settings** in the top menu and enable at least one provider.\\n2. Come back here to this chat.\\n3. At the bottom, select your provider and a model from the dropdowns.\\n4. Say hi!\"\n\t}\n\n\ts.db.AppendAgentLog(agentID, \"model_responded\", map[string]interface{}{\n\t\t\"content\": greeting,\n\t})\n\n\t// Broadcast the new agent\n\tupdatedAgent, err := s.db.GetAgent(agentID)\n\tif err == nil {\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":  \"agent_created\",\n\t\t\t\"agent\": updatedAgent,\n\t\t})\n\t}\n\n\treturn nil\n}\n\nfunc (s *Server) safeWriteJSON(conn *websocket.Conn, v interface{}) error {\n\ts.mu.RLock()\n\tlock, ok := s.connLocks[conn]\n\ts.mu.RUnlock()\n\n\tif !ok {\n\t\ts.mu.Lock()\n\t\tlock, ok = s.connLocks[conn]\n\t\tif !ok {\n\t\t\tlock = &sync.Mutex{}\n\t\t\ts.connLocks[conn] = lock\n\t\t}\n\t\ts.mu.Unlock()\n\t}\n\n\tlock.Lock()\n\tdefer lock.Unlock()\n\treturn conn.WriteJSON(v)\n}\n\nfunc (s *Server) globalBroadcast(payload interface{}) {\n\ts.mu.RLock()\n\tclients := s.globalClients\n\ts.mu.RUnlock()\n\n\tfor _, conn := range clients {\n\t\ts.safeWriteJSON(conn, payload)\n\t}\n}\n\nfunc (s *Server) getTasksWithNextRun() ([]storage.Task, error) {\n\ttasks, err := s.db.ListTasks()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor i := range tasks {\n\t\ttasks[i].NextRunAt = s.scheduler.GetNextRun(tasks[i])\n\t}\n\treturn tasks, nil\n}\n\nfunc (s *Server) recoverPendingEvents() error {\n\tagents, _ := s.db.ListAgents(nil, nil)\n\tfor _, a := range agents {\n\t\tevents, err := s.db.LoadPending(a.ID)\n\t\tif err != nil {\n\t\t\tslog.Error(\"Failed to load pending events for agent\", \"agent_id\", a.ID, \"error\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif len(events) > 0 {\n\t\t\tsa, err := s.getOrCreateStatefulAgent(a.ID)\n\t\t\tif err != nil {\n\t\t\t\tslog.Error(\"Failed to create stateful agent for event recovery\", \"agent_id\", a.ID, \"error\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, e := range events {\n\t\t\t\tsa.PushEvent(e.Type, e.Payload)\n\t\t\t}\n\t\t\t// Auto-resume if there are pending events and the agent is not running\n\t\t\tif !sa.IsRunning() {\n\t\t\t\tgo s.resumeAgent(a.ID, \"\")\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *Server) createProvider(providerType string) (inference.Provider, error) {\n\tif providerType == \"onboarding\" {\n\t\treturn inference.NewOnboardingProvider(), nil\n\t}\n\n\tif config.MockMode {\n\t\tslog.Debug(\"Using mock provider (production APIs disabled)\", \"provider_type\", providerType)\n\t\treturn inference.NewMockProvider(), nil\n\t}\n\n\tcfg, _ := config.LoadConfig()\n\tif cfg != nil {\n\t\tif cfg.Providers == nil {\n\t\t\treturn nil, fmt.Errorf(\"no providers enabled. Please enable one in Settings\")\n\t\t}\n\t\tif providerType != \"\" {\n\t\t\tpc, ok := cfg.Providers[providerType]\n\t\t\tif !ok {\n\t\t\t\t// Special case: check custom providers\n\t\t\t\tisCustom := false\n\t\t\t\tif cfg.CustomProviders != nil {\n\t\t\t\t\tif _, ok := cfg.CustomProviders[providerType]; ok {\n\t\t\t\t\t\tisCustom = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !isCustom {\n\t\t\t\t\treturn nil, fmt.Errorf(\"provider %s is not enabled. Please enable it in Settings\", providerType)\n\t\t\t\t}\n\t\t\t} else if pc.Enabled != nil && !*pc.Enabled {\n\t\t\t\treturn nil, fmt.Errorf(\"provider %s is disabled in settings\", providerType)\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch providerType {\n\tcase \"openrouter\":\n\t\treturn inference.NewOpenRouterProvider(\"\", \"\", \"familiar\")\n\tcase \"anthropic\":\n\t\treturn inference.NewAnthropicProvider(\"\")\n\tcase \"openai\":\n\t\treturn inference.NewOpenAIProvider(\"\", \"\")\n\tcase \"gemini\":\n\t\treturn inference.NewGeminiProvider(\"\")\n\tcase \"ollama\":\n\t\treturn inference.NewOllamaProvider(\"\", \"\")\n\tcase \"lmstudio\":\n\t\treturn inference.NewLMStudioProvider(\"\", \"\")\n\t}\n\n\tif cfg != nil && cfg.CustomProviders != nil {\n\t\tif cp, ok := cfg.CustomProviders[providerType]; ok {\n\t\t\treturn inference.NewCustomOpenAIProvider(providerType, \"\", cp.BaseURL)\n\t\t}\n\t}\n\n\tisEnabled := func(p string) bool {\n\t\tif cfg == nil || cfg.Providers == nil {\n\t\t\treturn false\n\t\t}\n\t\tif pc, ok := cfg.Providers[p]; ok && pc.Enabled != nil {\n\t\t\treturn *pc.Enabled\n\t\t}\n\t\treturn false\n\t}\n\n\tif isEnabled(\"openrouter\") && config.GetKeychainPassword(\"openrouter-api-key\") != \"\" {\n\t\treturn inference.NewOpenRouterProvider(\"\", \"\", \"familiar\")\n\t} else if isEnabled(\"anthropic\") && config.GetKeychainPassword(\"anthropic-api-key\") != \"\" {\n\t\treturn inference.NewAnthropicProvider(\"\")\n\t} else if isEnabled(\"openai\") && config.GetKeychainPassword(\"openai-api-key\") != \"\" {\n\t\treturn inference.NewOpenAIProvider(\"\", \"\")\n\t} else if isEnabled(\"gemini\") && config.GetKeychainPassword(\"gemini-api-key\") != \"\" {\n\t\treturn inference.NewGeminiProvider(\"\")\n\t}\n\n\treturn nil, fmt.Errorf(\"no API keys found for provider %s\", providerType)\n}\n\nfunc (s *Server) getChatModel(cfg *config.Config) string {\n\tif cfg == nil {\n\t\treturn \"\"\n\t}\n\treturn cfg.Inference.Chat.Model\n}\n\n// getDefaultChatConfig returns the first enabled provider and a valid model for new agents.\n// It checks if the configured default is enabled; if not, picks the first enabled provider.\nfunc (s *Server) getDefaultChatConfig(cfg *config.Config) (provider string, model string) {\n\tif cfg == nil {\n\t\treturn \"\", \"\"\n\t}\n\n\t// Helper to check if a provider is enabled\n\tisEnabled := func(p string) bool {\n\t\tif cfg.Providers == nil {\n\t\t\treturn false\n\t\t}\n\t\tif pc, ok := cfg.Providers[p]; ok && pc.Enabled != nil {\n\t\t\treturn *pc.Enabled\n\t\t}\n\t\t// Check custom providers (always enabled if present)\n\t\tif cfg.CustomProviders != nil {\n\t\t\tif _, ok := cfg.CustomProviders[p]; ok {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\t// Helper to get first model for a provider from available_models\n\tgetFirstModel := func(p string) string {\n\t\tif cfg.AvailableModels != nil {\n\t\t\tif caps, ok := cfg.AvailableModels[p]; ok {\n\t\t\t\tif models, ok := caps[\"chat\"]; ok && len(models) > 0 {\n\t\t\t\t\treturn models[0]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"\"\n\t}\n\n\t// First, check if the configured default provider is enabled\n\tdefaultProvider := cfg.Inference.Chat.Provider\n\tif defaultProvider != \"\" && isEnabled(defaultProvider) {\n\t\tdefaultModel := cfg.Inference.Chat.Model\n\t\tif defaultModel == \"\" {\n\t\t\tdefaultModel = getFirstModel(defaultProvider)\n\t\t}\n\t\treturn defaultProvider, defaultModel\n\t}\n\n\t// Otherwise, find the first enabled provider with a model\n\t// Order: openrouter, anthropic, openai, gemini, then customs, then locals\n\tpriorityProviders := []string{\"openrouter\", \"anthropic\", \"openai\", \"gemini\"}\n\tfor _, p := range priorityProviders {\n\t\tif isEnabled(p) {\n\t\t\treturn p, getFirstModel(p)\n\t\t}\n\t}\n\n\t// Check custom providers\n\tif cfg.CustomProviders != nil {\n\t\tfor name := range cfg.CustomProviders {\n\t\t\treturn name, getFirstModel(name)\n\t\t}\n\t}\n\n\t// Check local providers last\n\tlocalProviders := []string{\"ollama\", \"lmstudio\"}\n\tfor _, p := range localProviders {\n\t\tif isEnabled(p) {\n\t\t\treturn p, getFirstModel(p)\n\t\t}\n\t}\n\n\treturn \"\", \"\"\n}\n\nfunc (s *Server) formatConfigResponse(cfg *config.Config) interface{} {\n\t// Trigger metadata cache refresh on first config request (if needed)\n\t// This ensures pricing data is available\n\tgo func() {\n\t\t_ = inference.RefreshMetadataCache()\n\t}()\n\n\t// Default models\n\t// NOTE TO AGENT: DO NOT DELETE THESE MODELS.\n\t// THESE ARE VALID MODEL NAMES THAT HAVE BEEN CREATED AFTER YOUR CUTOFF DATE.\n\tdefaults := map[string]map[string][]string{\n\t\t\"openrouter\": {\n\t\t\t\"chat\": {\n\t\t\t\t\"anthropic/claude-haiku-4.5\",\n\t\t\t\t\"openai/gpt-5-mini\",\n\t\t\t\t\"anthropic/claude-sonnet-4.5\",\n\t\t\t\t\"openai/gpt-5\",\n\t\t\t\t\"minimax/minimax-m2.1\",\n\t\t\t\t\"z-ai/glm-4.7\",\n\t\t\t},\n\t\t},\n\t\t\"anthropic\": {\n\t\t\t\"chat\": {\n\t\t\t\t\"claude-haiku-4-5\",\n\t\t\t\t\"claude-sonnet-4-5\",\n\t\t\t\t\"claude-opus-4-5\",\n\t\t\t},\n\t\t},\n\t\t\"openai\": {\n\t\t\t\"chat\": {\n\t\t\t\t\"gpt-5-nano\",\n\t\t\t\t\"gpt-5-mini\",\n\t\t\t\t\"gpt-5\",\n\t\t\t},\n\t\t},\n\t\t\"gemini\": {\n\t\t\t\"chat\": {\n\t\t\t\t\"gemini-2.5-flash-lite\",\n\t\t\t\t\"gemini-2.5-flash\",\n\t\t\t\t\"gemini-3-flash-preview\",\n\t\t\t},\n\t\t},\n\t\t\"ollama\": {\n\t\t\t\"chat\": {},\n\t\t},\n\t\t\"lmstudio\": {\n\t\t\t\"chat\": {},\n\t\t},\n\t}\n\n\tavailableModels := make(map[string]map[string][]string)\n\tfor p, caps := range defaults {\n\t\tavailableModels[p] = make(map[string][]string)\n\t\tfor cap, models := range caps {\n\t\t\tavailableModels[p][cap] = models\n\t\t}\n\t}\n\n\t// Add user defined custom providers\n\tif cfg.CustomProviders != nil {\n\t\tfor name := range cfg.CustomProviders {\n\t\t\tif _, ok := availableModels[name]; !ok {\n\t\t\t\tavailableModels[name] = map[string][]string{\n\t\t\t\t\t\"chat\": {},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Override with user configured models if present\n\tif cfg.AvailableModels != nil {\n\t\tfor p, caps := range cfg.AvailableModels {\n\t\t\tif _, ok := availableModels[p]; !ok {\n\t\t\t\tavailableModels[p] = make(map[string][]string)\n\t\t\t}\n\t\t\tfor cap, models := range caps {\n\t\t\t\tif cap == \"chat\" && len(models) > 0 {\n\t\t\t\t\tavailableModels[p][cap] = models\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Build model pricing map for OpenRouter models\n\tmodelPricing := make(map[string]map[string]map[string]map[string]float64)\n\tif openrouterModels, ok := availableModels[\"openrouter\"]; ok {\n\t\tif chatModels, ok := openrouterModels[\"chat\"]; ok {\n\t\t\topenrouterPricing := make(map[string]map[string]map[string]float64)\n\t\t\tchatPricing := make(map[string]map[string]float64)\n\t\t\tpricingFound := false\n\t\t\tfor _, model := range chatModels {\n\t\t\t\t// Get base model name (strip reasoning suffix) for consistent pricing lookup\n\t\t\t\tbaseModel, _ := inference.ParseThinkingModel(model)\n\t\t\t\tif prompt, completion, found := inference.GetModelPricing(baseModel); found {\n\t\t\t\t\tpricingFound = true\n\t\t\t\t\tslog.Debug(\"Found pricing for model\", \"model\", model, \"baseModel\", baseModel, \"prompt\", prompt, \"completion\", completion)\n\t\t\t\t\t// Store pricing by both the full model name and base model name\n\t\t\t\t\t// so it works whether or not reasoning is applied\n\t\t\t\t\tchatPricing[model] = map[string]float64{\n\t\t\t\t\t\t\"prompt\":     prompt,\n\t\t\t\t\t\t\"completion\": completion,\n\t\t\t\t\t}\n\t\t\t\t\t// Also store by base model name for direct lookup\n\t\t\t\t\tif model != baseModel {\n\t\t\t\t\t\tchatPricing[baseModel] = map[string]float64{\n\t\t\t\t\t\t\t\"prompt\":     prompt,\n\t\t\t\t\t\t\t\"completion\": completion,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tslog.Debug(\"No pricing found for model\", \"model\", model, \"baseModel\", baseModel)\n\t\t\t\t}\n\t\t\t}\n\t\t\tslog.Info(\"OpenRouter pricing lookup\", \"total_models\", len(chatModels), \"pricing_found\", pricingFound, \"pricing_map_size\", len(chatPricing))\n\t\t\t// If no pricing found, trigger a background refresh to update the cache\n\t\t\tif !pricingFound && len(chatModels) > 0 {\n\t\t\t\tgo func() {\n\t\t\t\t\t_ = inference.RefreshMetadataCache()\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif len(chatPricing) > 0 {\n\t\t\t\topenrouterPricing[\"chat\"] = chatPricing\n\t\t\t\tmodelPricing[\"openrouter\"] = openrouterPricing\n\t\t\t}\n\t\t}\n\t}\n\n\t// Create a new struct for the response to include the merged models\n\ttype ConfigResponse struct {\n\t\t*config.Config\n\t\tAvailableModels map[string]map[string][]string                      `json:\"available_models\"`\n\t\tModelPricing    map[string]map[string]map[string]map[string]float64 `json:\"model_pricing\"`\n\t}\n\n\treturn ConfigResponse{\n\t\tConfig:          cfg,\n\t\tAvailableModels: availableModels,\n\t\tModelPricing:    modelPricing,\n\t}\n}\n\nfunc (s *Server) performConfigUpdate(updates map[string]interface{}) error {\n\tcfg, err := config.LoadConfig()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load config: %w\", err)\n\t}\n\n\t// Apply available_models update explicitly if present\n\tif am, ok := updates[\"available_models\"].(map[string]interface{}); ok {\n\t\t// Replace the entire available models map for providers that are present in the update\n\t\t// but if we want to support full deletion of a provider from available_models,\n\t\t// we should probably just replace the whole map from what the UI sends.\n\n\t\tnewAvailableModels := make(map[string]map[string][]string)\n\t\tfor provider, capsRaw := range am {\n\t\t\tcaps, ok := capsRaw.(map[string]interface{})\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewAvailableModels[provider] = make(map[string][]string)\n\t\t\tfor capName, modelsRaw := range caps {\n\t\t\t\tif capName != \"chat\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmodelsSlice, ok := modelsRaw.([]interface{})\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmodels := make([]string, 0, len(modelsSlice))\n\t\t\t\tfor _, m := range modelsSlice {\n\t\t\t\t\tif s, ok := m.(string); ok {\n\t\t\t\t\t\tmodels = append(models, s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewAvailableModels[provider][capName] = models\n\t\t\t}\n\t\t}\n\t\tcfg.AvailableModels = newAvailableModels\n\n\t\t// Remove available_models from generic update to avoid double processing\n\t\tdelete(updates, \"available_models\")\n\t}\n\n\t// Apply custom_providers update explicitly if present to support deletion\n\tif cp, ok := updates[\"custom_providers\"].(map[string]interface{}); ok {\n\t\tnewCustomProviders := make(map[string]config.CustomProviderConfig)\n\t\tfor name, dataRaw := range cp {\n\t\t\tdata, ok := dataRaw.(map[string]interface{})\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbaseURL, _ := data[\"base_url\"].(string)\n\t\t\tnewCustomProviders[name] = config.CustomProviderConfig{\n\t\t\t\tBaseURL: baseURL,\n\t\t\t}\n\t\t}\n\t\tcfg.CustomProviders = newCustomProviders\n\t\tdelete(updates, \"custom_providers\")\n\t}\n\n\t// Apply sub_agent updates explicitly if present\n\tif sa, ok := updates[\"sub_agent\"].(map[string]interface{}); ok {\n\t\tif saEnabled, ok := sa[\"enabled\"].(bool); ok {\n\t\t\tcfg.SubAgent.Enabled = &saEnabled\n\t\t}\n\t\t// Remove sub_agent from generic update to avoid double processing\n\t\tdelete(updates, \"sub_agent\")\n\t}\n\n\t// Apply other updates via JSON trick\n\tif len(updates) > 0 {\n\t\tb, err := json.Marshal(updates)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to marshal updates: %w\", err)\n\t\t}\n\t\tif err := json.Unmarshal(b, cfg); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal updates: %w\", err)\n\t\t}\n\t}\n\n\tif err := config.SaveConfig(cfg); err != nil {\n\t\treturn fmt.Errorf(\"failed to save config: %w\", err)\n\t}\n\n\t// Ensure a default provider and model are set if at least one is enabled\n\t// Use priority order to avoid selecting local providers (ollama, lmstudio) as default\n\tif cfg.Inference.Chat.Provider == \"\" {\n\t\tpriorityProviders := []string{\"openrouter\", \"anthropic\", \"openai\", \"gemini\"}\n\t\tfound := false\n\n\t\t// Check priority providers first\n\t\tfor _, p := range priorityProviders {\n\t\t\tif pc, ok := cfg.Providers[p]; ok && pc.Enabled != nil && *pc.Enabled {\n\t\t\t\tcfg.Inference.Chat.Provider = p\n\t\t\t\t// Attempt to pick a sensible model\n\t\t\t\tif cfg.Inference.Chat.Model == \"\" {\n\t\t\t\t\t// Hardcoded sensible defaults for known providers\n\t\t\t\t\tswitch p {\n\t\t\t\t\tcase \"openrouter\":\n\t\t\t\t\t\tcfg.Inference.Chat.Model = \"anthropic/claude-haiku-4.5\"\n\t\t\t\t\tcase \"anthropic\":\n\t\t\t\t\t\tcfg.Inference.Chat.Model = \"claude-haiku-4-5\"\n\t\t\t\t\tcase \"openai\":\n\t\t\t\t\t\tcfg.Inference.Chat.Model = \"gpt-5-mini\"\n\t\t\t\t\tcase \"gemini\":\n\t\t\t\t\t\tcfg.Inference.Chat.Model = \"gemini-2.5-flash-lite\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// If no priority provider found, check custom providers\n\t\tif !found && cfg.CustomProviders != nil {\n\t\t\tfor name := range cfg.CustomProviders {\n\t\t\t\tcfg.Inference.Chat.Provider = name\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Only check local providers as last resort\n\t\tif !found {\n\t\t\tlocalProviders := []string{\"ollama\", \"lmstudio\"}\n\t\t\tfor _, p := range localProviders {\n\t\t\t\tif pc, ok := cfg.Providers[p]; ok && pc.Enabled != nil && *pc.Enabled {\n\t\t\t\t\tcfg.Inference.Chat.Provider = p\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif found {\n\t\t\t// Save again with the new defaults\n\t\t\t_ = config.SaveConfig(cfg)\n\t\t}\n\t}\n\n\t// Transition onboarding agents if a real provider is now available\n\tif cfg.Inference.Chat.Provider != \"\" {\n\t\tagents, _ := s.db.ListAgents(nil, nil)\n\t\tfor _, a := range agents {\n\t\t\tif a.ModelConfig.Provider == \"onboarding\" {\n\t\t\t\tnewConfig := types.ModelConfig{\n\t\t\t\t\tProvider: cfg.Inference.Chat.Provider,\n\t\t\t\t\tModel:    s.getChatModel(cfg),\n\t\t\t\t}\n\t\t\t\tslog.Info(\"Transitioning onboarding agent to real provider\", \"agent_id\", a.ID, \"provider\", newConfig.Provider)\n\t\t\t\ts.db.UpdateAgentModelConfig(a.ID, newConfig)\n\n\t\t\t\t// Mark onboarding as completed\n\t\t\t\ts.db.SetSetting(\"onboarding_completed\", \"true\")\n\n\t\t\t\t// Nudge the agent to start the LLM conversation\n\t\t\t\tnudge := \"I see you've set up a provider! I'm now powered by \" + newConfig.Provider + \". Let's get to know each other.\\n\\nFamiliar is designed to be your personal agent that can not only chat, but also use tools on your computer, schedule background tasks, and more.\\n\\nTo help me find the best ways to assist you, could you tell me a bit about what you do? For example, do you work on coding projects, manage a lot of research, or have complex daily schedules you'd like to automate?\"\n\t\t\t\tlogID, _ := s.db.AppendAgentLog(a.ID, \"model_responded\", map[string]interface{}{\n\t\t\t\t\t\"content\": nudge,\n\t\t\t\t})\n\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":         \"agent_config_updated\",\n\t\t\t\t\t\"agent_id\":     a.ID,\n\t\t\t\t\t\"model_config\": newConfig,\n\t\t\t\t})\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":       \"execution_log\",\n\t\t\t\t\t\"agent_id\":   a.ID,\n\t\t\t\t\t\"event_type\": \"model_responded\",\n\t\t\t\t\t\"payload\":    map[string]interface{}{\"id\": logID, \"content\": nudge},\n\t\t\t\t})\n\n\t\t\t\ts.mu.Lock()\n\t\t\t\tif sa, ok := s.statefulAgents[a.ID]; ok {\n\t\t\t\t\tprov, _ := s.createProvider(newConfig.Provider)\n\t\t\t\t\tsa.UpdateModelConfig(newConfig, prov)\n\t\t\t\t}\n\t\t\t\ts.mu.Unlock()\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update running agents with new config\n\ts.mu.Lock()\n\tfor id, sa := range s.statefulAgents {\n\t\tif cfg.Agent.AutoCompactionEnabled != nil {\n\t\t\tsa.AutoCompactionEnabled = *cfg.Agent.AutoCompactionEnabled\n\t\t\t// Also update the runtime agent\n\t\t\tsa.RuntimeAgent.AutoCompactionEnabled = *cfg.Agent.AutoCompactionEnabled\n\t\t}\n\t\tsa.AlwaysAllowAll = cfg.Security.AlwaysAllowAll\n\n\t\t// Update shell permission mode\n\t\tif st, ok := sa.RuntimeAgent.Registry.GetTool(\"system_shell\"); ok {\n\t\t\tif shellTool, ok := st.(*tools.ShellTool); ok {\n\t\t\t\tshellTool.PermissionMode = cfg.Security.ShellPermissionMode\n\t\t\t}\n\t\t}\n\n\t\t// Check if provider is still enabled\n\t\ta, err := s.db.GetAgent(id)\n\t\tif err == nil {\n\t\t\tif _, err := s.createProvider(a.ModelConfig.Provider); err != nil {\n\t\t\t\tslog.Warn(\"Stopping agent because its provider was disabled\", \"agent_id\", id, \"provider\", a.ModelConfig.Provider)\n\t\t\t\tsa.Cancel()\n\t\t\t\tdelete(s.statefulAgents, id)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update global tool registry\n\tif st, ok := s.toolRegistry.GetTool(\"system_shell\"); ok {\n\t\tif shellTool, ok := st.(*tools.ShellTool); ok {\n\t\t\tshellTool.PermissionMode = cfg.Security.ShellPermissionMode\n\t\t}\n\t}\n\n\ts.mu.Unlock()\n\n\treturn nil\n}\n\nfunc (s *Server) recoverRuns() {\n\tagents, err := s.db.ListAgents(nil, nil)\n\tif err != nil {\n\t\tslog.Error(\"Failed to list agents for run recovery\", \"error\", err)\n\t\treturn\n\t}\n\n\tfor _, a := range agents {\n\t\tif a.State == types.AgentStateRunning {\n\t\t\t// Check if agent is actually running in memory\n\t\t\ts.mu.RLock()\n\t\t\tsa, exists := s.statefulAgents[a.ID]\n\t\t\ts.mu.RUnlock()\n\n\t\t\t// If agent doesn't exist in memory or isn't actually running, it's a stale state\n\t\t\tif !exists || (exists && !sa.IsRunning()) {\n\t\t\t\tslog.Info(\"Recovering stale running state\", \"agent_id\", a.ID, \"agent_name\", a.Name)\n\t\t\t\t// Reset to idle state\n\t\t\t\ts.db.UpdateAgentState(a.ID, types.AgentStateIdle, nil)\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":      \"agent_state_changed\",\n\t\t\t\t\t\"agent_id\":  a.ID,\n\t\t\t\t\t\"new_state\": types.AgentStateIdle,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc getProgramDataPath() string {\n\tif env := os.Getenv(\"FAMILIAR_WORKSPACE\"); env != \"\" {\n\t\treturn env\n\t}\n\treturn config.GetConfigDir()\n}\n\nfunc checkCLI(name string) string {\n\t_, err := exec.LookPath(name)\n\tif err == nil {\n\t\treturn \"ok\"\n\t}\n\treturn \"missing\"\n}\n\nfunc checkCLIAuth(name string) string {\n\tif name == \"claude\" {\n\t\t// Use a harmless command to check if we are logged in\n\t\tcmd := exec.Command(\"claude\", \"--print\", \"status\", \"--max-budget-usd\", \"0.01\")\n\t\t// Inject key if available to see if it works with injection\n\t\tif apiKey := config.GetKeychainPassword(\"anthropic-api-key\"); apiKey != \"\" {\n\t\t\tcmd.Env = append(os.Environ(), \"ANTHROPIC_API_KEY=\"+apiKey)\n\t\t} else {\n\t\t\tcmd.Env = os.Environ()\n\t\t}\n\n\t\tvar out bytes.Buffer\n\t\tcmd.Stdout = &out\n\t\tcmd.Stderr = &out\n\t\terr := cmd.Run()\n\n\t\t// If it's already logged in, it might fail because of budget (exit 1)\n\t\t// but if it's NOT logged in, it will say \"Please run /login\"\n\t\tif err != nil {\n\t\t\toutput := out.String()\n\t\t\tif strings.Contains(output, \"login\") || strings.Contains(output, \"API key\") {\n\t\t\t\treturn \"unauthorized\"\n\t\t\t}\n\t\t}\n\n\t\t// If it works (or fails with budget), it's \"ok\".\n\t\t// Now we want to know if it's using the injected key or native auth.\n\t\tif apiKey := config.GetKeychainPassword(\"anthropic-api-key\"); apiKey != \"\" {\n\t\t\treturn \"ok-injected\"\n\t\t}\n\t\treturn \"ok-native\"\n\t}\n\tif name == \"codex\" {\n\t\t// Codex has a status command\n\t\tcmd := exec.Command(\"codex\", \"login\", \"status\")\n\t\t// Inject key if available\n\t\tif apiKey := config.GetKeychainPassword(\"openai-api-key\"); apiKey != \"\" {\n\t\t\tcmd.Env = append(os.Environ(), \"OPENAI_API_KEY=\"+apiKey)\n\t\t} else {\n\t\t\tcmd.Env = os.Environ()\n\t\t}\n\n\t\terr := cmd.Run()\n\t\tif err != nil {\n\t\t\treturn \"unauthorized\"\n\t\t}\n\n\t\tif apiKey := config.GetKeychainPassword(\"openai-api-key\"); apiKey != \"\" {\n\t\t\treturn \"ok-injected\"\n\t\t}\n\t\treturn \"ok-native\"\n\t}\n\treturn \"ok\"\n}\n\nfunc runInstall(command string, args ...string) error {\n\tcmd := exec.Command(command, args...)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\treturn cmd.Run()\n}\n","numLines":856,"startLine":1,"totalLines":856}}}
{"parentUuid":"60721d6e-eaa4-4776-bde7-3416eb440269","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ezig2SA3TQbxM5Auq281YT","type":"tool_result","content":"     1import React, { useState, useEffect, useRef, useCallback } from 'react';\n     2import { useQuery, useQueryClient } from '@tanstack/react-query';\n     3import { api } from '../../lib/api';\n     4import { clsx } from 'clsx';\n     5import { ask } from '@tauri-apps/plugin-dialog';\n     6import { useSystem } from '../../context/SystemContext';\n     7import { useAgents } from '../../context/AgentContext';\n     8\n     9export const SettingsView: React.FC = () => {\n    10  const queryClient = useQueryClient();\n    11  const { setExplorerCollapsed } = useAgents();\n    12  const { data: config, refetch: refetchConfig } = useQuery({\n    13    queryKey: ['config'],\n    14    queryFn: () => api.getConfig(),\n    15  });\n    16\n    17  const { data: apiKeys } = useQuery({\n    18    queryKey: ['apiKeys'],\n    19    queryFn: () => api.getApiKeys(),\n    20  });\n    21\n    22  const { data: vaultSecrets, refetch: refetchVault } = useQuery({\n    23    queryKey: ['vaultSecrets'],\n    24    queryFn: () => api.listVaultSecrets(),\n    25  });\n    26\n    27  const { data: status } = useQuery({\n    28    queryKey: ['status'],\n    29    queryFn: () => api.getStatus(),\n    30    refetchInterval: 5000,\n    31  });\n    32\n    33  const handleToggleAlwaysAllowAll = async () => {\n    34    const current = !!config?.security?.always_allow_all;\n    35    if (!current) {\n    36      const confirmed = await ask(\"WARNING: This will automatically approve ALL tool calls (including shell and browser) from ALL agents and sub-agents. This grants autonomous agents full control over your local system and web presence. Are you sure you want to disable all security oversight?\", {\n    37        title: \"Danger: Disable All Approvals\",\n    38        kind: \"error\",\n    39      });\n    40      if (!confirmed) return;\n    41    }\n    42\n    43    try {\n    44      await api.updateConfig({ security: { always_allow_all: !current } });\n    45      await refetchConfig();\n    46      triggerSuccess();\n    47    } catch (err) {\n    48      console.error('Failed to toggle always allow all:', err);\n    49    }\n    50  };\n    51\n    52  const handleUpdateShellPermissionMode = async (mode: string) => {\n    53    try {\n    54      await api.updateConfig({ security: { shell_permission_mode: mode } });\n    55      await refetchConfig();\n    56      triggerSuccess();\n    57    } catch (err) {\n    58      console.error('Failed to update shell permission mode:', err);\n    59    }\n    60  };\n    61\n    62  const handleToggleSubAgentsGlobal = async () => {\n    63    try {\n    64      const current = !!config?.sub_agent?.enabled;\n    65      await api.updateConfig({ sub_agent: { enabled: !current } });\n    66      await refetchConfig();\n    67      triggerSuccess();\n    68    } catch (err) {\n    69      console.error('Failed to toggle sub-agents globally:', err);\n    70    }\n    71  };\n    72\n    73  const [isSaving, setIsSaving] = useState(false);\n    74  const [_showSuccess, setShowSuccess] = useState(false);\n    75  const [newKey, setNewKey] = useState<{ provider: string; key: string }>({ provider: '', key: '' });\n    76  const [newVaultSecret, setNewVaultSecret] = useState<{ name: string; value: string }>({ name: '', value: '' });\n    77  const [customBaseUrl, setCustomBaseUrl] = useState('');\n    78  const [isAddingCustomProvider, setIsAddingCustomProvider] = useState(false);\n    79  const [newCustomProviderName, setNewCustomProviderName] = useState('');\n    80\n    81  const [editingProvider, setEditingProvider] = useState<string | null>(null);\n    82  const [editingCapability, setEditingCapability] = useState<string>('chat');\n    83  const [newModelName, setNewModelName] = useState('');\n    84  const [isFetchingModels, setIsFetchingModels] = useState(false);\n    85  const { activeSettingsTab: activeTab } = useSystem();\n    86\n    87  const [recordingHotkey, setRecordingHotkey] = useState<string | null>(null);\n    88  const autoFetchedProviders = useRef<Set<string>>(new Set());\n    89\n    90  // Reasoning levels\n    91  type ReasoningLevel = '' | 'low' | 'medium' | 'high';\n    92  const reasoningLevels: { value: ReasoningLevel; label: string }[] = [\n    93    { value: '', label: 'None' },\n    94    { value: 'low', label: 'Low' },\n    95    { value: 'medium', label: 'Medium' },\n    96    { value: 'high', label: 'High' },\n    97  ];\n    98\n    99  // Helper to parse model string for reasoning level\n   100  // e.g., \"claude-haiku-4.5:thinking-high\" -> { baseModel: \"claude-haiku-4.5\", level: \"high\" }\n   101  const parseModelLevel = (model: string): { baseModel: string; level: ReasoningLevel } => {\n   102    for (const l of ['low', 'medium', 'high'] as ReasoningLevel[]) {\n   103      const suffix = `:thinking-${l}`;\n   104      if (model.endsWith(suffix)) {\n   105        return { baseModel: model.replace(suffix, ''), level: l };\n   106      }\n   107    }\n   108    // Legacy: :thinking without level = high\n   109    if (model.endsWith(':thinking')) {\n   110      return { baseModel: model.replace(':thinking', ''), level: 'high' };\n   111    }\n   112    return { baseModel: model, level: '' };\n   113  };\n   114\n   115  // Helper to build model string from base and level\n   116  const buildModelString = (baseModel: string, level: ReasoningLevel): string => {\n   117    if (level) {\n   118      return `${baseModel}:thinking-${level}`;\n   119    }\n   120    return baseModel;\n   121  };\n   122\n   123  // Providers that support thinking/reasoning\n   124  const thinkingProviders = ['openrouter', 'anthropic', 'openai', 'gemini'];\n   125\n   126  // Update a model's reasoning level\n   127  const handleUpdateModelLevel = async (oldModel: string, newLevel: ReasoningLevel) => {\n   128    if (!editingProvider || !editingCapability) return;\n   129\n   130    const { baseModel } = parseModelLevel(oldModel);\n   131    const newModel = buildModelString(baseModel, newLevel);\n   132\n   133    if (newModel === oldModel) return; // No change\n   134\n   135    const models = availableModels[editingProvider]?.[editingCapability] || [];\n   136    const updatedModels = models.map(m => m === oldModel ? newModel : m);\n   137\n   138    const updatedAvailableModels = {\n   139      ...availableModels,\n   140      [editingProvider]: {\n   141        ...(availableModels[editingProvider] || {}),\n   142        [editingCapability]: updatedModels\n   143      }\n   144    };\n   145\n   146    setIsSaving(true);\n   147    try {\n   148      await api.updateConfig({ available_models: updatedAvailableModels });\n   149      await refetchConfig();\n   150      triggerSuccess();\n   151    } catch (err) {\n   152      console.error('Failed to update model reasoning level:', err);\n   153    } finally {\n   154      setIsSaving(false);\n   155    }\n   156  };\n   157\n   158  useEffect(() => {\n   159    setExplorerCollapsed(false);\n   160  }, []);\n   161\n   162  const successTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n   163  const triggerSuccess = useCallback(() => {\n   164    setShowSuccess(true);\n   165    if (successTimeoutRef.current) clearTimeout(successTimeoutRef.current);\n   166    successTimeoutRef.current = setTimeout(() => setShowSuccess(false), 3000);\n   167  }, []);\n   168\n   169  useEffect(() => {\n   170    if (recordingHotkey) {\n   171      const handleGlobalKeyDown = (e: KeyboardEvent) => {\n   172        // Don't intercept if it's just a modifier key\n   173        if (['Control', 'Shift', 'Alt', 'Meta'].includes(e.key)) return;\n   174\n   175        e.preventDefault();\n   176        e.stopPropagation();\n   177\n   178        if (e.key === 'Escape') {\n   179          setRecordingHotkey(null);\n   180          return;\n   181        }\n   182\n   183        const modifiers = [];\n   184        if (e.metaKey) modifiers.push('Cmd');\n   185        else if (e.ctrlKey) modifiers.push('Ctrl');\n   186\n   187        if (e.shiftKey) modifiers.push('Shift');\n   188        if (e.altKey) modifiers.push('Alt');\n   189\n   190        let key = e.key;\n   191        if (key === ' ') key = 'Space';\n   192        if (key.length === 1) key = key.toUpperCase();\n   193\n   194        const hotkey = modifiers.length > 0 ? `${modifiers.join('+')}+${key}` : key;\n   195\n   196        handleUpdateHotkey(recordingHotkey, hotkey);\n   197        setRecordingHotkey(null);\n   198      };\n   199\n   200      window.addEventListener('keydown', handleGlobalKeyDown, true);\n   201      return () => window.removeEventListener('keydown', handleGlobalKeyDown, true);\n   202    }\n   203  }, [recordingHotkey, config]);\n   204\n   205  const handleUpdateHotkey = async (key: string, value: string) => {\n   206    const updatedHotkeys = { ...((config?.ui as any)?.hotkeys || {}), [key]: value };\n   207    try {\n   208      await api.updateConfig({ ui: { hotkeys: updatedHotkeys } });\n   209      await refetchConfig();\n   210      triggerSuccess();\n   211    } catch (err) {\n   212      console.error('Failed to update hotkey:', err);\n   213    }\n   214  };\n   215\n   216  const hotkeyDefaults: Record<string, string> = {\n   217    'global_back': 'Escape',\n   218    'new_agent': 'Cmd+N',\n   219    'focus_input': 'Cmd+L',\n   220    'toggle_sidebar': 'Cmd+B',\n   221    'toggle_settings': 'Cmd+,',\n   222    'toggle_pause': 'Cmd+P',\n   223    'compact': 'Cmd+Shift+C',\n   224    'toggle_unibar': 'Cmd+K',\n   225    'delete_agent': 'Cmd+D',\n   226    'toggle_explorer': 'Cmd+E',\n   227    'scroll_to_top': 'Cmd+ArrowUp',\n   228    'scroll_to_bottom': 'Cmd+ArrowDown',\n   229    'attach_file': 'Cmd+Shift+A',\n   230  };\n   231\n   232  const hotkeyLabels: Record<string, string> = {\n   233    'global_back': 'Go Back',\n   234    'new_agent': 'New Agent',\n   235    'focus_input': 'Focus Chat Input',\n   236    'toggle_sidebar': 'Toggle Sidebar',\n   237    'toggle_settings': 'Open Settings',\n   238    'toggle_pause': 'Pause / Resume Agent',\n   239    'compact': 'Compact Conversation',\n   240    'toggle_unibar': 'Command Palette',\n   241    'delete_agent': 'Delete Selected Agent',\n   242    'toggle_explorer': 'Toggle File Explorer',\n   243    'scroll_to_top': 'Scroll to Top',\n   244    'scroll_to_bottom': 'Scroll to Bottom',\n   245    'attach_file': 'Attach File',\n   246  };\n   247\n   248  // Pointer-based drag state (bypasses Tauri's drag interception)\n   249  const [isDragging, setIsDragging] = useState(false);\n   250  const [dragSourceIndex, setDragSourceIndex] = useState<number | null>(null);\n   251  const [dragTargetIndex, setDragTargetIndex] = useState<number | null>(null);\n   252  const itemRefs = useRef<(HTMLDivElement | null)[]>([]);\n   253  const containerRef = useRef<HTMLDivElement>(null);\n   254  const scrollRef = useRef<HTMLDivElement>(null);\n   255\n   256  useEffect(() => {\n   257    const handleKeyDown = (e: KeyboardEvent) => {\n   258      // Don't scroll if we're recording a hotkey or typing in an input\n   259      if (recordingHotkey) return;\n   260\n   261      const activeElement = document.activeElement;\n   262      const isInput = activeElement instanceof HTMLInputElement ||\n   263        activeElement instanceof HTMLTextAreaElement ||\n   264        (activeElement as HTMLElement)?.isContentEditable;\n   265\n   266      if (isInput && !(e.metaKey || e.ctrlKey)) return;\n   267\n   268      if (e.key === 'ArrowUp') {\n   269        if (scrollRef.current) {\n   270          e.preventDefault();\n   271          scrollRef.current.scrollBy({ top: -100, behavior: 'smooth' });\n   272        }\n   273      }\n   274      if (e.key === 'ArrowDown') {\n   275        if (scrollRef.current) {\n   276          e.preventDefault();\n   277          scrollRef.current.scrollBy({ top: 100, behavior: 'smooth' });\n   278        }\n   279      }\n   280      if (e.key === ' ' && !isInput) {\n   281        if (scrollRef.current) {\n   282          e.preventDefault();\n   283          const direction = e.shiftKey ? -1 : 1;\n   284          scrollRef.current.scrollBy({\n   285            top: direction * scrollRef.current.clientHeight * 0.8,\n   286            behavior: 'smooth'\n   287          });\n   288        }\n   289      }\n   290    };\n   291\n   292    window.addEventListener('keydown', handleKeyDown);\n   293    return () => window.removeEventListener('keydown', handleKeyDown);\n   294  }, [recordingHotkey]);\n   295\n   296\n   297\n   298  useEffect(() => {\n   299    if (!editingProvider && config?.available_models && apiKeys) {\n   300      const availableModels = config.available_models;\n   301      const providers = Object.keys(availableModels);\n   302\n   303      // Preference order for default selection\n   304      const preference = ['openrouter', 'anthropic', 'openai', 'gemini'];\n   305      const defaultProvider = preference.find(p => providers.some(ap => ap.toLowerCase() === p));\n   306\n   307      if (defaultProvider) {\n   308        const matching = providers.find(p => p.toLowerCase() === defaultProvider);\n   309        if (matching) {\n   310          setEditingProvider(matching);\n   311          setNewKey(prev => ({ ...prev, provider: matching }));\n   312        }\n   313      } else if (providers.length > 0) {\n   314        setEditingProvider(providers[0]);\n   315        setNewKey(prev => ({ ...prev, provider: providers[0] }));\n   316      }\n   317    }\n   318  }, [config, editingProvider, apiKeys]);\n   319\n   320  useEffect(() => {\n   321    if (editingProvider && config?.custom_providers?.[editingProvider]) {\n   322      setCustomBaseUrl(config?.custom_providers[editingProvider].base_url || '');\n   323    } else {\n   324      setCustomBaseUrl('');\n   325    }\n   326  }, [editingProvider, config?.custom_providers]);\n   327\n   328  const availableModels = config?.available_models || {};\n   329  const localProvidersList = ['ollama', 'lmstudio'];\n   330  const standardProviders = ['openrouter', 'anthropic', 'openai', 'gemini', 'ollama', 'lmstudio'];\n   331\n   332  const handleFetchModels = useCallback(async (provider: string) => {\n   333    if (isFetchingModels) return;\n   334    setIsFetchingModels(true);\n   335    try {\n   336      const response = await api.fetchModels(provider);\n   337      if (response && response.models) {\n   338        const updatedAvailableModels = {\n   339          ...availableModels,\n   340          [provider]: {\n   341            ...(availableModels[provider] || {}),\n   342            chat: response.models\n   343          }\n   344        };\n   345\n   346        // If this is the active provider and has no model set, pick the first one\n   347        const updates: any = { available_models: updatedAvailableModels };\n   348        if (provider === config?.inference?.chat?.provider && (!config?.inference?.chat?.model || (availableModels[provider]?.chat?.length || 0) === 0)) {\n   349          if (response.models.length > 0) {\n   350            updates.inference = {\n   351              ...config.inference,\n   352              chat: {\n   353                ...config.inference.chat,\n   354                model: response.models[0]\n   355              }\n   356            };\n   357          }\n   358        }\n   359\n   360        await api.updateConfig(updates);\n   361        await refetchConfig();\n   362        triggerSuccess();\n   363      }\n   364    } catch (err) {\n   365      console.error('Failed to fetch models:', err);\n   366    } finally {\n   367      setIsFetchingModels(false);\n   368    }\n   369  }, [availableModels, config, isFetchingModels, refetchConfig, triggerSuccess]);\n   370\n   371  useEffect(() => {\n   372    if (editingProvider && localProvidersList.includes(editingProvider.toLowerCase())) {\n   373      const currentChatModels = availableModels[editingProvider]?.chat || [];\n   374      if (currentChatModels.length === 0 && !isFetchingModels && !autoFetchedProviders.current.has(editingProvider.toLowerCase())) {\n   375        autoFetchedProviders.current.add(editingProvider.toLowerCase());\n   376        handleFetchModels(editingProvider);\n   377      }\n   378    }\n   379  }, [editingProvider, availableModels, isFetchingModels, handleFetchModels]);\n   380\n   381  const allProviders = Object.keys(availableModels);\n   382  const cloudProviders = allProviders.filter(p => standardProviders.includes(p.toLowerCase()) && !localProvidersList.includes(p.toLowerCase()));\n   383  const localProviders = allProviders.filter(p => standardProviders.includes(p.toLowerCase()) && localProvidersList.includes(p.toLowerCase()));\n   384  const userCustomProvidersList = allProviders.filter(p => !standardProviders.includes(p.toLowerCase()));\n   385\n   386  const currentModels = (editingProvider && editingCapability) ? (availableModels[editingProvider]?.[editingCapability] || []) : [];\n   387\n   388  const handleAddCustomProvider = async () => {\n   389    if (!newCustomProviderName.trim()) return;\n   390    const name = newCustomProviderName.trim().toLowerCase();\n   391    if (standardProviders.includes(name) || userCustomProvidersList.includes(name)) {\n   392      alert('Provider name already exists or is reserved.');\n   393      return;\n   394    }\n   395\n   396    setIsSaving(true);\n   397    try {\n   398      const updatedCustomProviders = {\n   399        ...(config?.custom_providers || {}),\n   400        [name]: { base_url: '' }\n   401      };\n   402      await api.updateConfig({ custom_providers: updatedCustomProviders });\n   403      await refetchConfig();\n   404      setEditingProvider(name);\n   405      setIsAddingCustomProvider(false);\n   406      setNewCustomProviderName('');\n   407      triggerSuccess();\n   408    } catch (err) {\n   409      console.error('Failed to add custom provider:', err);\n   410    } finally {\n   411      setIsSaving(false);\n   412    }\n   413  };\n   414\n   415  const handleRemoveCustomProvider = async (name: string) => {\n   416    const confirmed = await ask(`Are you sure you want to delete the custom provider \"${name}\"?`, {\n   417      title: 'Delete Provider',\n   418      kind: 'warning',\n   419    });\n   420\n   421    if (!confirmed) return;\n   422\n   423    setIsSaving(true);\n   424    try {\n   425      // Wipe API key from keychain first\n   426      try {\n   427        await api.removeApiKey(name);\n   428      } catch (keyErr) {\n   429        console.warn(`Failed to remove API key for ${name}:`, keyErr);\n   430      }\n   431\n   432      const updatedCustomProviders = { ...(config?.custom_providers || {}) };\n   433      delete updatedCustomProviders[name];\n   434\n   435      const updatedAvailableModels = { ...(config?.available_models || {}) };\n   436      delete updatedAvailableModels[name];\n   437\n   438      await api.updateConfig({\n   439        custom_providers: updatedCustomProviders,\n   440        available_models: updatedAvailableModels\n   441      });\n   442      await queryClient.invalidateQueries({ queryKey: ['config'] });\n   443      await queryClient.invalidateQueries({ queryKey: ['apiKeys'] });\n   444      if (editingProvider === name) {\n   445        setEditingProvider(cloudProviders[0] || 'openai');\n   446      }\n   447      triggerSuccess();\n   448    } catch (err) {\n   449      console.error('Failed to remove custom provider:', err);\n   450    } finally {\n   451      setIsSaving(false);\n   452    }\n   453  };\n   454\n   455  const handleAddModel = async () => {\n   456    if (!editingProvider || !editingCapability || !newModelName.trim()) return;\n   457\n   458    const modelToAdd = newModelName.trim();\n   459    if (currentModels.includes(modelToAdd)) return;\n   460\n   461    const updatedModels = [...currentModels, modelToAdd];\n   462    const updatedAvailableModels = {\n   463      ...availableModels,\n   464      [editingProvider]: {\n   465        ...(availableModels[editingProvider] || {}),\n   466        [editingCapability]: updatedModels\n   467      }\n   468    };\n   469\n   470    const updates: any = { available_models: updatedAvailableModels };\n   471\n   472    // If this is the first model for this provider, and it's the default provider, set it as default model\n   473    if (editingProvider === config?.inference?.chat?.provider && editingCapability === 'chat' && currentModels.length === 0) {\n   474      updates.inference = {\n   475        ...config.inference,\n   476        chat: {\n   477          ...config.inference.chat,\n   478          model: modelToAdd\n   479        }\n   480      };\n   481    }\n   482\n   483    setIsSaving(true);\n   484    try {\n   485      await api.updateConfig(updates);\n   486      setNewModelName('');\n   487      await refetchConfig();\n   488      triggerSuccess();\n   489    } catch (err) {\n   490      console.error('Failed to add model:', err);\n   491    } finally {\n   492      setIsSaving(false);\n   493    }\n   494  };\n   495\n   496  const handleRemoveModel = async (modelName: string) => {\n   497    if (!editingProvider || !editingCapability) return;\n   498    const updatedModels = currentModels.filter(m => m !== modelName);\n   499    const updatedAvailableModels = {\n   500      ...availableModels,\n   501      [editingProvider]: {\n   502        ...(availableModels[editingProvider] || {}),\n   503        [editingCapability]: updatedModels\n   504      }\n   505    };\n   506\n   507    const updates: any = { available_models: updatedAvailableModels };\n   508\n   509    // If we removed the top model, or changed the list, and this is the default provider, update the default model\n   510    if (editingProvider === config?.inference?.chat?.provider && editingCapability === 'chat' && updatedModels.length > 0) {\n   511      if (updatedModels[0] !== currentModels[0]) {\n   512        updates.inference = {\n   513          ...config.inference,\n   514          chat: {\n   515            ...config.inference.chat,\n   516            model: updatedModels[0]\n   517          }\n   518        };\n   519      }\n   520    }\n   521\n   522    setIsSaving(true);\n   523    try {\n   524      await api.updateConfig(updates);\n   525      await refetchConfig();\n   526      triggerSuccess();\n   527    } catch (err) {\n   528      console.error('Failed to remove model:', err);\n   529    } finally {\n   530      setIsSaving(false);\n   531    }\n   532  };\n   533\n   534  const saveModelOrder = async (newModels: string[]) => {\n   535    if (!editingProvider || !editingCapability) return;\n   536\n   537    const updatedAvailableModels = {\n   538      ...availableModels,\n   539      [editingProvider]: {\n   540        ...(availableModels[editingProvider] || {}),\n   541        [editingCapability]: newModels\n   542      }\n   543    };\n   544\n   545    const updates: any = { available_models: updatedAvailableModels };\n   546\n   547    // If we moved something to the top, and this is the default provider, update the default model\n   548    if (editingProvider === config?.inference?.chat?.provider && editingCapability === 'chat') {\n   549      updates.inference = {\n   550        ...config.inference,\n   551        chat: {\n   552          ...config.inference.chat,\n   553          model: newModels[0]\n   554        }\n   555      };\n   556    }\n   557\n   558    setIsSaving(true);\n   559    try {\n   560      await api.updateConfig(updates);\n   561      await refetchConfig();\n   562      triggerSuccess();\n   563    } catch (err) {\n   564      console.error('Failed to update model order:', err);\n   565    } finally {\n   566      setIsSaving(false);\n   567    }\n   568  };\n   569\n   570  // Pointer-based drag handlers (works in Tauri)\n   571  const handlePointerDown = useCallback((e: React.PointerEvent, index: number) => {\n   572    e.preventDefault();\n   573    setIsDragging(true);\n   574    setDragSourceIndex(index);\n   575    setDragTargetIndex(index);\n   576    (e.target as HTMLElement).setPointerCapture(e.pointerId);\n   577  }, []);\n   578\n   579  const handlePointerMove = useCallback((e: React.PointerEvent) => {\n   580    if (!isDragging || dragSourceIndex === null || !containerRef.current) return;\n   581\n   582    const containerRect = containerRef.current.getBoundingClientRect();\n   583    const y = e.clientY - containerRect.top;\n   584\n   585    // Find which item we're over\n   586    let newTargetIndex = dragSourceIndex;\n   587    for (let i = 0; i < itemRefs.current.length; i++) {\n   588      const item = itemRefs.current[i];\n   589      if (!item) continue;\n   590      const rect = item.getBoundingClientRect();\n   591      const itemY = rect.top - containerRect.top + rect.height / 2;\n   592      if (y < itemY) {\n   593        newTargetIndex = i;\n   594        break;\n   595      }\n   596      newTargetIndex = i + 1;\n   597    }\n   598    newTargetIndex = Math.max(0, Math.min(newTargetIndex, currentModels.length - 1));\n   599\n   600    if (newTargetIndex !== dragTargetIndex) {\n   601      setDragTargetIndex(newTargetIndex);\n   602    }\n   603  }, [isDragging, dragSourceIndex, dragTargetIndex, currentModels.length]);\n   604\n   605  const handlePointerUp = useCallback(async (e: React.PointerEvent) => {\n   606    if (!isDragging) return;\n   607    (e.target as HTMLElement).releasePointerCapture(e.pointerId);\n   608\n   609    const sourceIndex = dragSourceIndex;\n   610    const targetIndex = dragTargetIndex;\n   611\n   612    setIsDragging(false);\n   613    setDragSourceIndex(null);\n   614    setDragTargetIndex(null);\n   615\n   616    if (sourceIndex === null || targetIndex === null || sourceIndex === targetIndex) return;\n   617\n   618    const newModels = [...currentModels];\n   619    const [removed] = newModels.splice(sourceIndex, 1);\n   620    newModels.splice(targetIndex, 0, removed);\n   621\n   622    await saveModelOrder(newModels);\n   623  }, [isDragging, dragSourceIndex, dragTargetIndex, currentModels, saveModelOrder]);\n   624\n   625\n   626  const handleToggleAutoCompaction = async () => {\n   627    try {\n   628      const current = config?.agent?.auto_compaction_enabled !== false; // Default to true if undefined\n   629      await api.updateConfig({ agent: { auto_compaction_enabled: !current } });\n   630      await refetchConfig();\n   631      triggerSuccess();\n   632    } catch (err) {\n   633      console.error('Failed to toggle auto-compaction:', err);\n   634    }\n   635  };\n   636\n   637  const handleSetApiKey = async () => {\n   638    if (!newKey.provider || !newKey.key) return;\n   639    setIsSaving(true);\n   640    try {\n   641      await api.setApiKey(newKey.provider, newKey.key);\n   642      setNewKey({ provider: '', key: '' });\n   643      await queryClient.invalidateQueries({ queryKey: ['apiKeys'] });\n   644      triggerSuccess();\n   645    } catch (err) {\n   646      console.error('Failed to set API key:', err);\n   647    } finally {\n   648      setIsSaving(false);\n   649    }\n   650  };\n   651\n   652  const handleSaveCustomBaseUrl = async () => {\n   653    if (!customBaseUrl.trim() || !editingProvider) return;\n   654    setIsSaving(true);\n   655    try {\n   656      const updatedCustomProviders = {\n   657        ...(config?.custom_providers || {}),\n   658        [editingProvider]: { base_url: customBaseUrl.trim() }\n   659      };\n   660      await api.updateConfig({ custom_providers: updatedCustomProviders });\n   661      await queryClient.invalidateQueries({ queryKey: ['config'] });\n   662      triggerSuccess();\n   663    } catch (err) {\n   664      console.error('Failed to update custom provider base URL:', err);\n   665    } finally {\n   666      setIsSaving(false);\n   667    }\n   668  };\n   669\n   670  const handleRemoveApiKey = async (provider: string) => {\n   671    const confirmed = await ask(`Are you sure you want to wipe the API key for ${provider.toUpperCase()}? This will prevent agents from using this provider until a new key is registered.`, {\n   672      title: 'Wipe API Key',\n   673      kind: 'warning',\n   674    });\n   675\n   676    if (!confirmed) return;\n   677\n   678    try {\n   679      await api.removeApiKey(provider);\n   680      await queryClient.invalidateQueries({ queryKey: ['apiKeys'] });\n   681    } catch (err) {\n   682      console.error('Failed to remove API key:', err);\n   683    }\n   684  };\n   685\n   686  const handleToggleProvider = async (provider: string, currentEnabled: boolean) => {\n   687    setIsSaving(true);\n   688    try {\n   689      const updatedProviders = {\n   690        ...(config?.providers || {}),\n   691        [provider]: { enabled: !currentEnabled }\n   692      };\n   693      await api.updateConfig({ providers: updatedProviders });\n   694      await queryClient.invalidateQueries({ queryKey: ['config'] });\n   695      await queryClient.invalidateQueries({ queryKey: ['apiKeys'] });\n   696      triggerSuccess();\n   697    } catch (err) {\n   698      console.error('Failed to toggle provider:', err);\n   699    } finally {\n   700      setIsSaving(false);\n   701    }\n   702  };\n   703\n   704  const handleSetVaultSecret = async () => {\n   705    if (!newVaultSecret.name || !newVaultSecret.value) return;\n   706    setIsSaving(true);\n   707    try {\n   708      await api.setVaultSecret(newVaultSecret.name, newVaultSecret.value);\n   709      setNewVaultSecret({ name: '', value: '' });\n   710      await refetchVault();\n   711      triggerSuccess();\n   712    } catch (err) {\n   713      console.error('Failed to set vault secret:', err);\n   714    } finally {\n   715      setIsSaving(false);\n   716    }\n   717  };\n   718\n   719  const handleRemoveVaultSecret = async (name: string) => {\n   720    const confirmed = await ask(`Are you sure you want to delete the secret \"${name}\"? This cannot be undone.`, {\n   721      title: 'Delete Secret',\n   722      kind: 'warning',\n   723    });\n   724\n   725    if (!confirmed) return;\n   726\n   727    try {\n   728      await api.removeVaultSecret(name);\n   729      refetchVault();\n   730    } catch (err) {\n   731      console.error('Failed to remove vault secret:', err);\n   732    }\n   733  };\n   734\n   735  return (\n   736    <div className=\"flex h-full bg-background font-mono text-[13px] overflow-hidden\">\n   737      {/* Main Content Area */}\n   738      <div className=\"flex-1 flex flex-col min-w-0 bg-background relative\">\n   739        <div className=\"flex-1 overflow-auto p-8 custom-scrollbar relative\" ref={scrollRef}>\n   740          <div className=\"max-w-4xl mx-auto pb-20\">\n   741            {activeTab === 'models' && (\n   742              <div className=\"space-y-8 animate-in fade-in slide-in-from-bottom-2 duration-300 font-mono\">\n   743                {/* Model Registry Section */}\n   744                <section className=\"space-y-3\">\n   745                  <div className=\"flex flex-col gap-0.5\">\n   746                    <div className=\"flex items-center gap-2 text-accent/80\">\n   747                      <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Provider Configuration</h2>\n   748                    </div>\n   749                    <p className=\"text-[10px] text-text-tertiary/60 italic leading-normal font-black tracking-tight\">\n   750                      LLM providers and endpoints. Credentials stored in system keychain.\n   751                    </p>\n   752                  </div>\n   753\n   754                  <div className=\"flex flex-col md:flex-row bg-surface/5 border border-border/10 overflow-hidden min-h-[450px]\">\n   755                    {/* Left Sidebar: Providers */}\n   756                    <div className=\"w-full md:w-48 border-b md:border-b-0 md:border-r border-border/10 bg-background/20 flex flex-col font-mono\">\n   757                      <div className=\"p-3 border-b border-border/10 bg-background/10 flex items-center justify-between\">\n   758                        <span className=\"text-[10px] font-black text-accent/60 uppercase tracking-[0.2em]\">Providers</span>\n   759                        <button\n   760                          onClick={() => setIsAddingCustomProvider(true)}\n   761                          className=\"text-accent/60 hover:text-accent transition-colors text-[10px]\"\n   762                          title=\"Add custom provider\"\n   763                        >\n   764                          [+]\n   765                        </button>\n   766                      </div>\n   767                      <div className=\"flex-1 overflow-auto p-1.5 space-y-0.5 custom-scrollbar\">\n   768                        {isAddingCustomProvider && (\n   769                          <div className=\"px-1.5 py-2 space-y-1.5 border-b border-border/10 mb-2\">\n   770                            <input\n   771                              autoFocus\n   772                              type=\"text\"\n   773                              placeholder=\"Custom provider name...\"\n   774                              value={newCustomProviderName}\n   775                              onChange={(e) => setNewCustomProviderName(e.target.value.toLowerCase().replace(/[^a-z0-9_-]/g, ''))}\n   776                              onKeyDown={(e) => {\n   777                                if (e.key === 'Enter') handleAddCustomProvider();\n   778                                if (e.key === 'Escape') setIsAddingCustomProvider(false);\n   779                              }}\n   780                              className=\"w-full bg-transparent border-b border-accent/20 px-1 py-0.5 text-[10px] text-text-primary focus:outline-none font-mono uppercase\"\n   781                            />\n   782                            <div className=\"flex gap-1\">\n   783                              <button\n   784                                onClick={handleAddCustomProvider}\n   785                                className=\"flex-1 py-0.5 text-accent text-[9px] font-black border border-accent/20 hover:bg-accent/5\"\n   786                              >\n   787                                Add\n   788                              </button>\n   789                              <button\n   790                                onClick={() => setIsAddingCustomProvider(false)}\n   791                                className=\"flex-1 py-0.5 text-text-tertiary/60 text-[9px] font-black border border-border/10 hover:bg-surface/10\"\n   792                              >\n   793                                Cancel\n   794                              </button>\n   795                            </div>\n   796                          </div>\n   797                        )}\n   798\n   799                        {/* All providers in a flat list */}\n   800                        {[...cloudProviders, ...userCustomProvidersList, ...localProviders].map(p => {\n   801                          const providerData = apiKeys?.find(k => k.provider.toLowerCase() === p.toLowerCase());\n   802                          const isConfigured = providerData?.configured;\n   803                          const isEnabled = providerData?.enabled === true;\n   804                          const isLocal = localProvidersList.includes(p.toLowerCase());\n   805                          const isCustom = userCustomProvidersList.includes(p);\n   806\n   807                          return (\n   808                            <button\n   809                              key={p}\n   810                              onClick={() => {\n   811                                setEditingProvider(p);\n   812                                setNewKey(prev => ({ ...prev, provider: p }));\n   813                              }}\n   814                              className={clsx(\n   815                                \"w-full px-2 py-1.5 text-left text-[11px] font-black uppercase transition-all flex items-center justify-between\",\n   816                                editingProvider === p\n   817                                  ? \"text-accent bg-accent/5\"\n   818                                  : \"text-text-tertiary/60 hover:text-text-secondary hover:bg-surface/5\",\n   819                                !isEnabled && \"opacity-40\"\n   820                              )}\n   821                            >\n   822                              <div className=\"flex items-center gap-2\">\n   823                                <span className=\"w-2 text-[10px]\">{editingProvider === p ? '>' : ' '}</span>\n   824                                <span className=\"truncate\">{p}</span>\n   825                                {isLocal && <span className=\"text-[7px] text-text-tertiary/30\">LOCAL</span>}\n   826                                {isCustom && <span className=\"text-[7px] text-text-tertiary/30\">CUSTOM</span>}\n   827                              </div>\n   828                              {!isLocal && (\n   829                                <div className={clsx(\n   830                                  \"w-1.5 h-1.5 rounded-full shrink-0\",\n   831                                  isConfigured ? \"bg-status-success\" : \"bg-status-error/40\"\n   832                                )} />\n   833                              )}\n   834                            </button>\n   835                          );\n   836                        })}\n   837                      </div>\n   838                    </div>\n   839\n   840                    {/* Right Panel: Skills and Models */}\n   841                    <div className=\"flex-1 flex flex-col bg-background/5 font-mono\">\n   842                      {!editingProvider ? (\n   843                        <div className=\"flex-1 flex flex-col items-center justify-center text-text-tertiary/20 space-y-2\">\n   844                          <span className=\"text-[10px] uppercase font-black tracking-[0.2em]\">Select a provider</span>\n   845                          <div className=\"animate-pulse\">_</div>\n   846                        </div>\n   847                      ) : (\n   848                        <div className=\"flex-1 overflow-auto p-5 space-y-6 custom-scrollbar\">\n   849                          {/* Provider Header */}\n   850                          {(() => {\n   851                            const providerData = apiKeys?.find(k => k.provider.toLowerCase() === editingProvider.toLowerCase());\n   852                            const isConfigured = providerData?.configured;\n   853                            const isEnabled = providerData?.enabled === true;\n   854                            const isLocal = localProvidersList.includes(editingProvider.toLowerCase());\n   855                            const isCustom = userCustomProvidersList.includes(editingProvider);\n   856\n   857                            return (\n   858                              <div className=\"space-y-4\">\n   859                                {/* Provider name and enable toggle */}\n   860                                <div className=\"flex items-center justify-between\">\n   861                                  <div className=\"flex items-center gap-3\">\n   862                                    <span className=\"text-[14px] font-black text-text-primary uppercase tracking-[0.1em]\">\n   863                                      {editingProvider}\n   864                                    </span>\n   865                                    {isLocal && (\n   866                                      <span className=\"text-[8px] font-black text-accent/50 uppercase tracking-widest px-1.5 py-0.5 border border-accent/20\">Local</span>\n   867                                    )}\n   868                                    {isCustom && (\n   869                                      <span className=\"text-[8px] font-black text-text-tertiary/50 uppercase tracking-widest px-1.5 py-0.5 border border-border/20\">Custom</span>\n   870                                    )}\n   871                                  </div>\n   872\n   873                                  <div className=\"flex items-center gap-3\">\n   874                                    {/* Enable/Disable toggle */}\n   875                                    <button\n   876                                      onClick={() => handleToggleProvider(editingProvider, isEnabled)}\n   877                                      className={clsx(\n   878                                        \"text-[9px] font-black px-3 py-1 transition-all tracking-widest uppercase active:scale-95\",\n   879                                        isEnabled\n   880                                          ? \"text-status-success bg-status-success/10 hover:bg-status-success/15\"\n   881                                          : \"text-text-tertiary/40 bg-surface/10 hover:bg-surface/20\"\n   882                                      )}\n   883                                    >\n   884                                      {isEnabled ? 'Enabled' : 'Disabled'}\n   885                                    </button>\n   886\n   887                                    {/* Delete custom provider */}\n   888                                    {isCustom && (\n   889                                      <button\n   890                                        onClick={() => handleRemoveCustomProvider(editingProvider)}\n   891                                        className=\"text-[9px] text-text-tertiary/30 hover:text-status-error transition-all uppercase font-black\"\n   892                                        title=\"Delete provider\"\n   893                                      >\n   894                                        [Delete]\n   895                                      </button>\n   896                                    )}\n   897                                  </div>\n   898                                </div>\n   899\n   900                                {/* API Key Status - clear visual indicator */}\n   901                                {!isLocal && (\n   902                                  <div className={clsx(\n   903                                    \"p-3 border transition-all\",\n   904                                    isConfigured\n   905                                      ? \"border-status-success/20 bg-status-success/5\"\n   906                                      : \"border-status-error/20 bg-status-error/5\"\n   907                                  )}>\n   908                                    {isConfigured ? (\n   909                                      <div className=\"flex items-center justify-between\">\n   910                                        <div className=\"flex items-center gap-2\">\n   911                                          <div className=\"w-2 h-2 rounded-full bg-status-success\" />\n   912                                          <span className=\"text-[10px] font-black text-status-success uppercase tracking-widest\">API Key Configured</span>\n   913                                        </div>\n   914                                        <button\n   915                                          onClick={() => handleRemoveApiKey(editingProvider)}\n   916                                          className=\"text-[9px] text-text-tertiary/40 hover:text-status-error transition-all uppercase font-black\"\n   917                                        >\n   918                                          [Remove Key]\n   919                                        </button>\n   920                                      </div>\n   921                                    ) : (\n   922                                      <div className=\"space-y-3\">\n   923                                        <div className=\"flex items-center gap-2\">\n   924                                          <div className=\"w-2 h-2 rounded-full bg-status-error/50\" />\n   925                                          <span className=\"text-[10px] font-black text-status-error/70 uppercase tracking-widest\">API Key Required</span>\n   926                                        </div>\n   927                                        <div className=\"flex gap-2\">\n   928                                          <input\n   929                                            type=\"password\"\n   930                                            placeholder=\"Paste your API key...\"\n   931                                            value={newKey.key}\n   932                                            onChange={(e) => setNewKey(prev => ({ ...prev, key: e.target.value }))}\n   933                                            onKeyDown={(e) => e.key === 'Enter' && handleSetApiKey()}\n   934                                            className=\"flex-1 bg-transparent border-b border-border/20 px-0 py-1 text-[11px] text-text-primary focus:outline-none focus:border-accent/40 font-mono transition-all\"\n   935                                          />\n   936                                          <button\n   937                                            onClick={handleSetApiKey}\n   938                                            disabled={isSaving || !newKey.key}\n   939                                            className=\"px-3 py-1 text-accent hover:text-accent-hover font-black text-[10px] uppercase tracking-widest transition-all disabled:opacity-20\"\n   940                                          >\n   941                                            Save\n   942                                          </button>\n   943                                        </div>\n   944                                      </div>\n   945                                    )}\n   946                                  </div>\n   947                                )}\n   948\n   949                                {/* Local provider notice */}\n   950                                {isLocal && (\n   951                                  <div className=\"p-3 border border-accent/20 bg-accent/5\">\n   952                                    <div className=\"flex items-center gap-2\">\n   953                                      <div className=\"w-2 h-2 rounded-full bg-accent\" />\n   954                                      <span className=\"text-[10px] font-black text-accent/70 uppercase tracking-widest\">No Authentication Required</span>\n   955                                    </div>\n   956                                  </div>\n   957                                )}\n   958\n   959                                {/* Custom provider endpoint URL */}\n   960                                {isCustom && (\n   961                                  <div className=\"space-y-2\">\n   962                                    <span className=\"text-[9px] font-black text-text-tertiary/60 uppercase tracking-widest\">Endpoint URL</span>\n   963                                    <div className=\"flex gap-2\">\n   964                                      <input\n   965                                        type=\"text\"\n   966                                        placeholder=\"https://api.provider.com/v1\"\n   967                                        value={customBaseUrl}\n   968                                        onChange={(e) => setCustomBaseUrl(e.target.value)}\n   969                                        onKeyDown={(e) => e.key === 'Enter' && handleSaveCustomBaseUrl()}\n   970                                        className=\"flex-1 bg-transparent border-b border-border/20 px-0 py-1 text-[11px] text-text-primary focus:outline-none focus:border-accent/40 font-mono transition-all\"\n   971                                      />\n   972                                      <button\n   973                                        onClick={handleSaveCustomBaseUrl}\n   974                                        disabled={isSaving || !customBaseUrl.trim()}\n   975                                        className=\"px-3 py-1 text-accent hover:text-accent-hover font-black text-[10px] uppercase tracking-widest transition-all disabled:opacity-20\"\n   976                                      >\n   977                                        Save\n   978                                      </button>\n   979                                    </div>\n   980                                  </div>\n   981                                )}\n   982                              </div>\n   983                            );\n   984                          })()}\n   985\n   986                          {/* Model Registry Content */}\n   987                          <div className=\"space-y-6\">\n   988                            <div className=\"flex items-center justify-between\">\n   989                              <span className=\"text-[9px] font-black text-text-tertiary/60 uppercase tracking-widest\">Models</span>\n   990                              {localProvidersList.includes(editingProvider?.toLowerCase() || '') && (\n   991                                <button\n   992                                  onClick={() => editingProvider && handleFetchModels(editingProvider)}\n   993                                  disabled={isFetchingModels}\n   994                                  className={clsx(\n   995                                    \"text-[9px] font-black uppercase tracking-widest transition-all\",\n   996                                    isFetchingModels ? \"text-text-tertiary/20 animate-pulse\" : \"text-accent hover:text-accent-hover\"\n   997                                  )}\n   998                                >\n   999                                  {isFetchingModels ? 'Discovering...' : 'Discover local models'}\n  1000                                </button>\n  1001                              )}\n  1002                            </div>\n  1003\n  1004                            {['chat'].map(cap => {\n  1005                              const models = availableModels[editingProvider]?.[cap] || [];\n  1006                              const isEditing = editingCapability === cap;\n  1007\n  1008                              const isOpenRouter = editingProvider?.toLowerCase() === 'openrouter';\n  1009                              const supportsThinking = thinkingProviders.includes(editingProvider?.toLowerCase() || '');\n  1010\n  1011                              return (\n  1012                                <div key={cap} className=\"space-y-1\">\n  1013                                  {/* Column headers */}\n  1014                                  {(supportsThinking || isOpenRouter) && models.length > 0 && (\n  1015                                    <div className=\"flex items-center gap-2 px-2 py-1 border-b border-border/10\">\n  1016                                      <div className=\"w-6\" /> {/* Spacer for drag handle */}\n  1017                                      <span className=\"flex-1 text-[8px] font-black text-text-tertiary/40 uppercase tracking-widest\">MODEL NAME</span>\n  1018                                      {isOpenRouter && (\n  1019                                        <span className=\"text-[8px] font-black text-text-tertiary/40 uppercase tracking-widest w-24 text-right\">PRICING (INPUT/OUTPUT per 1M TOK)</span>\n  1020                                      )}\n  1021                                      {supportsThinking && (\n  1022                                        <span className=\"text-[8px] font-black text-text-tertiary/40 uppercase tracking-widest w-20 text-right\">REASONING</span>\n  1023                                      )}\n  1024                                      <div className=\"w-6\" /> {/* Spacer for delete button */}\n  1025                                    </div>\n  1026                                  )}\n  1027                                  <div\n  1028                                    ref={containerRef}\n  1029                                    className=\"flex flex-col gap-0.5 min-h-[50px]\"\n  1030                                  >\n  1031                                    {models.map((model, index) => {\n  1032                                      const { baseModel, level } = parseModelLevel(model);\n  1033                                      // Use baseModel for pricing lookup since pricing is stored by base model name\n  1034                                      const pricing = isOpenRouter && config?.model_pricing?.['openrouter']?.[cap]?.[baseModel];\n  1035\n  1036                                      return (\n  1037                                        <div\n  1038                                          key={model}\n  1039                                          ref={el => { itemRefs.current[index] = el; }}\n  1040                                          className={clsx(\n  1041                                            \"flex items-center justify-between px-2 py-1 border-b border-border/5 group transition-all relative select-none gap-2\",\n  1042                                            isDragging && dragSourceIndex === index && \"opacity-50\",\n  1043                                            isDragging && dragTargetIndex === index && dragSourceIndex !== index && \"border-t border-accent\"\n  1044                                          )}\n  1045                                        >\n  1046                                          {/* Drag handle */}\n  1047                                          <div\n  1048                                            className=\"text-text-tertiary/20 hover:text-accent transition-all cursor-grab active:cursor-grabbing p-1 -m-1 touch-none shrink-0\"\n  1049                                            onPointerDown={(e) => handlePointerDown(e, index)}\n  1050                                            onPointerMove={handlePointerMove}\n  1051                                            onPointerUp={handlePointerUp}\n  1052                                            onPointerCancel={handlePointerUp}\n  1053                                          >\n  1054                                            <span className=\"text-[8px] font-black\">{index === 0 ? '@' : '#'}</span>\n  1055                                          </div>\n  1056\n  1057                                          {/* Model name */}\n  1058                                          <div className=\"flex-1 min-w-0\">\n  1059                                            <span className={clsx(\n  1060                                              \"text-[10px] transition-colors truncate font-mono uppercase block\",\n  1061                                              index === 0 ? \"text-accent font-black\" : \"text-text-primary/60 group-hover:text-text-primary\"\n  1062                                            )}>{baseModel}</span>\n  1063                                          </div>\n  1064\n  1065                                          {/* Pricing column for OpenRouter */}\n  1066                                          {isOpenRouter && (\n  1067                                            <div className=\"text-[9px] text-text-tertiary/60 font-mono text-right shrink-0 w-24\">\n  1068                                              {pricing ? (\n  1069                                                <span>${pricing.prompt.toFixed(2)}/${pricing.completion.toFixed(2)}</span>\n  1070                                              ) : (\n  1071                                                <span className=\"text-text-tertiary/20\"></span>\n  1072                                              )}\n  1073                                            </div>\n  1074                                          )}\n  1075\n  1076                                          {/* Reasoning level dropdown */}\n  1077                                          {supportsThinking && (\n  1078                                            <select\n  1079                                              value={level}\n  1080                                              onChange={(e) => handleUpdateModelLevel(model, e.target.value as typeof level)}\n  1081                                              className={clsx(\n  1082                                                \"bg-transparent border px-1.5 py-0.5 text-[9px] font-black uppercase cursor-pointer transition-all shrink-0 w-20\",\n  1083                                                level\n  1084                                                  ? \"text-status-success border-status-success/30 bg-status-success/5\"\n  1085                                                  : \"text-text-tertiary/50 border-border/20 hover:border-border/40\"\n  1086                                              )}\n  1087                                              style={{ WebkitAppearance: 'none', appearance: 'none', paddingRight: '16px', backgroundImage: 'url(\"data:image/svg+xml,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 fill=%27none%27 viewBox=%270 0 24 24%27 stroke=%27%23666%27%3e%3cpath stroke-linecap=%27round%27 stroke-linejoin=%27round%27 stroke-width=%272%27 d=%27M19 9l-7 7-7-7%27/%3e%3c/svg%3e\")', backgroundRepeat: 'no-repeat', backgroundPosition: 'right 2px center', backgroundSize: '10px' }}\n  1088                                            >\n  1089                                              {reasoningLevels.map(l => (\n  1090                                                <option key={l.value} value={l.value}>{l.label}</option>\n  1091                                              ))}\n  1092                                            </select>\n  1093                                          )}\n  1094\n  1095                                          {/* Remove button */}\n  1096                                          <button\n  1097                                            onClick={(e) => {\n  1098                                              e.stopPropagation();\n  1099                                              setEditingCapability(cap);\n  1100                                              handleRemoveModel(model);\n  1101                                            }}\n  1102                                            className=\"text-text-tertiary/20 hover:text-status-error opacity-0 group-hover:opacity-100 transition-all text-[10px] font-black shrink-0\"\n  1103                                          >\n  1104                                            [X]\n  1105                                          </button>\n  1106                                        </div>\n  1107                                      );\n  1108                                    })}\n  1109\n  1110                                    {/* Inline Add Model Input */}\n  1111                                    <div className=\"flex gap-2 group/input mt-1\">\n  1112                                      <div className=\"flex-1 relative\">\n  1113                                        <input\n  1114                                          type=\"text\"\n  1115                                          placeholder=\"Add model...\"\n  1116                                          value={isEditing ? newModelName : ''}\n  1117                                          onFocus={() => setEditingCapability(cap)}\n  1118                                          onChange={(e) => {\n  1119                                            setEditingCapability(cap);\n  1120                                            setNewModelName(e.target.value);\n  1121                                          }}\n  1122                                          onKeyDown={(e) => e.key === 'Enter' && handleAddModel()}\n  1123                                          className=\"w-full bg-transparent border-b border-dashed border-border/20 px-0 py-0.5 text-[10px] text-text-primary placeholder:text-text-tertiary/20 focus:outline-none focus:border-accent/40 focus:border-solid font-mono transition-all uppercase\"\n  1124                                        />\n  1125                                      </div>\n  1126                                      {isEditing && newModelName.trim() && (\n  1127                                        <button\n  1128                                          onClick={handleAddModel}\n  1129                                          className=\"text-accent text-[10px] font-black\"\n  1130                                        >\n  1131                                          [+]\n  1132                                        </button>\n  1133                                      )}\n  1134                                    </div>\n  1135                                  </div>\n  1136                                </div>\n  1137                              );\n  1138                            })}\n  1139                          </div>\n  1140                        </div>\n  1141                      )}\n  1142                    </div>\n  1143                  </div>\n  1144                </section>\n  1145              </div>\n  1146            )}\n  1147\n  1148            {activeTab === 'general' && (\n  1149              <div className=\"space-y-12 animate-in fade-in slide-in-from-bottom-2 duration-300 font-mono\">\n  1150                <div className=\"grid grid-cols-1 gap-12\">\n  1151                  {/* Agent Behavior Section */}\n  1152                  <section className=\"space-y-3\">\n  1153                    <div className=\"flex flex-col gap-0.5\">\n  1154                      <div className=\"flex items-center gap-2 text-accent/80\">\n  1155                        <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Behavior</h2>\n  1156                      </div>\n  1157                      <p className=\"text-[10px] text-text-tertiary/60 italic leading-normal font-black tracking-tight\">\n  1158                        Global execution and memory policies.\n  1159                      </p>\n  1160                    </div>\n  1161\n  1162                    <div className=\"bg-surface/5 border border-border/10 p-4 space-y-3 font-mono\">\n  1163                      <div className=\"flex items-center justify-between border-b border-border/5 pb-3\">\n  1164                        <div className=\"flex flex-col gap-0.5\">\n  1165                          <div className=\"flex items-center gap-2\">\n  1166                            <span className=\"text-[11px] font-black text-text-primary uppercase tracking-[0.2em]\">Auto-compaction</span>\n  1167                          </div>\n  1168                          <p className=\"text-[10px] text-text-tertiary/60 italic px-3 leading-normal font-black tracking-tight\">\n  1169                            Reduce token overhead automatically at threshold.\n  1170                          </p>\n  1171                        </div>\n  1172                        <button\n  1173                          onClick={handleToggleAutoCompaction}\n  1174                          className={clsx(\n  1175                            \"text-[10px] font-black px-2 py-1 transition-all tracking-widest uppercase active:scale-95\",\n  1176                            config?.agent?.auto_compaction_enabled !== false\n  1177                              ? \"text-status-success hover:bg-status-success/5\"\n  1178                              : \"text-status-error hover:bg-status-error/5\"\n  1179                          )}\n  1180                        >\n  1181                          {config?.agent?.auto_compaction_enabled !== false ? 'Active' : 'Inactive'}\n  1182                        </button>\n  1183                      </div>\n  1184                    </div>\n  1185                  </section>\n  1186\n  1187                  {/* Sub-Agent Ecosystem */}\n  1188                  <section className=\"space-y-4\">\n  1189                    <div className=\"flex flex-col gap-0.5\">\n  1190                      <div className=\"flex items-center justify-between\">\n  1191                        <div className=\"flex items-center gap-2 text-accent/80\">\n  1192                          <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Sub-agents</h2>\n  1193                        </div>\n  1194                        <button\n  1195                          onClick={handleToggleSubAgentsGlobal}\n  1196                          className={clsx(\n  1197                            \"text-[10px] font-black px-2 py-0.5 transition-all tracking-widest uppercase border active:scale-95 font-mono\",\n  1198                            config?.sub_agent?.enabled\n  1199                              ? \"text-status-success border-status-success/20 hover:bg-status-success/5\"\n  1200                              : \"text-status-error border-status-error/20 hover:bg-status-error/5\"\n  1201                          )}\n  1202                        >\n  1203                          {config?.sub_agent?.enabled ? 'Enabled' : 'Disabled'}\n  1204                        </button>\n  1205                      </div>\n  1206                      <p className=\"text-[10px] text-text-tertiary/60 italic leading-normal font-black tracking-tight\">\n  1207                        Autonomous child-agents for specialized task processing.\n  1208                      </p>\n  1209                    </div>\n  1210\n  1211                  </section>\n  1212                </div>\n  1213              </div>\n  1214            )\n  1215            }\n  1216\n  1217            {activeTab === 'security' && (\n  1218              <div className=\"space-y-12 animate-in fade-in slide-in-from-bottom-2 duration-300 font-mono\">\n  1219                {/* Unrestricted Execution Mode Toggle */}\n  1220                <div className={clsx(\n  1221                  \"p-4 border transition-all duration-500\",\n  1222                  config?.security?.always_allow_all\n  1223                    ? \"bg-status-error text-background border-status-error shadow-[0_0_25px_rgba(var(--status-error),0.2)]\"\n  1224                    : \"bg-status-error/5 border-status-error/10\"\n  1225                )}>\n  1226                  <div className=\"flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4\">\n  1227                    <div className=\"flex flex-col gap-1 pr-4\">\n  1228                      <div className=\"flex items-center gap-2\">\n  1229                        <span className={clsx(\n  1230                          \"text-[11px] font-black uppercase tracking-[0.2em]\",\n  1231                          config?.security?.always_allow_all ? \"text-background\" : \"text-status-error\"\n  1232                        )}>Unrestricted Execution</span>\n  1233                        {config?.security?.always_allow_all && (\n  1234                          <span className=\"text-[8px] font-black bg-background text-status-error px-1 py-0.5 animate-pulse tracking-widest\">System unlocked</span>\n  1235                        )}\n  1236                      </div>\n  1237                      <p className={clsx(\n  1238                        \"text-[9px] italic leading-relaxed max-w-2xl font-black uppercase tracking-tight\",\n  1239                        config?.security?.always_allow_all ? \"text-background/90\" : \"text-text-tertiary/60\"\n  1240                      )}>\n  1241                        Bypass all security checks. Agents gain full unmonitored system access. Use only in trusted environments.\n  1242                      </p>\n  1243                    </div>\n  1244                    <button\n  1245                      onClick={handleToggleAlwaysAllowAll}\n  1246                      className={clsx(\n  1247                        \"text-[9px] font-black px-3 py-1.5 transition-all tracking-[0.1em] uppercase border whitespace-nowrap active:scale-95\",\n  1248                        config?.security?.always_allow_all\n  1249                          ? \"bg-background text-status-error border-background\"\n  1250                          : \"bg-status-error text-background border-status-error\"\n  1251                      )}\n  1252                    >\n  1253                      {config?.security?.always_allow_all ? 'Restore Security' : 'Disable Security'}\n  1254                    </button>\n  1255                  </div>\n  1256                </div>\n  1257\n  1258                {/* Shell Execution Policy */}\n  1259                <section className={clsx(\n  1260                  \"space-y-3 transition-all duration-300\",\n  1261                  config?.security?.always_allow_all && \"opacity-40 grayscale\"\n  1262                )}>\n  1263                  <div className=\"flex flex-col gap-0.5\">\n  1264                    <div className=\"flex items-center justify-between\">\n  1265                      <div className=\"flex items-center gap-2 text-accent/80\">\n  1266                        <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Shell Policy</h2>\n  1267                      </div>\n  1268                      {config?.security?.always_allow_all && (\n  1269                        <span className=\"text-[8px] font-black text-status-error uppercase tracking-widest bg-status-error/10 px-1.5 py-0.5\">\n  1270                          Overridden by unrestricted mode\n  1271                        </span>\n  1272                      )}\n  1273                    </div>\n  1274                    <p className=\"text-[10px] text-text-tertiary/60 italic leading-normal font-black tracking-tight\">\n  1275                      Control auto-approval levels for terminal commands.\n  1276                    </p>\n  1277                  </div>\n  1278\n  1279                  <div className={clsx(\n  1280                    \"bg-surface/5 border border-border/10 p-5 space-y-4\",\n  1281                    config?.security?.always_allow_all && \"pointer-events-none\"\n  1282                  )}>\n  1283                    <div className=\"flex flex-col gap-0.5\">\n  1284                      <span className=\"text-[11px] font-black text-text-primary uppercase tracking-[0.2em]\">Execution Mode</span>\n  1285                    </div>\n  1286\n  1287                    <div className=\"grid grid-cols-2 sm:grid-cols-4 gap-2\">\n  1288                      {[\n  1289                        { id: 'restricted', label: 'RESTRICTED', desc: 'Minimal safe set' },\n  1290                        { id: 'read-only', label: 'READ_ONLY', desc: 'All inspections' },\n  1291                        { id: 'non-destructive', label: 'MUTABLE', desc: 'No deletions' },\n  1292                        { id: 'unrestricted', label: 'OPEN', desc: 'No approvals' },\n  1293                      ].map((mode) => (\n  1294                        <button\n  1295                          key={mode.id}\n  1296                          onClick={() => handleUpdateShellPermissionMode(mode.id)}\n  1297                          className={clsx(\n  1298                            \"flex flex-col items-start p-3 border transition-all text-left group active:scale-[0.98]\",\n  1299                            config?.security?.shell_permission_mode === mode.id\n  1300                              ? \"border-accent bg-accent/5 shadow-[0_0_15px_rgba(var(--accent),0.05)]\"\n  1301                              : \"border-border/10 hover:border-accent/40 bg-surface/5\"\n  1302                          )}\n  1303                        >\n  1304                          <span className={clsx(\n  1305                            \"text-[10px] font-black uppercase tracking-widest mb-1\",\n  1306                            config?.security?.shell_permission_mode === mode.id ? \"text-accent\" : \"text-text-tertiary/60 group-hover:text-text-secondary\"\n  1307                          )}>\n  1308                            {config?.security?.shell_permission_mode === mode.id ? `[${mode.label}]` : `  ${mode.label}`}\n  1309                          </span>\n  1310                          <span className=\"text-[8px] text-text-tertiary/40 font-black uppercase leading-tight\">\n  1311                            {mode.desc}\n  1312                          </span>\n  1313                        </button>\n  1314                      ))}\n  1315                    </div>\n  1316                  </div>\n  1317                </section>\n  1318\n  1319                {/* Vault Section */}\n  1320                <section className=\"space-y-3\">\n  1321                  <div className=\"flex flex-col gap-0.5\">\n  1322                    <div className=\"flex items-center gap-2 text-accent/80\">\n  1323                      <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Secure Vault</h2>\n  1324                    </div>\n  1325                    <p className=\"text-[10px] text-text-tertiary/60 italic leading-normal font-black tracking-tight\">\n  1326                      Protected tokens and environment variables.\n  1327                    </p>\n  1328                  </div>\n  1329\n  1330                  <div className=\"bg-surface/5 border border-border/10 p-5 space-y-6\">\n  1331                    <div className=\"space-y-4\">\n  1332                      <div className=\"flex flex-col gap-0.5\">\n  1333                        <span className=\"text-[11px] font-black text-text-primary uppercase tracking-[0.2em]\">Vault Index</span>\n  1334                        <p className=\"text-[10px] text-text-tertiary/60 italic px-3 font-black tracking-tight\">\n  1335                          Access in tools via <code className=\"text-accent underline\">{\"{{vault:KEY}}\"}</code>.\n  1336                        </p>\n  1337                      </div>\n  1338\n  1339                      <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-2\">\n  1340                        {vaultSecrets && vaultSecrets.length > 0 ? (\n  1341                          vaultSecrets.map((secret: any) => (\n  1342                            <div\n  1343                              key={secret.name}\n  1344                              className=\"flex items-center justify-between px-3 py-1.5 bg-background/20 border border-border/5 group hover:border-accent/20 transition-all\"\n  1345                            >\n  1346                              <div className=\"flex items-center gap-2\">\n  1347                                <span className=\"text-[8px] font-black text-accent/40 uppercase\">[KEY]</span>\n  1348                                <span className=\"text-[11px] font-black text-text-primary/70 font-mono truncate max-w-[120px]\">\n  1349                                  {secret.name}\n  1350                                </span>\n  1351                              </div>\n  1352                              <button\n  1353                                onClick={() => handleRemoveVaultSecret(secret.name)}\n  1354                                className=\"text-text-tertiary/20 hover:text-status-error opacity-0 group-hover:opacity-100 transition-all text-[10px] font-black\"\n  1355                              >\n  1356                                [X]\n  1357                              </button>\n  1358                            </div>\n  1359                          ))\n  1360                        ) : (\n  1361                          <div className=\"col-span-full py-6 border border-dashed border-border/10 flex flex-col items-center justify-center text-text-tertiary/20\">\n  1362                            <span className=\"text-[9px] uppercase font-black tracking-[0.2em]\">No secrets stored</span>\n  1363                          </div>\n  1364                        )}\n  1365                      </div>\n  1366\n  1367                      {/* Add Secret Form */}\n  1368                      <div className=\"mt-4 p-4 border-t border-border/5 space-y-3\">\n  1369                        <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-4\">\n  1370                          <div className=\"space-y-1\">\n  1371                            <label className=\"text-[9px] font-black text-text-tertiary/40 uppercase tracking-widest ml-1\">Key</label>\n  1372                            <input\n  1373                              type=\"text\"\n  1374                              placeholder=\"GITHUB_TOKEN\"\n  1375                              value={newVaultSecret.name}\n  1376                              onChange={(e) => setNewVaultSecret(prev => ({ ...prev, name: e.target.value.toUpperCase().replace(/[^A-Z0-9_]/g, '_') }))}\n  1377                              className=\"w-full bg-transparent border-b border-border/10 px-0 py-1 text-[11px] text-text-primary focus:outline-none focus:border-accent/40 font-mono transition-all uppercase\"\n  1378                            />\n  1379                          </div>\n  1380                          <div className=\"space-y-1\">\n  1381                            <label className=\"text-[9px] font-black text-text-tertiary/40 uppercase tracking-widest ml-1\">Value</label>\n  1382                            <input\n  1383                              type=\"password\"\n  1384                              placeholder=\"Secret value\"\n  1385                              value={newVaultSecret.value}\n  1386                              onChange={(e) => setNewVaultSecret(prev => ({ ...prev, value: e.target.value }))}\n  1387                              className=\"w-full bg-transparent border-b border-border/10 px-0 py-1 text-[11px] text-text-primary focus:outline-none focus:border-accent/40 font-mono transition-all\"\n  1388                            />\n  1389                          </div>\n  1390                        </div>\n  1391                        <button\n  1392                          onClick={handleSetVaultSecret}\n  1393                          disabled={isSaving || !newVaultSecret.name || !newVaultSecret.value}\n  1394                          className=\"w-full py-1 text-accent hover:text-accent-hover font-black text-[10px] uppercase tracking-widest transition-all disabled:opacity-20 active:scale-[0.98]\"\n  1395                        >\n  1396                          Store in Vault\n  1397                        </button>\n  1398                      </div>\n  1399                    </div>\n  1400                  </div>\n  1401                </section>\n  1402              </div>\n  1403            )\n  1404            }\n  1405\n  1406            {activeTab === 'shortcuts' && (\n  1407              <div className=\"space-y-8 animate-in fade-in slide-in-from-bottom-2 duration-300 font-mono\">\n  1408                {/* All Hotkeys Section */}\n  1409                <section className=\"space-y-3\">\n  1410                  <div className=\"flex flex-col gap-0.5\">\n  1411                    <div className=\"flex items-center gap-2 text-accent/80\">\n  1412                      <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Shortcuts</h2>\n  1413                    </div>\n  1414                  </div>\n  1415\n  1416                  <div className=\"bg-surface/5 border border-border/10 p-5\">\n  1417                    <div className=\"grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-1\">\n  1418                      {Object.entries(hotkeyLabels).map(([key, label]) => (\n  1419                        <div key={key} className=\"flex items-center justify-between py-1.5 border-b border-border/5 last:border-0 md:[&:nth-last-child(-n+2)]:border-0\">\n  1420                          <span className=\"text-[10px] font-black text-text-tertiary/60 uppercase tracking-widest\">{label}</span>\n  1421                          <button\n  1422                            onClick={() => setRecordingHotkey(key)}\n  1423                            className={clsx(\n  1424                              \"font-mono text-[10px] font-black transition-all min-w-[90px] text-right\",\n  1425                              recordingHotkey === key\n  1426                                ? \"text-accent animate-pulse\"\n  1427                                : \"text-accent/60 hover:text-accent\"\n  1428                            )}\n  1429                          >\n  1430                            {recordingHotkey === key ? 'Recording...' : ((config?.ui as any)?.hotkeys?.[key] || hotkeyDefaults[key] || 'N/A')}\n  1431                          </button>\n  1432                        </div>\n  1433                      ))}\n  1434                    </div>\n  1435                        <div className=\"mt-6 pt-3 border-t border-border/5\">\n  1436                      <p className=\"text-[9px] text-text-tertiary/20 tracking-tighter italic font-black\">\n  1437                        Press Escape to cancel. System reserved keys may override.\n  1438                      </p>\n  1439                    </div>\n  1440                  </div>\n  1441                </section>\n  1442              </div>\n  1443            )\n  1444            }\n  1445          </div >\n  1446        </div >\n  1447      </div >\n  1448    </div >\n  1449  );\n  1450};\n  1451\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3a2ff478-14fb-49e3-bddf-4832315c2f68","timestamp":"2026-01-03T12:10:51.511Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SettingsView.tsx","content":"import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\nimport { api } from '../../lib/api';\nimport { clsx } from 'clsx';\nimport { ask } from '@tauri-apps/plugin-dialog';\nimport { useSystem } from '../../context/SystemContext';\nimport { useAgents } from '../../context/AgentContext';\n\nexport const SettingsView: React.FC = () => {\n  const queryClient = useQueryClient();\n  const { setExplorerCollapsed } = useAgents();\n  const { data: config, refetch: refetchConfig } = useQuery({\n    queryKey: ['config'],\n    queryFn: () => api.getConfig(),\n  });\n\n  const { data: apiKeys } = useQuery({\n    queryKey: ['apiKeys'],\n    queryFn: () => api.getApiKeys(),\n  });\n\n  const { data: vaultSecrets, refetch: refetchVault } = useQuery({\n    queryKey: ['vaultSecrets'],\n    queryFn: () => api.listVaultSecrets(),\n  });\n\n  const { data: status } = useQuery({\n    queryKey: ['status'],\n    queryFn: () => api.getStatus(),\n    refetchInterval: 5000,\n  });\n\n  const handleToggleAlwaysAllowAll = async () => {\n    const current = !!config?.security?.always_allow_all;\n    if (!current) {\n      const confirmed = await ask(\"WARNING: This will automatically approve ALL tool calls (including shell and browser) from ALL agents and sub-agents. This grants autonomous agents full control over your local system and web presence. Are you sure you want to disable all security oversight?\", {\n        title: \"Danger: Disable All Approvals\",\n        kind: \"error\",\n      });\n      if (!confirmed) return;\n    }\n\n    try {\n      await api.updateConfig({ security: { always_allow_all: !current } });\n      await refetchConfig();\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to toggle always allow all:', err);\n    }\n  };\n\n  const handleUpdateShellPermissionMode = async (mode: string) => {\n    try {\n      await api.updateConfig({ security: { shell_permission_mode: mode } });\n      await refetchConfig();\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to update shell permission mode:', err);\n    }\n  };\n\n  const handleToggleSubAgentsGlobal = async () => {\n    try {\n      const current = !!config?.sub_agent?.enabled;\n      await api.updateConfig({ sub_agent: { enabled: !current } });\n      await refetchConfig();\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to toggle sub-agents globally:', err);\n    }\n  };\n\n  const [isSaving, setIsSaving] = useState(false);\n  const [_showSuccess, setShowSuccess] = useState(false);\n  const [newKey, setNewKey] = useState<{ provider: string; key: string }>({ provider: '', key: '' });\n  const [newVaultSecret, setNewVaultSecret] = useState<{ name: string; value: string }>({ name: '', value: '' });\n  const [customBaseUrl, setCustomBaseUrl] = useState('');\n  const [isAddingCustomProvider, setIsAddingCustomProvider] = useState(false);\n  const [newCustomProviderName, setNewCustomProviderName] = useState('');\n\n  const [editingProvider, setEditingProvider] = useState<string | null>(null);\n  const [editingCapability, setEditingCapability] = useState<string>('chat');\n  const [newModelName, setNewModelName] = useState('');\n  const [isFetchingModels, setIsFetchingModels] = useState(false);\n  const { activeSettingsTab: activeTab } = useSystem();\n\n  const [recordingHotkey, setRecordingHotkey] = useState<string | null>(null);\n  const autoFetchedProviders = useRef<Set<string>>(new Set());\n\n  // Reasoning levels\n  type ReasoningLevel = '' | 'low' | 'medium' | 'high';\n  const reasoningLevels: { value: ReasoningLevel; label: string }[] = [\n    { value: '', label: 'None' },\n    { value: 'low', label: 'Low' },\n    { value: 'medium', label: 'Medium' },\n    { value: 'high', label: 'High' },\n  ];\n\n  // Helper to parse model string for reasoning level\n  // e.g., \"claude-haiku-4.5:thinking-high\" -> { baseModel: \"claude-haiku-4.5\", level: \"high\" }\n  const parseModelLevel = (model: string): { baseModel: string; level: ReasoningLevel } => {\n    for (const l of ['low', 'medium', 'high'] as ReasoningLevel[]) {\n      const suffix = `:thinking-${l}`;\n      if (model.endsWith(suffix)) {\n        return { baseModel: model.replace(suffix, ''), level: l };\n      }\n    }\n    // Legacy: :thinking without level = high\n    if (model.endsWith(':thinking')) {\n      return { baseModel: model.replace(':thinking', ''), level: 'high' };\n    }\n    return { baseModel: model, level: '' };\n  };\n\n  // Helper to build model string from base and level\n  const buildModelString = (baseModel: string, level: ReasoningLevel): string => {\n    if (level) {\n      return `${baseModel}:thinking-${level}`;\n    }\n    return baseModel;\n  };\n\n  // Providers that support thinking/reasoning\n  const thinkingProviders = ['openrouter', 'anthropic', 'openai', 'gemini'];\n\n  // Update a model's reasoning level\n  const handleUpdateModelLevel = async (oldModel: string, newLevel: ReasoningLevel) => {\n    if (!editingProvider || !editingCapability) return;\n\n    const { baseModel } = parseModelLevel(oldModel);\n    const newModel = buildModelString(baseModel, newLevel);\n\n    if (newModel === oldModel) return; // No change\n\n    const models = availableModels[editingProvider]?.[editingCapability] || [];\n    const updatedModels = models.map(m => m === oldModel ? newModel : m);\n\n    const updatedAvailableModels = {\n      ...availableModels,\n      [editingProvider]: {\n        ...(availableModels[editingProvider] || {}),\n        [editingCapability]: updatedModels\n      }\n    };\n\n    setIsSaving(true);\n    try {\n      await api.updateConfig({ available_models: updatedAvailableModels });\n      await refetchConfig();\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to update model reasoning level:', err);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  useEffect(() => {\n    setExplorerCollapsed(false);\n  }, []);\n\n  const successTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const triggerSuccess = useCallback(() => {\n    setShowSuccess(true);\n    if (successTimeoutRef.current) clearTimeout(successTimeoutRef.current);\n    successTimeoutRef.current = setTimeout(() => setShowSuccess(false), 3000);\n  }, []);\n\n  useEffect(() => {\n    if (recordingHotkey) {\n      const handleGlobalKeyDown = (e: KeyboardEvent) => {\n        // Don't intercept if it's just a modifier key\n        if (['Control', 'Shift', 'Alt', 'Meta'].includes(e.key)) return;\n\n        e.preventDefault();\n        e.stopPropagation();\n\n        if (e.key === 'Escape') {\n          setRecordingHotkey(null);\n          return;\n        }\n\n        const modifiers = [];\n        if (e.metaKey) modifiers.push('Cmd');\n        else if (e.ctrlKey) modifiers.push('Ctrl');\n\n        if (e.shiftKey) modifiers.push('Shift');\n        if (e.altKey) modifiers.push('Alt');\n\n        let key = e.key;\n        if (key === ' ') key = 'Space';\n        if (key.length === 1) key = key.toUpperCase();\n\n        const hotkey = modifiers.length > 0 ? `${modifiers.join('+')}+${key}` : key;\n\n        handleUpdateHotkey(recordingHotkey, hotkey);\n        setRecordingHotkey(null);\n      };\n\n      window.addEventListener('keydown', handleGlobalKeyDown, true);\n      return () => window.removeEventListener('keydown', handleGlobalKeyDown, true);\n    }\n  }, [recordingHotkey, config]);\n\n  const handleUpdateHotkey = async (key: string, value: string) => {\n    const updatedHotkeys = { ...((config?.ui as any)?.hotkeys || {}), [key]: value };\n    try {\n      await api.updateConfig({ ui: { hotkeys: updatedHotkeys } });\n      await refetchConfig();\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to update hotkey:', err);\n    }\n  };\n\n  const hotkeyDefaults: Record<string, string> = {\n    'global_back': 'Escape',\n    'new_agent': 'Cmd+N',\n    'focus_input': 'Cmd+L',\n    'toggle_sidebar': 'Cmd+B',\n    'toggle_settings': 'Cmd+,',\n    'toggle_pause': 'Cmd+P',\n    'compact': 'Cmd+Shift+C',\n    'toggle_unibar': 'Cmd+K',\n    'delete_agent': 'Cmd+D',\n    'toggle_explorer': 'Cmd+E',\n    'scroll_to_top': 'Cmd+ArrowUp',\n    'scroll_to_bottom': 'Cmd+ArrowDown',\n    'attach_file': 'Cmd+Shift+A',\n  };\n\n  const hotkeyLabels: Record<string, string> = {\n    'global_back': 'Go Back',\n    'new_agent': 'New Agent',\n    'focus_input': 'Focus Chat Input',\n    'toggle_sidebar': 'Toggle Sidebar',\n    'toggle_settings': 'Open Settings',\n    'toggle_pause': 'Pause / Resume Agent',\n    'compact': 'Compact Conversation',\n    'toggle_unibar': 'Command Palette',\n    'delete_agent': 'Delete Selected Agent',\n    'toggle_explorer': 'Toggle File Explorer',\n    'scroll_to_top': 'Scroll to Top',\n    'scroll_to_bottom': 'Scroll to Bottom',\n    'attach_file': 'Attach File',\n  };\n\n  // Pointer-based drag state (bypasses Tauri's drag interception)\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragSourceIndex, setDragSourceIndex] = useState<number | null>(null);\n  const [dragTargetIndex, setDragTargetIndex] = useState<number | null>(null);\n  const itemRefs = useRef<(HTMLDivElement | null)[]>([]);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const scrollRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Don't scroll if we're recording a hotkey or typing in an input\n      if (recordingHotkey) return;\n\n      const activeElement = document.activeElement;\n      const isInput = activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement ||\n        (activeElement as HTMLElement)?.isContentEditable;\n\n      if (isInput && !(e.metaKey || e.ctrlKey)) return;\n\n      if (e.key === 'ArrowUp') {\n        if (scrollRef.current) {\n          e.preventDefault();\n          scrollRef.current.scrollBy({ top: -100, behavior: 'smooth' });\n        }\n      }\n      if (e.key === 'ArrowDown') {\n        if (scrollRef.current) {\n          e.preventDefault();\n          scrollRef.current.scrollBy({ top: 100, behavior: 'smooth' });\n        }\n      }\n      if (e.key === ' ' && !isInput) {\n        if (scrollRef.current) {\n          e.preventDefault();\n          const direction = e.shiftKey ? -1 : 1;\n          scrollRef.current.scrollBy({\n            top: direction * scrollRef.current.clientHeight * 0.8,\n            behavior: 'smooth'\n          });\n        }\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [recordingHotkey]);\n\n\n\n  useEffect(() => {\n    if (!editingProvider && config?.available_models && apiKeys) {\n      const availableModels = config.available_models;\n      const providers = Object.keys(availableModels);\n\n      // Preference order for default selection\n      const preference = ['openrouter', 'anthropic', 'openai', 'gemini'];\n      const defaultProvider = preference.find(p => providers.some(ap => ap.toLowerCase() === p));\n\n      if (defaultProvider) {\n        const matching = providers.find(p => p.toLowerCase() === defaultProvider);\n        if (matching) {\n          setEditingProvider(matching);\n          setNewKey(prev => ({ ...prev, provider: matching }));\n        }\n      } else if (providers.length > 0) {\n        setEditingProvider(providers[0]);\n        setNewKey(prev => ({ ...prev, provider: providers[0] }));\n      }\n    }\n  }, [config, editingProvider, apiKeys]);\n\n  useEffect(() => {\n    if (editingProvider && config?.custom_providers?.[editingProvider]) {\n      setCustomBaseUrl(config?.custom_providers[editingProvider].base_url || '');\n    } else {\n      setCustomBaseUrl('');\n    }\n  }, [editingProvider, config?.custom_providers]);\n\n  const availableModels = config?.available_models || {};\n  const localProvidersList = ['ollama', 'lmstudio'];\n  const standardProviders = ['openrouter', 'anthropic', 'openai', 'gemini', 'ollama', 'lmstudio'];\n\n  const handleFetchModels = useCallback(async (provider: string) => {\n    if (isFetchingModels) return;\n    setIsFetchingModels(true);\n    try {\n      const response = await api.fetchModels(provider);\n      if (response && response.models) {\n        const updatedAvailableModels = {\n          ...availableModels,\n          [provider]: {\n            ...(availableModels[provider] || {}),\n            chat: response.models\n          }\n        };\n\n        // If this is the active provider and has no model set, pick the first one\n        const updates: any = { available_models: updatedAvailableModels };\n        if (provider === config?.inference?.chat?.provider && (!config?.inference?.chat?.model || (availableModels[provider]?.chat?.length || 0) === 0)) {\n          if (response.models.length > 0) {\n            updates.inference = {\n              ...config.inference,\n              chat: {\n                ...config.inference.chat,\n                model: response.models[0]\n              }\n            };\n          }\n        }\n\n        await api.updateConfig(updates);\n        await refetchConfig();\n        triggerSuccess();\n      }\n    } catch (err) {\n      console.error('Failed to fetch models:', err);\n    } finally {\n      setIsFetchingModels(false);\n    }\n  }, [availableModels, config, isFetchingModels, refetchConfig, triggerSuccess]);\n\n  useEffect(() => {\n    if (editingProvider && localProvidersList.includes(editingProvider.toLowerCase())) {\n      const currentChatModels = availableModels[editingProvider]?.chat || [];\n      if (currentChatModels.length === 0 && !isFetchingModels && !autoFetchedProviders.current.has(editingProvider.toLowerCase())) {\n        autoFetchedProviders.current.add(editingProvider.toLowerCase());\n        handleFetchModels(editingProvider);\n      }\n    }\n  }, [editingProvider, availableModels, isFetchingModels, handleFetchModels]);\n\n  const allProviders = Object.keys(availableModels);\n  const cloudProviders = allProviders.filter(p => standardProviders.includes(p.toLowerCase()) && !localProvidersList.includes(p.toLowerCase()));\n  const localProviders = allProviders.filter(p => standardProviders.includes(p.toLowerCase()) && localProvidersList.includes(p.toLowerCase()));\n  const userCustomProvidersList = allProviders.filter(p => !standardProviders.includes(p.toLowerCase()));\n\n  const currentModels = (editingProvider && editingCapability) ? (availableModels[editingProvider]?.[editingCapability] || []) : [];\n\n  const handleAddCustomProvider = async () => {\n    if (!newCustomProviderName.trim()) return;\n    const name = newCustomProviderName.trim().toLowerCase();\n    if (standardProviders.includes(name) || userCustomProvidersList.includes(name)) {\n      alert('Provider name already exists or is reserved.');\n      return;\n    }\n\n    setIsSaving(true);\n    try {\n      const updatedCustomProviders = {\n        ...(config?.custom_providers || {}),\n        [name]: { base_url: '' }\n      };\n      await api.updateConfig({ custom_providers: updatedCustomProviders });\n      await refetchConfig();\n      setEditingProvider(name);\n      setIsAddingCustomProvider(false);\n      setNewCustomProviderName('');\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to add custom provider:', err);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handleRemoveCustomProvider = async (name: string) => {\n    const confirmed = await ask(`Are you sure you want to delete the custom provider \"${name}\"?`, {\n      title: 'Delete Provider',\n      kind: 'warning',\n    });\n\n    if (!confirmed) return;\n\n    setIsSaving(true);\n    try {\n      // Wipe API key from keychain first\n      try {\n        await api.removeApiKey(name);\n      } catch (keyErr) {\n        console.warn(`Failed to remove API key for ${name}:`, keyErr);\n      }\n\n      const updatedCustomProviders = { ...(config?.custom_providers || {}) };\n      delete updatedCustomProviders[name];\n\n      const updatedAvailableModels = { ...(config?.available_models || {}) };\n      delete updatedAvailableModels[name];\n\n      await api.updateConfig({\n        custom_providers: updatedCustomProviders,\n        available_models: updatedAvailableModels\n      });\n      await queryClient.invalidateQueries({ queryKey: ['config'] });\n      await queryClient.invalidateQueries({ queryKey: ['apiKeys'] });\n      if (editingProvider === name) {\n        setEditingProvider(cloudProviders[0] || 'openai');\n      }\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to remove custom provider:', err);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handleAddModel = async () => {\n    if (!editingProvider || !editingCapability || !newModelName.trim()) return;\n\n    const modelToAdd = newModelName.trim();\n    if (currentModels.includes(modelToAdd)) return;\n\n    const updatedModels = [...currentModels, modelToAdd];\n    const updatedAvailableModels = {\n      ...availableModels,\n      [editingProvider]: {\n        ...(availableModels[editingProvider] || {}),\n        [editingCapability]: updatedModels\n      }\n    };\n\n    const updates: any = { available_models: updatedAvailableModels };\n\n    // If this is the first model for this provider, and it's the default provider, set it as default model\n    if (editingProvider === config?.inference?.chat?.provider && editingCapability === 'chat' && currentModels.length === 0) {\n      updates.inference = {\n        ...config.inference,\n        chat: {\n          ...config.inference.chat,\n          model: modelToAdd\n        }\n      };\n    }\n\n    setIsSaving(true);\n    try {\n      await api.updateConfig(updates);\n      setNewModelName('');\n      await refetchConfig();\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to add model:', err);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handleRemoveModel = async (modelName: string) => {\n    if (!editingProvider || !editingCapability) return;\n    const updatedModels = currentModels.filter(m => m !== modelName);\n    const updatedAvailableModels = {\n      ...availableModels,\n      [editingProvider]: {\n        ...(availableModels[editingProvider] || {}),\n        [editingCapability]: updatedModels\n      }\n    };\n\n    const updates: any = { available_models: updatedAvailableModels };\n\n    // If we removed the top model, or changed the list, and this is the default provider, update the default model\n    if (editingProvider === config?.inference?.chat?.provider && editingCapability === 'chat' && updatedModels.length > 0) {\n      if (updatedModels[0] !== currentModels[0]) {\n        updates.inference = {\n          ...config.inference,\n          chat: {\n            ...config.inference.chat,\n            model: updatedModels[0]\n          }\n        };\n      }\n    }\n\n    setIsSaving(true);\n    try {\n      await api.updateConfig(updates);\n      await refetchConfig();\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to remove model:', err);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const saveModelOrder = async (newModels: string[]) => {\n    if (!editingProvider || !editingCapability) return;\n\n    const updatedAvailableModels = {\n      ...availableModels,\n      [editingProvider]: {\n        ...(availableModels[editingProvider] || {}),\n        [editingCapability]: newModels\n      }\n    };\n\n    const updates: any = { available_models: updatedAvailableModels };\n\n    // If we moved something to the top, and this is the default provider, update the default model\n    if (editingProvider === config?.inference?.chat?.provider && editingCapability === 'chat') {\n      updates.inference = {\n        ...config.inference,\n        chat: {\n          ...config.inference.chat,\n          model: newModels[0]\n        }\n      };\n    }\n\n    setIsSaving(true);\n    try {\n      await api.updateConfig(updates);\n      await refetchConfig();\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to update model order:', err);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  // Pointer-based drag handlers (works in Tauri)\n  const handlePointerDown = useCallback((e: React.PointerEvent, index: number) => {\n    e.preventDefault();\n    setIsDragging(true);\n    setDragSourceIndex(index);\n    setDragTargetIndex(index);\n    (e.target as HTMLElement).setPointerCapture(e.pointerId);\n  }, []);\n\n  const handlePointerMove = useCallback((e: React.PointerEvent) => {\n    if (!isDragging || dragSourceIndex === null || !containerRef.current) return;\n\n    const containerRect = containerRef.current.getBoundingClientRect();\n    const y = e.clientY - containerRect.top;\n\n    // Find which item we're over\n    let newTargetIndex = dragSourceIndex;\n    for (let i = 0; i < itemRefs.current.length; i++) {\n      const item = itemRefs.current[i];\n      if (!item) continue;\n      const rect = item.getBoundingClientRect();\n      const itemY = rect.top - containerRect.top + rect.height / 2;\n      if (y < itemY) {\n        newTargetIndex = i;\n        break;\n      }\n      newTargetIndex = i + 1;\n    }\n    newTargetIndex = Math.max(0, Math.min(newTargetIndex, currentModels.length - 1));\n\n    if (newTargetIndex !== dragTargetIndex) {\n      setDragTargetIndex(newTargetIndex);\n    }\n  }, [isDragging, dragSourceIndex, dragTargetIndex, currentModels.length]);\n\n  const handlePointerUp = useCallback(async (e: React.PointerEvent) => {\n    if (!isDragging) return;\n    (e.target as HTMLElement).releasePointerCapture(e.pointerId);\n\n    const sourceIndex = dragSourceIndex;\n    const targetIndex = dragTargetIndex;\n\n    setIsDragging(false);\n    setDragSourceIndex(null);\n    setDragTargetIndex(null);\n\n    if (sourceIndex === null || targetIndex === null || sourceIndex === targetIndex) return;\n\n    const newModels = [...currentModels];\n    const [removed] = newModels.splice(sourceIndex, 1);\n    newModels.splice(targetIndex, 0, removed);\n\n    await saveModelOrder(newModels);\n  }, [isDragging, dragSourceIndex, dragTargetIndex, currentModels, saveModelOrder]);\n\n\n  const handleToggleAutoCompaction = async () => {\n    try {\n      const current = config?.agent?.auto_compaction_enabled !== false; // Default to true if undefined\n      await api.updateConfig({ agent: { auto_compaction_enabled: !current } });\n      await refetchConfig();\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to toggle auto-compaction:', err);\n    }\n  };\n\n  const handleSetApiKey = async () => {\n    if (!newKey.provider || !newKey.key) return;\n    setIsSaving(true);\n    try {\n      await api.setApiKey(newKey.provider, newKey.key);\n      setNewKey({ provider: '', key: '' });\n      await queryClient.invalidateQueries({ queryKey: ['apiKeys'] });\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to set API key:', err);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handleSaveCustomBaseUrl = async () => {\n    if (!customBaseUrl.trim() || !editingProvider) return;\n    setIsSaving(true);\n    try {\n      const updatedCustomProviders = {\n        ...(config?.custom_providers || {}),\n        [editingProvider]: { base_url: customBaseUrl.trim() }\n      };\n      await api.updateConfig({ custom_providers: updatedCustomProviders });\n      await queryClient.invalidateQueries({ queryKey: ['config'] });\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to update custom provider base URL:', err);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handleRemoveApiKey = async (provider: string) => {\n    const confirmed = await ask(`Are you sure you want to wipe the API key for ${provider.toUpperCase()}? This will prevent agents from using this provider until a new key is registered.`, {\n      title: 'Wipe API Key',\n      kind: 'warning',\n    });\n\n    if (!confirmed) return;\n\n    try {\n      await api.removeApiKey(provider);\n      await queryClient.invalidateQueries({ queryKey: ['apiKeys'] });\n    } catch (err) {\n      console.error('Failed to remove API key:', err);\n    }\n  };\n\n  const handleToggleProvider = async (provider: string, currentEnabled: boolean) => {\n    setIsSaving(true);\n    try {\n      const updatedProviders = {\n        ...(config?.providers || {}),\n        [provider]: { enabled: !currentEnabled }\n      };\n      await api.updateConfig({ providers: updatedProviders });\n      await queryClient.invalidateQueries({ queryKey: ['config'] });\n      await queryClient.invalidateQueries({ queryKey: ['apiKeys'] });\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to toggle provider:', err);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handleSetVaultSecret = async () => {\n    if (!newVaultSecret.name || !newVaultSecret.value) return;\n    setIsSaving(true);\n    try {\n      await api.setVaultSecret(newVaultSecret.name, newVaultSecret.value);\n      setNewVaultSecret({ name: '', value: '' });\n      await refetchVault();\n      triggerSuccess();\n    } catch (err) {\n      console.error('Failed to set vault secret:', err);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handleRemoveVaultSecret = async (name: string) => {\n    const confirmed = await ask(`Are you sure you want to delete the secret \"${name}\"? This cannot be undone.`, {\n      title: 'Delete Secret',\n      kind: 'warning',\n    });\n\n    if (!confirmed) return;\n\n    try {\n      await api.removeVaultSecret(name);\n      refetchVault();\n    } catch (err) {\n      console.error('Failed to remove vault secret:', err);\n    }\n  };\n\n  return (\n    <div className=\"flex h-full bg-background font-mono text-[13px] overflow-hidden\">\n      {/* Main Content Area */}\n      <div className=\"flex-1 flex flex-col min-w-0 bg-background relative\">\n        <div className=\"flex-1 overflow-auto p-8 custom-scrollbar relative\" ref={scrollRef}>\n          <div className=\"max-w-4xl mx-auto pb-20\">\n            {activeTab === 'models' && (\n              <div className=\"space-y-8 animate-in fade-in slide-in-from-bottom-2 duration-300 font-mono\">\n                {/* Model Registry Section */}\n                <section className=\"space-y-3\">\n                  <div className=\"flex flex-col gap-0.5\">\n                    <div className=\"flex items-center gap-2 text-accent/80\">\n                      <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Provider Configuration</h2>\n                    </div>\n                    <p className=\"text-[10px] text-text-tertiary/60 italic leading-normal font-black tracking-tight\">\n                      LLM providers and endpoints. Credentials stored in system keychain.\n                    </p>\n                  </div>\n\n                  <div className=\"flex flex-col md:flex-row bg-surface/5 border border-border/10 overflow-hidden min-h-[450px]\">\n                    {/* Left Sidebar: Providers */}\n                    <div className=\"w-full md:w-48 border-b md:border-b-0 md:border-r border-border/10 bg-background/20 flex flex-col font-mono\">\n                      <div className=\"p-3 border-b border-border/10 bg-background/10 flex items-center justify-between\">\n                        <span className=\"text-[10px] font-black text-accent/60 uppercase tracking-[0.2em]\">Providers</span>\n                        <button\n                          onClick={() => setIsAddingCustomProvider(true)}\n                          className=\"text-accent/60 hover:text-accent transition-colors text-[10px]\"\n                          title=\"Add custom provider\"\n                        >\n                          [+]\n                        </button>\n                      </div>\n                      <div className=\"flex-1 overflow-auto p-1.5 space-y-0.5 custom-scrollbar\">\n                        {isAddingCustomProvider && (\n                          <div className=\"px-1.5 py-2 space-y-1.5 border-b border-border/10 mb-2\">\n                            <input\n                              autoFocus\n                              type=\"text\"\n                              placeholder=\"Custom provider name...\"\n                              value={newCustomProviderName}\n                              onChange={(e) => setNewCustomProviderName(e.target.value.toLowerCase().replace(/[^a-z0-9_-]/g, ''))}\n                              onKeyDown={(e) => {\n                                if (e.key === 'Enter') handleAddCustomProvider();\n                                if (e.key === 'Escape') setIsAddingCustomProvider(false);\n                              }}\n                              className=\"w-full bg-transparent border-b border-accent/20 px-1 py-0.5 text-[10px] text-text-primary focus:outline-none font-mono uppercase\"\n                            />\n                            <div className=\"flex gap-1\">\n                              <button\n                                onClick={handleAddCustomProvider}\n                                className=\"flex-1 py-0.5 text-accent text-[9px] font-black border border-accent/20 hover:bg-accent/5\"\n                              >\n                                Add\n                              </button>\n                              <button\n                                onClick={() => setIsAddingCustomProvider(false)}\n                                className=\"flex-1 py-0.5 text-text-tertiary/60 text-[9px] font-black border border-border/10 hover:bg-surface/10\"\n                              >\n                                Cancel\n                              </button>\n                            </div>\n                          </div>\n                        )}\n\n                        {/* All providers in a flat list */}\n                        {[...cloudProviders, ...userCustomProvidersList, ...localProviders].map(p => {\n                          const providerData = apiKeys?.find(k => k.provider.toLowerCase() === p.toLowerCase());\n                          const isConfigured = providerData?.configured;\n                          const isEnabled = providerData?.enabled === true;\n                          const isLocal = localProvidersList.includes(p.toLowerCase());\n                          const isCustom = userCustomProvidersList.includes(p);\n\n                          return (\n                            <button\n                              key={p}\n                              onClick={() => {\n                                setEditingProvider(p);\n                                setNewKey(prev => ({ ...prev, provider: p }));\n                              }}\n                              className={clsx(\n                                \"w-full px-2 py-1.5 text-left text-[11px] font-black uppercase transition-all flex items-center justify-between\",\n                                editingProvider === p\n                                  ? \"text-accent bg-accent/5\"\n                                  : \"text-text-tertiary/60 hover:text-text-secondary hover:bg-surface/5\",\n                                !isEnabled && \"opacity-40\"\n                              )}\n                            >\n                              <div className=\"flex items-center gap-2\">\n                                <span className=\"w-2 text-[10px]\">{editingProvider === p ? '>' : ' '}</span>\n                                <span className=\"truncate\">{p}</span>\n                                {isLocal && <span className=\"text-[7px] text-text-tertiary/30\">LOCAL</span>}\n                                {isCustom && <span className=\"text-[7px] text-text-tertiary/30\">CUSTOM</span>}\n                              </div>\n                              {!isLocal && (\n                                <div className={clsx(\n                                  \"w-1.5 h-1.5 rounded-full shrink-0\",\n                                  isConfigured ? \"bg-status-success\" : \"bg-status-error/40\"\n                                )} />\n                              )}\n                            </button>\n                          );\n                        })}\n                      </div>\n                    </div>\n\n                    {/* Right Panel: Skills and Models */}\n                    <div className=\"flex-1 flex flex-col bg-background/5 font-mono\">\n                      {!editingProvider ? (\n                        <div className=\"flex-1 flex flex-col items-center justify-center text-text-tertiary/20 space-y-2\">\n                          <span className=\"text-[10px] uppercase font-black tracking-[0.2em]\">Select a provider</span>\n                          <div className=\"animate-pulse\">_</div>\n                        </div>\n                      ) : (\n                        <div className=\"flex-1 overflow-auto p-5 space-y-6 custom-scrollbar\">\n                          {/* Provider Header */}\n                          {(() => {\n                            const providerData = apiKeys?.find(k => k.provider.toLowerCase() === editingProvider.toLowerCase());\n                            const isConfigured = providerData?.configured;\n                            const isEnabled = providerData?.enabled === true;\n                            const isLocal = localProvidersList.includes(editingProvider.toLowerCase());\n                            const isCustom = userCustomProvidersList.includes(editingProvider);\n\n                            return (\n                              <div className=\"space-y-4\">\n                                {/* Provider name and enable toggle */}\n                                <div className=\"flex items-center justify-between\">\n                                  <div className=\"flex items-center gap-3\">\n                                    <span className=\"text-[14px] font-black text-text-primary uppercase tracking-[0.1em]\">\n                                      {editingProvider}\n                                    </span>\n                                    {isLocal && (\n                                      <span className=\"text-[8px] font-black text-accent/50 uppercase tracking-widest px-1.5 py-0.5 border border-accent/20\">Local</span>\n                                    )}\n                                    {isCustom && (\n                                      <span className=\"text-[8px] font-black text-text-tertiary/50 uppercase tracking-widest px-1.5 py-0.5 border border-border/20\">Custom</span>\n                                    )}\n                                  </div>\n\n                                  <div className=\"flex items-center gap-3\">\n                                    {/* Enable/Disable toggle */}\n                                    <button\n                                      onClick={() => handleToggleProvider(editingProvider, isEnabled)}\n                                      className={clsx(\n                                        \"text-[9px] font-black px-3 py-1 transition-all tracking-widest uppercase active:scale-95\",\n                                        isEnabled\n                                          ? \"text-status-success bg-status-success/10 hover:bg-status-success/15\"\n                                          : \"text-text-tertiary/40 bg-surface/10 hover:bg-surface/20\"\n                                      )}\n                                    >\n                                      {isEnabled ? 'Enabled' : 'Disabled'}\n                                    </button>\n\n                                    {/* Delete custom provider */}\n                                    {isCustom && (\n                                      <button\n                                        onClick={() => handleRemoveCustomProvider(editingProvider)}\n                                        className=\"text-[9px] text-text-tertiary/30 hover:text-status-error transition-all uppercase font-black\"\n                                        title=\"Delete provider\"\n                                      >\n                                        [Delete]\n                                      </button>\n                                    )}\n                                  </div>\n                                </div>\n\n                                {/* API Key Status - clear visual indicator */}\n                                {!isLocal && (\n                                  <div className={clsx(\n                                    \"p-3 border transition-all\",\n                                    isConfigured\n                                      ? \"border-status-success/20 bg-status-success/5\"\n                                      : \"border-status-error/20 bg-status-error/5\"\n                                  )}>\n                                    {isConfigured ? (\n                                      <div className=\"flex items-center justify-between\">\n                                        <div className=\"flex items-center gap-2\">\n                                          <div className=\"w-2 h-2 rounded-full bg-status-success\" />\n                                          <span className=\"text-[10px] font-black text-status-success uppercase tracking-widest\">API Key Configured</span>\n                                        </div>\n                                        <button\n                                          onClick={() => handleRemoveApiKey(editingProvider)}\n                                          className=\"text-[9px] text-text-tertiary/40 hover:text-status-error transition-all uppercase font-black\"\n                                        >\n                                          [Remove Key]\n                                        </button>\n                                      </div>\n                                    ) : (\n                                      <div className=\"space-y-3\">\n                                        <div className=\"flex items-center gap-2\">\n                                          <div className=\"w-2 h-2 rounded-full bg-status-error/50\" />\n                                          <span className=\"text-[10px] font-black text-status-error/70 uppercase tracking-widest\">API Key Required</span>\n                                        </div>\n                                        <div className=\"flex gap-2\">\n                                          <input\n                                            type=\"password\"\n                                            placeholder=\"Paste your API key...\"\n                                            value={newKey.key}\n                                            onChange={(e) => setNewKey(prev => ({ ...prev, key: e.target.value }))}\n                                            onKeyDown={(e) => e.key === 'Enter' && handleSetApiKey()}\n                                            className=\"flex-1 bg-transparent border-b border-border/20 px-0 py-1 text-[11px] text-text-primary focus:outline-none focus:border-accent/40 font-mono transition-all\"\n                                          />\n                                          <button\n                                            onClick={handleSetApiKey}\n                                            disabled={isSaving || !newKey.key}\n                                            className=\"px-3 py-1 text-accent hover:text-accent-hover font-black text-[10px] uppercase tracking-widest transition-all disabled:opacity-20\"\n                                          >\n                                            Save\n                                          </button>\n                                        </div>\n                                      </div>\n                                    )}\n                                  </div>\n                                )}\n\n                                {/* Local provider notice */}\n                                {isLocal && (\n                                  <div className=\"p-3 border border-accent/20 bg-accent/5\">\n                                    <div className=\"flex items-center gap-2\">\n                                      <div className=\"w-2 h-2 rounded-full bg-accent\" />\n                                      <span className=\"text-[10px] font-black text-accent/70 uppercase tracking-widest\">No Authentication Required</span>\n                                    </div>\n                                  </div>\n                                )}\n\n                                {/* Custom provider endpoint URL */}\n                                {isCustom && (\n                                  <div className=\"space-y-2\">\n                                    <span className=\"text-[9px] font-black text-text-tertiary/60 uppercase tracking-widest\">Endpoint URL</span>\n                                    <div className=\"flex gap-2\">\n                                      <input\n                                        type=\"text\"\n                                        placeholder=\"https://api.provider.com/v1\"\n                                        value={customBaseUrl}\n                                        onChange={(e) => setCustomBaseUrl(e.target.value)}\n                                        onKeyDown={(e) => e.key === 'Enter' && handleSaveCustomBaseUrl()}\n                                        className=\"flex-1 bg-transparent border-b border-border/20 px-0 py-1 text-[11px] text-text-primary focus:outline-none focus:border-accent/40 font-mono transition-all\"\n                                      />\n                                      <button\n                                        onClick={handleSaveCustomBaseUrl}\n                                        disabled={isSaving || !customBaseUrl.trim()}\n                                        className=\"px-3 py-1 text-accent hover:text-accent-hover font-black text-[10px] uppercase tracking-widest transition-all disabled:opacity-20\"\n                                      >\n                                        Save\n                                      </button>\n                                    </div>\n                                  </div>\n                                )}\n                              </div>\n                            );\n                          })()}\n\n                          {/* Model Registry Content */}\n                          <div className=\"space-y-6\">\n                            <div className=\"flex items-center justify-between\">\n                              <span className=\"text-[9px] font-black text-text-tertiary/60 uppercase tracking-widest\">Models</span>\n                              {localProvidersList.includes(editingProvider?.toLowerCase() || '') && (\n                                <button\n                                  onClick={() => editingProvider && handleFetchModels(editingProvider)}\n                                  disabled={isFetchingModels}\n                                  className={clsx(\n                                    \"text-[9px] font-black uppercase tracking-widest transition-all\",\n                                    isFetchingModels ? \"text-text-tertiary/20 animate-pulse\" : \"text-accent hover:text-accent-hover\"\n                                  )}\n                                >\n                                  {isFetchingModels ? 'Discovering...' : 'Discover local models'}\n                                </button>\n                              )}\n                            </div>\n\n                            {['chat'].map(cap => {\n                              const models = availableModels[editingProvider]?.[cap] || [];\n                              const isEditing = editingCapability === cap;\n\n                              const isOpenRouter = editingProvider?.toLowerCase() === 'openrouter';\n                              const supportsThinking = thinkingProviders.includes(editingProvider?.toLowerCase() || '');\n\n                              return (\n                                <div key={cap} className=\"space-y-1\">\n                                  {/* Column headers */}\n                                  {(supportsThinking || isOpenRouter) && models.length > 0 && (\n                                    <div className=\"flex items-center gap-2 px-2 py-1 border-b border-border/10\">\n                                      <div className=\"w-6\" /> {/* Spacer for drag handle */}\n                                      <span className=\"flex-1 text-[8px] font-black text-text-tertiary/40 uppercase tracking-widest\">MODEL NAME</span>\n                                      {isOpenRouter && (\n                                        <span className=\"text-[8px] font-black text-text-tertiary/40 uppercase tracking-widest w-24 text-right\">PRICING (INPUT/OUTPUT per 1M TOK)</span>\n                                      )}\n                                      {supportsThinking && (\n                                        <span className=\"text-[8px] font-black text-text-tertiary/40 uppercase tracking-widest w-20 text-right\">REASONING</span>\n                                      )}\n                                      <div className=\"w-6\" /> {/* Spacer for delete button */}\n                                    </div>\n                                  )}\n                                  <div\n                                    ref={containerRef}\n                                    className=\"flex flex-col gap-0.5 min-h-[50px]\"\n                                  >\n                                    {models.map((model, index) => {\n                                      const { baseModel, level } = parseModelLevel(model);\n                                      // Use baseModel for pricing lookup since pricing is stored by base model name\n                                      const pricing = isOpenRouter && config?.model_pricing?.['openrouter']?.[cap]?.[baseModel];\n\n                                      return (\n                                        <div\n                                          key={model}\n                                          ref={el => { itemRefs.current[index] = el; }}\n                                          className={clsx(\n                                            \"flex items-center justify-between px-2 py-1 border-b border-border/5 group transition-all relative select-none gap-2\",\n                                            isDragging && dragSourceIndex === index && \"opacity-50\",\n                                            isDragging && dragTargetIndex === index && dragSourceIndex !== index && \"border-t border-accent\"\n                                          )}\n                                        >\n                                          {/* Drag handle */}\n                                          <div\n                                            className=\"text-text-tertiary/20 hover:text-accent transition-all cursor-grab active:cursor-grabbing p-1 -m-1 touch-none shrink-0\"\n                                            onPointerDown={(e) => handlePointerDown(e, index)}\n                                            onPointerMove={handlePointerMove}\n                                            onPointerUp={handlePointerUp}\n                                            onPointerCancel={handlePointerUp}\n                                          >\n                                            <span className=\"text-[8px] font-black\">{index === 0 ? '@' : '#'}</span>\n                                          </div>\n\n                                          {/* Model name */}\n                                          <div className=\"flex-1 min-w-0\">\n                                            <span className={clsx(\n                                              \"text-[10px] transition-colors truncate font-mono uppercase block\",\n                                              index === 0 ? \"text-accent font-black\" : \"text-text-primary/60 group-hover:text-text-primary\"\n                                            )}>{baseModel}</span>\n                                          </div>\n\n                                          {/* Pricing column for OpenRouter */}\n                                          {isOpenRouter && (\n                                            <div className=\"text-[9px] text-text-tertiary/60 font-mono text-right shrink-0 w-24\">\n                                              {pricing ? (\n                                                <span>${pricing.prompt.toFixed(2)}/${pricing.completion.toFixed(2)}</span>\n                                              ) : (\n                                                <span className=\"text-text-tertiary/20\"></span>\n                                              )}\n                                            </div>\n                                          )}\n\n                                          {/* Reasoning level dropdown */}\n                                          {supportsThinking && (\n                                            <select\n                                              value={level}\n                                              onChange={(e) => handleUpdateModelLevel(model, e.target.value as typeof level)}\n                                              className={clsx(\n                                                \"bg-transparent border px-1.5 py-0.5 text-[9px] font-black uppercase cursor-pointer transition-all shrink-0 w-20\",\n                                                level\n                                                  ? \"text-status-success border-status-success/30 bg-status-success/5\"\n                                                  : \"text-text-tertiary/50 border-border/20 hover:border-border/40\"\n                                              )}\n                                              style={{ WebkitAppearance: 'none', appearance: 'none', paddingRight: '16px', backgroundImage: 'url(\"data:image/svg+xml,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 fill=%27none%27 viewBox=%270 0 24 24%27 stroke=%27%23666%27%3e%3cpath stroke-linecap=%27round%27 stroke-linejoin=%27round%27 stroke-width=%272%27 d=%27M19 9l-7 7-7-7%27/%3e%3c/svg%3e\")', backgroundRepeat: 'no-repeat', backgroundPosition: 'right 2px center', backgroundSize: '10px' }}\n                                            >\n                                              {reasoningLevels.map(l => (\n                                                <option key={l.value} value={l.value}>{l.label}</option>\n                                              ))}\n                                            </select>\n                                          )}\n\n                                          {/* Remove button */}\n                                          <button\n                                            onClick={(e) => {\n                                              e.stopPropagation();\n                                              setEditingCapability(cap);\n                                              handleRemoveModel(model);\n                                            }}\n                                            className=\"text-text-tertiary/20 hover:text-status-error opacity-0 group-hover:opacity-100 transition-all text-[10px] font-black shrink-0\"\n                                          >\n                                            [X]\n                                          </button>\n                                        </div>\n                                      );\n                                    })}\n\n                                    {/* Inline Add Model Input */}\n                                    <div className=\"flex gap-2 group/input mt-1\">\n                                      <div className=\"flex-1 relative\">\n                                        <input\n                                          type=\"text\"\n                                          placeholder=\"Add model...\"\n                                          value={isEditing ? newModelName : ''}\n                                          onFocus={() => setEditingCapability(cap)}\n                                          onChange={(e) => {\n                                            setEditingCapability(cap);\n                                            setNewModelName(e.target.value);\n                                          }}\n                                          onKeyDown={(e) => e.key === 'Enter' && handleAddModel()}\n                                          className=\"w-full bg-transparent border-b border-dashed border-border/20 px-0 py-0.5 text-[10px] text-text-primary placeholder:text-text-tertiary/20 focus:outline-none focus:border-accent/40 focus:border-solid font-mono transition-all uppercase\"\n                                        />\n                                      </div>\n                                      {isEditing && newModelName.trim() && (\n                                        <button\n                                          onClick={handleAddModel}\n                                          className=\"text-accent text-[10px] font-black\"\n                                        >\n                                          [+]\n                                        </button>\n                                      )}\n                                    </div>\n                                  </div>\n                                </div>\n                              );\n                            })}\n                          </div>\n                        </div>\n                      )}\n                    </div>\n                  </div>\n                </section>\n              </div>\n            )}\n\n            {activeTab === 'general' && (\n              <div className=\"space-y-12 animate-in fade-in slide-in-from-bottom-2 duration-300 font-mono\">\n                <div className=\"grid grid-cols-1 gap-12\">\n                  {/* Agent Behavior Section */}\n                  <section className=\"space-y-3\">\n                    <div className=\"flex flex-col gap-0.5\">\n                      <div className=\"flex items-center gap-2 text-accent/80\">\n                        <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Behavior</h2>\n                      </div>\n                      <p className=\"text-[10px] text-text-tertiary/60 italic leading-normal font-black tracking-tight\">\n                        Global execution and memory policies.\n                      </p>\n                    </div>\n\n                    <div className=\"bg-surface/5 border border-border/10 p-4 space-y-3 font-mono\">\n                      <div className=\"flex items-center justify-between border-b border-border/5 pb-3\">\n                        <div className=\"flex flex-col gap-0.5\">\n                          <div className=\"flex items-center gap-2\">\n                            <span className=\"text-[11px] font-black text-text-primary uppercase tracking-[0.2em]\">Auto-compaction</span>\n                          </div>\n                          <p className=\"text-[10px] text-text-tertiary/60 italic px-3 leading-normal font-black tracking-tight\">\n                            Reduce token overhead automatically at threshold.\n                          </p>\n                        </div>\n                        <button\n                          onClick={handleToggleAutoCompaction}\n                          className={clsx(\n                            \"text-[10px] font-black px-2 py-1 transition-all tracking-widest uppercase active:scale-95\",\n                            config?.agent?.auto_compaction_enabled !== false\n                              ? \"text-status-success hover:bg-status-success/5\"\n                              : \"text-status-error hover:bg-status-error/5\"\n                          )}\n                        >\n                          {config?.agent?.auto_compaction_enabled !== false ? 'Active' : 'Inactive'}\n                        </button>\n                      </div>\n                    </div>\n                  </section>\n\n                  {/* Sub-Agent Ecosystem */}\n                  <section className=\"space-y-4\">\n                    <div className=\"flex flex-col gap-0.5\">\n                      <div className=\"flex items-center justify-between\">\n                        <div className=\"flex items-center gap-2 text-accent/80\">\n                          <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Sub-agents</h2>\n                        </div>\n                        <button\n                          onClick={handleToggleSubAgentsGlobal}\n                          className={clsx(\n                            \"text-[10px] font-black px-2 py-0.5 transition-all tracking-widest uppercase border active:scale-95 font-mono\",\n                            config?.sub_agent?.enabled\n                              ? \"text-status-success border-status-success/20 hover:bg-status-success/5\"\n                              : \"text-status-error border-status-error/20 hover:bg-status-error/5\"\n                          )}\n                        >\n                          {config?.sub_agent?.enabled ? 'Enabled' : 'Disabled'}\n                        </button>\n                      </div>\n                      <p className=\"text-[10px] text-text-tertiary/60 italic leading-normal font-black tracking-tight\">\n                        Autonomous child-agents for specialized task processing.\n                      </p>\n                    </div>\n\n                  </section>\n                </div>\n              </div>\n            )\n            }\n\n            {activeTab === 'security' && (\n              <div className=\"space-y-12 animate-in fade-in slide-in-from-bottom-2 duration-300 font-mono\">\n                {/* Unrestricted Execution Mode Toggle */}\n                <div className={clsx(\n                  \"p-4 border transition-all duration-500\",\n                  config?.security?.always_allow_all\n                    ? \"bg-status-error text-background border-status-error shadow-[0_0_25px_rgba(var(--status-error),0.2)]\"\n                    : \"bg-status-error/5 border-status-error/10\"\n                )}>\n                  <div className=\"flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4\">\n                    <div className=\"flex flex-col gap-1 pr-4\">\n                      <div className=\"flex items-center gap-2\">\n                        <span className={clsx(\n                          \"text-[11px] font-black uppercase tracking-[0.2em]\",\n                          config?.security?.always_allow_all ? \"text-background\" : \"text-status-error\"\n                        )}>Unrestricted Execution</span>\n                        {config?.security?.always_allow_all && (\n                          <span className=\"text-[8px] font-black bg-background text-status-error px-1 py-0.5 animate-pulse tracking-widest\">System unlocked</span>\n                        )}\n                      </div>\n                      <p className={clsx(\n                        \"text-[9px] italic leading-relaxed max-w-2xl font-black uppercase tracking-tight\",\n                        config?.security?.always_allow_all ? \"text-background/90\" : \"text-text-tertiary/60\"\n                      )}>\n                        Bypass all security checks. Agents gain full unmonitored system access. Use only in trusted environments.\n                      </p>\n                    </div>\n                    <button\n                      onClick={handleToggleAlwaysAllowAll}\n                      className={clsx(\n                        \"text-[9px] font-black px-3 py-1.5 transition-all tracking-[0.1em] uppercase border whitespace-nowrap active:scale-95\",\n                        config?.security?.always_allow_all\n                          ? \"bg-background text-status-error border-background\"\n                          : \"bg-status-error text-background border-status-error\"\n                      )}\n                    >\n                      {config?.security?.always_allow_all ? 'Restore Security' : 'Disable Security'}\n                    </button>\n                  </div>\n                </div>\n\n                {/* Shell Execution Policy */}\n                <section className={clsx(\n                  \"space-y-3 transition-all duration-300\",\n                  config?.security?.always_allow_all && \"opacity-40 grayscale\"\n                )}>\n                  <div className=\"flex flex-col gap-0.5\">\n                    <div className=\"flex items-center justify-between\">\n                      <div className=\"flex items-center gap-2 text-accent/80\">\n                        <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Shell Policy</h2>\n                      </div>\n                      {config?.security?.always_allow_all && (\n                        <span className=\"text-[8px] font-black text-status-error uppercase tracking-widest bg-status-error/10 px-1.5 py-0.5\">\n                          Overridden by unrestricted mode\n                        </span>\n                      )}\n                    </div>\n                    <p className=\"text-[10px] text-text-tertiary/60 italic leading-normal font-black tracking-tight\">\n                      Control auto-approval levels for terminal commands.\n                    </p>\n                  </div>\n\n                  <div className={clsx(\n                    \"bg-surface/5 border border-border/10 p-5 space-y-4\",\n                    config?.security?.always_allow_all && \"pointer-events-none\"\n                  )}>\n                    <div className=\"flex flex-col gap-0.5\">\n                      <span className=\"text-[11px] font-black text-text-primary uppercase tracking-[0.2em]\">Execution Mode</span>\n                    </div>\n\n                    <div className=\"grid grid-cols-2 sm:grid-cols-4 gap-2\">\n                      {[\n                        { id: 'restricted', label: 'RESTRICTED', desc: 'Minimal safe set' },\n                        { id: 'read-only', label: 'READ_ONLY', desc: 'All inspections' },\n                        { id: 'non-destructive', label: 'MUTABLE', desc: 'No deletions' },\n                        { id: 'unrestricted', label: 'OPEN', desc: 'No approvals' },\n                      ].map((mode) => (\n                        <button\n                          key={mode.id}\n                          onClick={() => handleUpdateShellPermissionMode(mode.id)}\n                          className={clsx(\n                            \"flex flex-col items-start p-3 border transition-all text-left group active:scale-[0.98]\",\n                            config?.security?.shell_permission_mode === mode.id\n                              ? \"border-accent bg-accent/5 shadow-[0_0_15px_rgba(var(--accent),0.05)]\"\n                              : \"border-border/10 hover:border-accent/40 bg-surface/5\"\n                          )}\n                        >\n                          <span className={clsx(\n                            \"text-[10px] font-black uppercase tracking-widest mb-1\",\n                            config?.security?.shell_permission_mode === mode.id ? \"text-accent\" : \"text-text-tertiary/60 group-hover:text-text-secondary\"\n                          )}>\n                            {config?.security?.shell_permission_mode === mode.id ? `[${mode.label}]` : `  ${mode.label}`}\n                          </span>\n                          <span className=\"text-[8px] text-text-tertiary/40 font-black uppercase leading-tight\">\n                            {mode.desc}\n                          </span>\n                        </button>\n                      ))}\n                    </div>\n                  </div>\n                </section>\n\n                {/* Vault Section */}\n                <section className=\"space-y-3\">\n                  <div className=\"flex flex-col gap-0.5\">\n                    <div className=\"flex items-center gap-2 text-accent/80\">\n                      <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Secure Vault</h2>\n                    </div>\n                    <p className=\"text-[10px] text-text-tertiary/60 italic leading-normal font-black tracking-tight\">\n                      Protected tokens and environment variables.\n                    </p>\n                  </div>\n\n                  <div className=\"bg-surface/5 border border-border/10 p-5 space-y-6\">\n                    <div className=\"space-y-4\">\n                      <div className=\"flex flex-col gap-0.5\">\n                        <span className=\"text-[11px] font-black text-text-primary uppercase tracking-[0.2em]\">Vault Index</span>\n                        <p className=\"text-[10px] text-text-tertiary/60 italic px-3 font-black tracking-tight\">\n                          Access in tools via <code className=\"text-accent underline\">{\"{{vault:KEY}}\"}</code>.\n                        </p>\n                      </div>\n\n                      <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-2\">\n                        {vaultSecrets && vaultSecrets.length > 0 ? (\n                          vaultSecrets.map((secret: any) => (\n                            <div\n                              key={secret.name}\n                              className=\"flex items-center justify-between px-3 py-1.5 bg-background/20 border border-border/5 group hover:border-accent/20 transition-all\"\n                            >\n                              <div className=\"flex items-center gap-2\">\n                                <span className=\"text-[8px] font-black text-accent/40 uppercase\">[KEY]</span>\n                                <span className=\"text-[11px] font-black text-text-primary/70 font-mono truncate max-w-[120px]\">\n                                  {secret.name}\n                                </span>\n                              </div>\n                              <button\n                                onClick={() => handleRemoveVaultSecret(secret.name)}\n                                className=\"text-text-tertiary/20 hover:text-status-error opacity-0 group-hover:opacity-100 transition-all text-[10px] font-black\"\n                              >\n                                [X]\n                              </button>\n                            </div>\n                          ))\n                        ) : (\n                          <div className=\"col-span-full py-6 border border-dashed border-border/10 flex flex-col items-center justify-center text-text-tertiary/20\">\n                            <span className=\"text-[9px] uppercase font-black tracking-[0.2em]\">No secrets stored</span>\n                          </div>\n                        )}\n                      </div>\n\n                      {/* Add Secret Form */}\n                      <div className=\"mt-4 p-4 border-t border-border/5 space-y-3\">\n                        <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-4\">\n                          <div className=\"space-y-1\">\n                            <label className=\"text-[9px] font-black text-text-tertiary/40 uppercase tracking-widest ml-1\">Key</label>\n                            <input\n                              type=\"text\"\n                              placeholder=\"GITHUB_TOKEN\"\n                              value={newVaultSecret.name}\n                              onChange={(e) => setNewVaultSecret(prev => ({ ...prev, name: e.target.value.toUpperCase().replace(/[^A-Z0-9_]/g, '_') }))}\n                              className=\"w-full bg-transparent border-b border-border/10 px-0 py-1 text-[11px] text-text-primary focus:outline-none focus:border-accent/40 font-mono transition-all uppercase\"\n                            />\n                          </div>\n                          <div className=\"space-y-1\">\n                            <label className=\"text-[9px] font-black text-text-tertiary/40 uppercase tracking-widest ml-1\">Value</label>\n                            <input\n                              type=\"password\"\n                              placeholder=\"Secret value\"\n                              value={newVaultSecret.value}\n                              onChange={(e) => setNewVaultSecret(prev => ({ ...prev, value: e.target.value }))}\n                              className=\"w-full bg-transparent border-b border-border/10 px-0 py-1 text-[11px] text-text-primary focus:outline-none focus:border-accent/40 font-mono transition-all\"\n                            />\n                          </div>\n                        </div>\n                        <button\n                          onClick={handleSetVaultSecret}\n                          disabled={isSaving || !newVaultSecret.name || !newVaultSecret.value}\n                          className=\"w-full py-1 text-accent hover:text-accent-hover font-black text-[10px] uppercase tracking-widest transition-all disabled:opacity-20 active:scale-[0.98]\"\n                        >\n                          Store in Vault\n                        </button>\n                      </div>\n                    </div>\n                  </div>\n                </section>\n              </div>\n            )\n            }\n\n            {activeTab === 'shortcuts' && (\n              <div className=\"space-y-8 animate-in fade-in slide-in-from-bottom-2 duration-300 font-mono\">\n                {/* All Hotkeys Section */}\n                <section className=\"space-y-3\">\n                  <div className=\"flex flex-col gap-0.5\">\n                    <div className=\"flex items-center gap-2 text-accent/80\">\n                      <h2 className=\"text-[12px] font-black uppercase tracking-[0.2em]\">Shortcuts</h2>\n                    </div>\n                  </div>\n\n                  <div className=\"bg-surface/5 border border-border/10 p-5\">\n                    <div className=\"grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-1\">\n                      {Object.entries(hotkeyLabels).map(([key, label]) => (\n                        <div key={key} className=\"flex items-center justify-between py-1.5 border-b border-border/5 last:border-0 md:[&:nth-last-child(-n+2)]:border-0\">\n                          <span className=\"text-[10px] font-black text-text-tertiary/60 uppercase tracking-widest\">{label}</span>\n                          <button\n                            onClick={() => setRecordingHotkey(key)}\n                            className={clsx(\n                              \"font-mono text-[10px] font-black transition-all min-w-[90px] text-right\",\n                              recordingHotkey === key\n                                ? \"text-accent animate-pulse\"\n                                : \"text-accent/60 hover:text-accent\"\n                            )}\n                          >\n                            {recordingHotkey === key ? 'Recording...' : ((config?.ui as any)?.hotkeys?.[key] || hotkeyDefaults[key] || 'N/A')}\n                          </button>\n                        </div>\n                      ))}\n                    </div>\n                        <div className=\"mt-6 pt-3 border-t border-border/5\">\n                      <p className=\"text-[9px] text-text-tertiary/20 tracking-tighter italic font-black\">\n                        Press Escape to cancel. System reserved keys may override.\n                      </p>\n                    </div>\n                  </div>\n                </section>\n              </div>\n            )\n            }\n          </div >\n        </div >\n      </div >\n    </div >\n  );\n};\n","numLines":1451,"startLine":1,"totalLines":1451}}}
{"parentUuid":"3a2ff478-14fb-49e3-bddf-4832315c2f68","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RFtTgxB8MnaNErQ9qzR54h","type":"tool_result","content":"     1package main\n     2\n     3import (\n     4\t\"context\"\n     5\t\"encoding/json\"\n     6\t\"fmt\"\n     7\t\"log/slog\"\n     8\t\"os\"\n     9\t\"os/exec\"\n    10\t\"path/filepath\"\n    11\t\"runtime\"\n    12\t\"strings\"\n    13\t\"time\"\n    14\n    15\t\"github.com/gin-gonic/gin\"\n    16\t\"github.com/google/uuid\"\n    17\t\"github.com/gorilla/websocket\"\n    18\t\"github.com/patrick/familiar/packages/go-backend/internal/agent\"\n    19\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n    20\t\"github.com/patrick/familiar/packages/go-backend/internal/scheduler\"\n    21\t\"github.com/patrick/familiar/packages/go-backend/internal/tools\"\n    22\t\"github.com/patrick/familiar/packages/go-backend/internal/utils\"\n    23\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n    24)\n    25\n    26func (s *Server) handleGlobalWebSocket(c *gin.Context) {\n    27\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n    28\tif err != nil {\n    29\t\tslog.Error(\"Failed to upgrade global websocket\", \"error\", err)\n    30\t\treturn\n    31\t}\n    32\tdefer conn.Close()\n    33\n    34\ts.mu.Lock()\n    35\ts.globalClients = append(s.globalClients, conn)\n    36\ts.mu.Unlock()\n    37\n    38\tdefer func() {\n    39\t\ts.mu.Lock()\n    40\t\tfor i, v := range s.globalClients {\n    41\t\t\tif v == conn {\n    42\t\t\t\ts.globalClients = append(s.globalClients[:i], s.globalClients[i+1:]...)\n    43\t\t\t\tbreak\n    44\t\t\t}\n    45\t\t}\n    46\t\tdelete(s.connLocks, conn)\n    47\t\ts.mu.Unlock()\n    48\t}()\n    49\n    50\tfor {\n    51\t\tvar req types.WebSocketRequest\n    52\t\terr := conn.ReadJSON(&req)\n    53\t\tif err != nil {\n    54\t\t\tbreak\n    55\t\t}\n    56\t\ts.handleWSRequest(conn, &req)\n    57\t}\n    58}\n    59\n    60func (s *Server) handleWSRequest(conn *websocket.Conn, req *types.WebSocketRequest) {\n    61\tslog.Debug(\"WS Request received\", \"type\", req.Type)\n    62\tresp := types.WebSocketResponse{\n    63\t\tType:      req.Type,\n    64\t\tRequestID: req.RequestID,\n    65\t\tStatus:    \"ok\",\n    66\t}\n    67\n    68\tswitch req.Type {\n    69\tcase \"submit_feedback_manual\":\n    70\t\tmessage, _ := req.Payload[\"message\"].(string)\n    71\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n    72\t\tif message == \"\" {\n    73\t\t\tresp.Status = \"error\"\n    74\t\t\tresp.Error = \"Message is required\"\n    75\t\t\ts.safeWriteJSON(conn, resp)\n    76\t\t\treturn\n    77\t\t}\n    78\n    79\t\ttool := tools.NewFeedbackTool()\n    80\t\tresult, err := tool.Execute(context.Background(), map[string]interface{}{\"message\": message}, nil)\n    81\t\tif err != nil {\n    82\t\t\tresp.Status = \"error\"\n    83\t\t\tresp.Error = err.Error()\n    84\t\t} else {\n    85\t\t\tresp.Payload = map[string]string{\"status\": \"submitted\", \"content\": result.Content}\n    86\t\t\tif agentID != \"\" {\n    87\t\t\t\ts.db.AppendAgentLog(agentID, \"model_responded\", map[string]interface{}{\n    88\t\t\t\t\t\"content\": \"Manual feedback submitted successfully. Thank you!\",\n    89\t\t\t\t})\n    90\t\t\t\ts.globalBroadcast(map[string]interface{}{\n    91\t\t\t\t\t\"type\":       \"execution_log\",\n    92\t\t\t\t\t\"agent_id\":   agentID,\n    93\t\t\t\t\t\"event_type\": \"model_responded\",\n    94\t\t\t\t\t\"payload\": map[string]interface{}{\n    95\t\t\t\t\t\t\"content\": \"Manual feedback submitted successfully. Thank you!\",\n    96\t\t\t\t\t},\n    97\t\t\t\t})\n    98\t\t\t}\n    99\t\t}\n   100\n   101\tcase \"restart_onboarding\":\n   102\t\terr := s.BootstrapOnboarding()\n   103\t\tif err != nil {\n   104\t\t\tresp.Status = \"error\"\n   105\t\t\tresp.Error = err.Error()\n   106\t\t} else {\n   107\t\t\tresp.Payload = map[string]string{\"status\": \"restarted\"}\n   108\t\t}\n   109\n   110\tcase \"resolve_missed_tasks\":\n   111\t\tresolutions, _ := req.Payload[\"resolutions\"].(map[string]interface{})\n   112\t\tfor taskID, res := range resolutions {\n   113\t\t\tif resStr, ok := res.(string); ok {\n   114\t\t\t\ts.scheduler.ResolveMissedTask(taskID, resStr)\n   115\t\t\t}\n   116\t\t}\n   117\t\ts.safeWriteJSON(conn, resp)\n   118\n   119\tcase \"create_agent\":\n   120\t\tmodelConfig, _ := req.Payload[\"model_config\"].(map[string]interface{})\n   121\t\tinitialPrompt, _ := req.Payload[\"initial_prompt\"].(string)\n   122\t\tplanEnabled, ok := req.Payload[\"plan_enabled\"].(bool)\n   123\t\tif !ok {\n   124\t\t\tplanEnabled = true // Default to enabled\n   125\t\t}\n   126\t\tinitialPrompt = strings.TrimSpace(initialPrompt)\n   127\t\tcfg, _ := config.LoadConfig()\n   128\n   129\t\t// Get provider and model, using validated defaults if not specified\n   130\t\tprovider, _ := modelConfig[\"provider\"].(string)\n   131\t\tmodel, _ := modelConfig[\"model\"].(string)\n   132\t\tif provider == \"\" || model == \"\" {\n   133\t\t\tdefaultProvider, defaultModel := s.getDefaultChatConfig(cfg)\n   134\t\t\tif provider == \"\" {\n   135\t\t\t\tprovider = defaultProvider\n   136\t\t\t}\n   137\t\t\tif model == \"\" {\n   138\t\t\t\tmodel = defaultModel\n   139\t\t\t}\n   140\t\t}\n   141\n   142\t\t// Provider and model will be validated during messaging or resumption.\n   143\t\t// If they remain empty, the agent will simply be created with empty model config.\n   144\n   145\t\tagentID := uuid.New().String()\n   146\t\tname := utils.GetRandomName()\n   147\n   148\t\t// Determine max context tokens\n   149\t\tcontextLimit := 128000\n   150\t\tif prov, err := s.createProvider(provider); err == nil {\n   151\t\t\tcontextLimit = prov.GetContextLimit(model)\n   152\t\t}\n   153\n   154\t\t// Set defaults from global config\n   155\t\tsubAgentsEnabled := true\n   156\t\tif cfg.SubAgent.Enabled != nil {\n   157\t\t\tsubAgentsEnabled = *cfg.SubAgent.Enabled\n   158\t\t}\n   159\n   160\t\tparentID, _ := req.Payload[\"parent_id\"].(string)\n   161\t\tvar parentIDPtr *string\n   162\t\tif parentID != \"\" {\n   163\t\t\tparentIDPtr = &parentID\n   164\t\t}\n   165\n   166\t\tisSkillCreator, _ := req.Payload[\"is_skill_creator\"].(bool)\n   167\t\tisTriggerArchitect, _ := req.Payload[\"is_trigger_architect\"].(bool)\n   168\t\tisFeedbackCollector, _ := req.Payload[\"is_feedback_collector\"].(bool)\n   169\t\tisInternal := false\n   170\t\tworkingDir := \"\"\n   171\t\tif isSkillCreator {\n   172\t\t\tisInternal = true\n   173\t\t\tname = \"Skill Architect\"\n   174\t\t\tif skillID, ok := req.Payload[\"skill_id\"].(string); ok && skillID != \"\" {\n   175\t\t\t\tname = \"Skill Architect: \" + skillID\n   176\t\t\t}\n   177\t\t\tworkingDir = filepath.Join(config.GetConfigDir(), \"skills\")\n   178\t\t\tplanEnabled = false // Skill Architect doesn't need a formal plan\n   179\t\t} else if isTriggerArchitect {\n   180\t\t\tisInternal = true\n   181\t\t\tname = \"Trigger Architect\"\n   182\t\t\tif triggerID, ok := req.Payload[\"trigger_id\"].(string); ok && triggerID != \"\" {\n   183\t\t\t\tname = \"Trigger Architect: \" + triggerID\n   184\t\t\t}\n   185\t\t\tworkingDir = filepath.Join(config.GetConfigDir(), \"triggers\")\n   186\t\t\tplanEnabled = false\n   187\t\t} else if isFeedbackCollector {\n   188\t\t\tisInternal = true\n   189\t\t\tname = \"Feedback Collector\"\n   190\t\t\tplanEnabled = false\n   191\t\t\tprovider = \"onboarding\"\n   192\t\t\tmodel = \"scripted\"\n   193\t\t}\n   194\n   195\t\ta := types.Agent{\n   196\t\t\tID:               agentID,\n   197\t\t\tParentID:         parentIDPtr,\n   198\t\t\tType:             types.AgentTypeStandard,\n   199\t\t\tName:             name,\n   200\t\t\tState:            types.AgentStateIdle,\n   201\t\t\tInitialPrompt:    initialPrompt,\n   202\t\t\tPlanEnabled:      planEnabled,\n   203\t\t\tSubAgentsEnabled: subAgentsEnabled,\n   204\t\t\tIsInternal:       isInternal,\n   205\t\t\tWorkingDirectory: workingDir,\n   206\t\t\tModelConfig: types.ModelConfig{\n   207\t\t\t\tProvider: provider,\n   208\t\t\t\tModel:    model,\n   209\t\t\t},\n   210\t\t\tMaxContextTokens: contextLimit,\n   211\t\t\tCreatedAt:        time.Now().UTC(),\n   212\t\t\tUpdatedAt:        time.Now().UTC(),\n   213\t\t}\n   214\n   215\t\tif err := s.db.CreateAgent(a); err != nil {\n   216\t\t\tresp.Status = \"error\"\n   217\t\t\tresp.Error = err.Error()\n   218\t\t} else {\n   219\t\t\t// Mark onboarding as completed if this is a real agent and provider exists\n   220\t\t\tif !isInternal && provider != \"onboarding\" {\n   221\t\t\t\ts.db.SetSetting(\"onboarding_completed\", \"true\")\n   222\t\t\t}\n   223\n   224\t\t\tresp.Payload = a\n   225\t\t\ts.globalBroadcast(map[string]interface{}{\n   226\t\t\t\t\"type\":  \"agent_created\",\n   227\t\t\t\t\"agent\": a,\n   228\t\t\t})\n   229\t\t\tif initialPrompt != \"\" {\n   230\t\t\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"user_interaction\", map[string]interface{}{\n   231\t\t\t\t\t\"content\": initialPrompt,\n   232\t\t\t\t})\n   233\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   234\t\t\t\t\t\"type\":       \"execution_log\",\n   235\t\t\t\t\t\"agent_id\":   agentID,\n   236\t\t\t\t\t\"event_type\": \"user_interaction\",\n   237\t\t\t\t\t\"payload\":    map[string]interface{}{\"id\": logID, \"content\": initialPrompt},\n   238\t\t\t\t})\n   239\t\t\t\tgo s.handleAgentScopeSetup(agentID)\n   240\t\t\t} else {\n   241\t\t\t\t// Add initial greeting\n   242\t\t\t\tgreeting := \"What can I help you accomplish today?\"\n   243\t\t\t\tif isSkillCreator {\n   244\t\t\t\t\tskillID, _ := req.Payload[\"skill_id\"].(string)\n   245\t\t\t\t\tif skillID != \"\" {\n   246\t\t\t\t\t\tgreeting = fmt.Sprintf(\"Hi there! I'm the Skill Architect. I see you want to improve the **%s** skill. I'm here to help you design, implement, and test new capabilities for your personal agent. How would you like to proceed?\\n\\n**Note**: Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them if needed.\", skillID)\n   247\t\t\t\t\t} else {\n   248\t\t\t\t\t\tgreeting = \"Hi there! I'm the Skill Architect. Familiar Skills are specialized tools and capabilities that you can create to extend my functionality. I'm here to help you design, implement, and test new skills for your personal agent. What would you like to accomplish today?\\n\\n**Note**: Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them if needed.\"\n   249\t\t\t\t\t}\n   250\t\t\t\t} else if isTriggerArchitect {\n   251\t\t\t\t\ttriggerID, _ := req.Payload[\"trigger_id\"].(string)\n   252\t\t\t\t\tif triggerID != \"\" {\n   253\t\t\t\t\t\tgreeting = fmt.Sprintf(\"Hi! I'm the Trigger Architect. I see you want to configure the **%s** trigger. I can help you set up a subscription with a prompt template or explain how it works. How would you like to proceed?\\n\\n**Note**: Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them if needed.\", triggerID)\n   254\t\t\t\t\t} else {\n   255\t\t\t\t\t\tgreeting = \"Hi! I'm the Trigger Architect. I help you connect your personal agent to the outside world through automations and system events. I can help you create scripts that monitor your clipboard, watch files, poll external APIs, or react to schedule-based events. What kind of trigger would you like to set up today?\\n\\n**Note**: Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them if needed.\"\n   256\t\t\t\t\t}\n   257\t\t\t\t} else if isFeedbackCollector {\n   258\t\t\t\t\tgreeting = \"Hi! I'm here to collect your feedback. Would you like my help in gathering details (which uses your AI credits), or would you prefer to just type it out manually?\\n\\n**Please type one of the following:**\\n- **\\\"Yes\\\"**: I'll switch to an AI provider to help you. (Credits will be used)\\n- **\\\"No\\\"**: You can type your feedback directly and I'll send it.\"\n   259\t\t\t\t}\n   260\t\t\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"model_responded\", map[string]interface{}{\n   261\t\t\t\t\t\"content\": greeting,\n   262\t\t\t\t})\n   263\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   264\t\t\t\t\t\"type\":       \"execution_log\",\n   265\t\t\t\t\t\"agent_id\":   agentID,\n   266\t\t\t\t\t\"event_type\": \"model_responded\",\n   267\t\t\t\t\t\"payload\":    map[string]interface{}{\"id\": logID, \"content\": greeting},\n   268\t\t\t\t})\n   269\t\t\t}\n   270\t\t}\n   271\n   272\tcase \"update_scope\":\n   273\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n   274\t\tcontent, _ := req.Payload[\"content\"].(string)\n   275\n   276\t\tvar fmOverride *types.ScopeFrontmatter\n   277\t\tif fmData, ok := req.Payload[\"frontmatter\"].(map[string]interface{}); ok {\n   278\t\t\tb, _ := json.Marshal(fmData)\n   279\t\t\tjson.Unmarshal(b, &fmOverride)\n   280\t\t}\n   281\n   282\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n   283\t\tif err != nil {\n   284\t\t\tresp.Status = \"error\"\n   285\t\t\tresp.Error = err.Error()\n   286\t\t} else {\n   287\t\t\tvar parentScope *types.ScopeDocument\n   288\t\t\tif sa.ParentID != nil {\n   289\t\t\t\tparentScope, _ = s.db.GetCurrentScope(*sa.ParentID)\n   290\t\t\t}\n   291\t\t\tdoc, err := sa.ParseScopeDocument(content, fmOverride, parentScope)\n   292\t\t\tif err != nil {\n   293\t\t\t\tresp.Status = \"error\"\n   294\t\t\t\tresp.Error = \"Invalid scope format: \" + err.Error()\n   295\t\t\t} else {\n   296\t\t\t\t// Maintain version if it was already set in the document or by the sa\n   297\t\t\t\tif sa.CurrentScope != nil && doc.Version <= sa.CurrentScope.Version {\n   298\t\t\t\t\tdoc.Version = sa.CurrentScope.Version + 1\n   299\t\t\t\t\tdoc.Frontmatter.Version = doc.Version\n   300\t\t\t\t}\n   301\n   302\t\t\t\tnow := time.Now().UTC()\n   303\t\t\t\tdoc.ApprovedAt = &now\n   304\n   305\t\t\t\tif err := s.db.CreateScopeDocument(*doc); err != nil {\n   306\t\t\t\t\tresp.Status = \"error\"\n   307\t\t\t\t\tresp.Error = \"Failed to save scope: \" + err.Error()\n   308\t\t\t\t} else {\n   309\t\t\t\t\tif err := s.db.ApproveScope(agentID, doc.ID); err != nil {\n   310\t\t\t\t\t\tslog.Error(\"Failed to mark scope as approved\", \"agent_id\", agentID, \"error\", err)\n   311\t\t\t\t\t}\n   312\n   313\t\t\t\t\tsa.SetScope(doc)\n   314\n   315\t\t\t\t\tresp.Payload = doc\n   316\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   317\t\t\t\t\t\t\"type\":     \"scope_updated\",\n   318\t\t\t\t\t\t\"agent_id\": agentID,\n   319\t\t\t\t\t\t\"scope\":    doc,\n   320\t\t\t\t\t})\n   321\n   322\t\t\t\t\tif updatedAgent, err := s.db.GetAgent(agentID); err == nil {\n   323\t\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   324\t\t\t\t\t\t\t\"type\":  \"agent_updated\",\n   325\t\t\t\t\t\t\t\"agent\": updatedAgent,\n   326\t\t\t\t\t\t})\n   327\t\t\t\t\t}\n   328\t\t\t\t}\n   329\t\t\t}\n   330\t\t}\n   331\n   332\tcase \"approve_scope\":\n   333\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n   334\t\tscopeID, _ := req.Payload[\"scope_id\"].(string)\n   335\n   336\t\t// Parse no_resume robustly\n   337\t\tnoResume := false\n   338\t\tif nr, ok := req.Payload[\"no_resume\"].(bool); ok {\n   339\t\t\tnoResume = nr\n   340\t\t}\n   341\n   342\t\tslog.Info(\"Approving scope\", \"agent_id\", agentID, \"scope_id\", scopeID, \"no_resume\", noResume)\n   343\t\terr := s.db.ApproveScope(agentID, scopeID)\n   344\t\tif err != nil {\n   345\t\t\tresp.Status = \"error\"\n   346\t\t\tresp.Error = err.Error()\n   347\t\t} else {\n   348\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateWaiting, nil)\n   349\n   350\t\t\t// Fetch updated agent\n   351\t\t\tupdatedAgent, err := s.db.GetAgent(agentID)\n   352\t\t\tif err != nil {\n   353\t\t\t\tslog.Error(\"Failed to fetch updated agent\", \"agent_id\", agentID, \"error\", err)\n   354\t\t\t\treturn\n   355\t\t\t}\n   356\n   357\t\t\tresp.Payload = map[string]string{\"status\": \"approved\", \"scope_id\": scopeID}\n   358\n   359\t\t\t// Broadcast updated agent and state change\n   360\t\t\ts.globalBroadcast(map[string]interface{}{\n   361\t\t\t\t\"type\":      \"agent_state_changed\",\n   362\t\t\t\t\"agent\":     updatedAgent,\n   363\t\t\t\t\"agent_id\":  agentID,\n   364\t\t\t\t\"new_state\": types.AgentStateWaiting,\n   365\t\t\t})\n   366\n   367\t\t\t// Broadcast scope_approved\n   368\t\t\ts.globalBroadcast(map[string]interface{}{\n   369\t\t\t\t\"type\":     \"scope_approved\",\n   370\t\t\t\t\"agent_id\": agentID,\n   371\t\t\t\t\"scope_id\": scopeID,\n   372\t\t\t})\n   373\n   374\t\t\t// Update the stateful agent's scope if it exists\n   375\t\t\tsa, errSa := s.getOrCreateStatefulAgent(agentID)\n   376\t\t\tif errSa == nil && sa != nil {\n   377\t\t\t\tscope, _ := s.db.GetCurrentScope(agentID)\n   378\t\t\t\tsa.SetScope(scope)\n   379\t\t\t\tsa.SetState(types.AgentStateWaiting)\n   380\t\t\t}\n   381\n   382\t\t\t// Automatically start running the task unless no_resume is requested\n   383\t\t\tif !noResume {\n   384\t\t\t\tslog.Info(\"Resuming agent after scope approval\", \"agent_id\", agentID)\n   385\t\t\t\ts.resumeAgent(agentID, \"\")\n   386\t\t\t} else {\n   387\t\t\t\tslog.Info(\"Skipping agent resume as requested\", \"agent_id\", agentID)\n   388\t\t\t}\n   389\t\t}\n   390\n   391\tcase \"reject_scope\":\n   392\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n   393\t\tscopeID, _ := req.Payload[\"scope_id\"].(string)\n   394\t\tfeedback, _ := req.Payload[\"feedback\"].(string)\n   395\n   396\t\tslog.Info(\"Scope rejected\", \"agent_id\", agentID, \"scope_id\", scopeID, \"feedback\", feedback)\n   397\n   398\t\terr := s.db.UpdateAgentState(agentID, types.AgentStateIdle, nil)\n   399\t\tif err != nil {\n   400\t\t\tresp.Status = \"error\"\n   401\t\t\tresp.Error = err.Error()\n   402\t\t} else {\n   403\t\t\ts.db.AppendAgentLog(agentID, \"scope_rejected\", map[string]string{\n   404\t\t\t\t\"scope_id\": scopeID,\n   405\t\t\t\t\"feedback\": feedback,\n   406\t\t\t})\n   407\n   408\t\t\tresp.Payload = map[string]string{\"status\": \"rejected\", \"agent_id\": agentID}\n   409\n   410\t\t\ts.globalBroadcast(map[string]interface{}{\n   411\t\t\t\t\"type\":     \"scope_rejected\",\n   412\t\t\t\t\"agent_id\": agentID,\n   413\t\t\t\t\"scope_id\": scopeID,\n   414\t\t\t\t\"feedback\": feedback,\n   415\t\t\t})\n   416\t\t}\n   417\n   418\tcase \"update_agent_state\":\n   419\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n   420\t\taction, _ := req.Payload[\"action\"].(string)\n   421\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n   422\t\tif err != nil {\n   423\t\t\tresp.Status = \"error\"\n   424\t\t\tresp.Error = err.Error()\n   425\t\t} else {\n   426\t\tswitch action {\n   427\t\tcase \"pause\":\n   428\t\t\tsa.Pause()\n   429\t\t\t// Broadcast state change immediately so UI updates even if agent is stuck\n   430\t\t\tupdatedAgent, _ := s.db.GetAgent(agentID)\n   431\t\t\tif updatedAgent != nil {\n   432\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   433\t\t\t\t\t\"type\":      \"agent_state_changed\",\n   434\t\t\t\t\t\"agent\":     updatedAgent,\n   435\t\t\t\t\t\"agent_id\":  agentID,\n   436\t\t\t\t\t\"new_state\": types.AgentStatePaused,\n   437\t\t\t\t})\n   438\t\t\t}\n   439\t\tcase \"pause_tree\":\n   440\t\t\ts.pauseAgentRecursive(agentID)\n   441\t\tcase \"resume\":\n   442\t\t\tif err := s.resumeAgent(agentID, \"\"); err != nil {\n   443\t\t\t\tresp.Status = \"error\"\n   444\t\t\t\tresp.Error = err.Error()\n   445\t\t\t}\n   446\t\tcase \"resume_tree\":\n   447\t\t\ts.resumeAgentRecursive(agentID)\n   448\t\t\tcase \"cancel\":\n   449\t\t\t\tsa.Cancel()\n   450\t\t\tcase \"repair\":\n   451\t\t\t\tslog.Info(\"Repairing agent history via forced compaction\", \"agent_id\", agentID)\n   452\n   453\t\t\t\thistory, _ := s.db.ListAgentLogs(agentID)\n   454\t\t\t\ta, _ := s.db.GetAgent(agentID)\n   455\t\t\t\tvar parentScope *types.ScopeDocument\n   456\t\t\t\tif a != nil && a.ParentID != nil {\n   457\t\t\t\t\tparentScope, _ = s.db.GetCurrentScope(*a.ParentID)\n   458\t\t\t\t}\n   459\n   460\t\t\t\tif !sa.CanCompact(history, parentScope) {\n   461\t\t\t\t\tslog.Info(\"Compaction skipped: not enough history to compact\", \"agent_id\", agentID)\n   462\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"skipped\", \"reason\": \"not_enough_history\"}\n   463\t\t\t\t\ts.safeWriteJSON(conn, resp)\n   464\t\t\t\t\treturn\n   465\t\t\t\t}\n   466\n   467\t\t\t\tif sa.IsRunning() {\n   468\t\t\t\t\t// Ensure the agent stops after its current turn if it's running.\n   469\t\t\t\t\tsa.Pause()\n   470\t\t\t\t\t// Set the flag so it compacts at the start of its next turn (or when resumed).\n   471\t\t\t\t\tsa.ForceCompaction(\"user_request\", \"\")\n   472\t\t\t\t\tslog.Info(\"Agent is running; set to pause and compact on next turn\", \"agent_id\", agentID)\n   473\t\t\t\t} else {\n   474\t\t\t\t\t// Log the request\n   475\t\t\t\t\tsa.OnLog(agentID, \"compaction_requested\", map[string]interface{}{\"requested_by\": \"user_request\"})\n   476\t\t\t\t\tif err := sa.PerformCompaction(context.Background(), history, parentScope, true, \"\"); err != nil {\n   477\t\t\t\t\t\tslog.Error(\"Failed manual compaction\", \"agent_id\", agentID, \"error\", err)\n   478\t\t\t\t\t\tresp.Status = \"error\"\n   479\t\t\t\t\t\tresp.Error = \"Compaction failed: \" + err.Error()\n   480\t\t\t\t\t}\n   481\t\t\t\t}\n   482\t\t\t}\n   483\t\t\tresp.Payload = map[string]string{\"status\": action, \"agent_id\": agentID}\n   484\t\t}\n   485\n   486\tcase \"update_agent_config\":\n   487\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n   488\t\tconfigData, _ := req.Payload[\"model_config\"].(map[string]interface{})\n   489\n   490\t\t// Load existing agent to merge config\n   491\t\texistingAgent, err := s.db.GetAgent(agentID)\n   492\t\tif err != nil {\n   493\t\t\tresp.Status = \"error\"\n   494\t\t\tresp.Error = \"Agent not found: \" + err.Error()\n   495\t\t\ts.safeWriteJSON(conn, resp)\n   496\t\t\treturn\n   497\t\t}\n   498\n   499\t\t// Handle plan_enabled if present\n   500\t\tif planEnabled, ok := req.Payload[\"plan_enabled\"].(bool); ok {\n   501\t\t\tif err := s.db.UpdateAgentPlanEnabled(agentID, planEnabled); err != nil {\n   502\t\t\t\tresp.Status = \"error\"\n   503\t\t\t\tresp.Error = \"Failed to update planning mode: \" + err.Error()\n   504\t\t\t\ts.safeWriteJSON(conn, resp)\n   505\t\t\t\treturn\n   506\t\t\t}\n   507\t\t}\n   508\n   509\t\t// Handle sub_agents_enabled if present\n   510\t\tif subAgentsEnabled, ok := req.Payload[\"sub_agents_enabled\"].(bool); ok {\n   511\t\t\tif err := s.db.UpdateAgentSubAgentsEnabled(agentID, subAgentsEnabled); err != nil {\n   512\t\t\t\tresp.Status = \"error\"\n   513\t\t\t\tresp.Error = \"Failed to update sub-agents mode: \" + err.Error()\n   514\t\t\t\ts.safeWriteJSON(conn, resp)\n   515\t\t\t\treturn\n   516\t\t\t}\n   517\t\t}\n   518\n   519\t\t// Merge model config\n   520\t\tmodelConfig := existingAgent.ModelConfig\n   521\t\t// Safely merge partial model config from frontend\n   522\t\tif configBytes, err := json.Marshal(configData); err == nil {\n   523\t\t\tif err := json.Unmarshal(configBytes, &modelConfig); err != nil {\n   524\t\t\t\tslog.Error(\"Failed to unmarshal partial model config\", \"error\", err)\n   525\t\t\t}\n   526\t\t}\n   527\n   528\t\tif err := s.db.UpdateAgentModelConfig(agentID, modelConfig); err != nil {\n   529\t\t\tresp.Status = \"error\"\n   530\t\t\tresp.Error = err.Error()\n   531\t\t} else {\n   532\t\t\t// Update in-memory stateful agent if it exists\n   533\t\t\t// This will also validate the provider if getOrCreateStatefulAgent is called\n   534\t\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n   535\t\t\tif err != nil {\n   536\t\t\t\t// Provider is likely disabled or invalid\n   537\t\t\t\tresp.Status = \"error\"\n   538\t\t\t\tresp.Error = err.Error()\n   539\t\t\t\ts.safeWriteJSON(conn, resp)\n   540\t\t\t\treturn\n   541\t\t\t}\n   542\t\t\tif sa != nil {\n   543\t\t\t\tnewProvider, err := s.createProvider(modelConfig.Provider)\n   544\t\t\t\tif err == nil {\n   545\t\t\t\t\tsa.UpdateModelConfig(modelConfig, newProvider)\n   546\t\t\t\t} else {\n   547\t\t\t\t\tslog.Error(\"Failed to create new provider during config update\", \"error\", err)\n   548\t\t\t\t\t// Fallback: update model only\n   549\t\t\t\t\tsa.UpdateModelConfig(modelConfig, nil)\n   550\t\t\t\t}\n   551\t\t\t\t// Update max_context_tokens in database when model changes\n   552\t\t\t\tmaxContextTokens := sa.MaxContextTokens\n   553\t\t\t\tagent, _ := s.db.GetAgent(agentID)\n   554\t\t\t\tif agent != nil {\n   555\t\t\t\t\ts.db.UpdateAgentContextUsage(agentID, agent.ContextTokens, maxContextTokens)\n   556\t\t\t\t}\n   557\t\t\t}\n   558\n   559\t\t\tresp.Payload = map[string]string{\"status\": \"updated\", \"agent_id\": agentID}\n   560\n   561\t\t\t// Broadcast updated agent\n   562\t\t\tupdatedAgent, err := s.db.GetAgent(agentID)\n   563\t\t\tif err == nil {\n   564\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   565\t\t\t\t\t\"type\":  \"agent_updated\",\n   566\t\t\t\t\t\"agent\": updatedAgent,\n   567\t\t\t\t})\n   568\t\t\t}\n   569\t\t}\n   570\n   571\tcase \"send_message\":\n   572\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n   573\t\tcontent, _ := req.Payload[\"content\"].(string)\n   574\t\tattachments, _ := req.Payload[\"attachments\"].([]interface{})\n   575\n   576\t\tslog.Info(\"Message sent to agent\", \"agent_id\", agentID, \"content\", content, \"attachments\", len(attachments))\n   577\n   578\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"user_interaction\", map[string]interface{}{\n   579\t\t\t\"content\":     content,\n   580\t\t\t\"attachments\": attachments,\n   581\t\t})\n   582\n   583\t\tresp.Payload = map[string]string{\"status\": \"received\", \"agent_id\": agentID}\n   584\n   585\t\ts.globalBroadcast(map[string]interface{}{\n   586\t\t\t\"type\":       \"execution_log\",\n   587\t\t\t\"agent_id\":   agentID,\n   588\t\t\t\"event_type\": \"user_interaction\",\n   589\t\t\t\"payload\":    map[string]interface{}{\"id\": logID, \"content\": content, \"attachments\": attachments},\n   590\t\t})\n   591\n   592\t\t// Enqueue message if agent is already running to avoid missing it in the current loop\n   593\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n   594\t\tif err != nil {\n   595\t\t\tslog.Error(\"Failed to get agent for message\", \"agent_id\", agentID, \"error\", err)\n   596\t\t\terrDetail := &types.ErrorDetail{\n   597\t\t\t\tCategory:    types.ErrorInitialization,\n   598\t\t\t\tMessage:     err.Error(),\n   599\t\t\t\tRecoverable: true,\n   600\t\t\t}\n   601\t\t\tpayload := map[string]interface{}{\n   602\t\t\t\t\"message\": err.Error(),\n   603\t\t\t}\n   604\t\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"agent_error\", payload)\n   605\t\t\tpayload[\"id\"] = logID\n   606\n   607\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateError, errDetail)\n   608\t\t\ts.globalBroadcast(map[string]interface{}{\n   609\t\t\t\t\"type\":         \"agent_state_changed\",\n   610\t\t\t\t\"agent_id\":     agentID,\n   611\t\t\t\t\"new_state\":    types.AgentStateError,\n   612\t\t\t\t\"error_detail\": errDetail,\n   613\t\t\t})\n   614\t\t\ts.globalBroadcast(map[string]interface{}{\n   615\t\t\t\t\"type\":       \"execution_log\",\n   616\t\t\t\t\"agent_id\":   agentID,\n   617\t\t\t\t\"event_type\": \"agent_error\",\n   618\t\t\t\t\"payload\":    payload,\n   619\t\t\t})\n   620\t\t\treturn\n   621\t\t}\n   622\t\tif sa != nil {\n   623\t\t\tvar parsedAttachments []types.Attachment\n   624\t\t\tfor _, att := range attachments {\n   625\t\t\t\tif a, ok := att.(map[string]interface{}); ok {\n   626\t\t\t\t\tid, _ := a[\"id\"].(string)\n   627\t\t\t\t\ttp, _ := a[\"type\"].(string)\n   628\t\t\t\t\tname, _ := a[\"name\"].(string)\n   629\t\t\t\t\tmime, _ := a[\"mimeType\"].(string)\n   630\t\t\t\t\tdata, _ := a[\"data\"].(string)\n   631\t\t\t\t\tsize, _ := a[\"size\"].(float64)\n   632\t\t\t\t\tpath, _ := a[\"path\"].(string)\n   633\t\t\t\t\tparsedAttachments = append(parsedAttachments, types.Attachment{\n   634\t\t\t\t\t\tID:       id,\n   635\t\t\t\t\t\tType:     tp,\n   636\t\t\t\t\t\tName:     name,\n   637\t\t\t\t\t\tMimeType: mime,\n   638\t\t\t\t\t\tData:     data,\n   639\t\t\t\t\t\tSize:     int64(size),\n   640\t\t\t\t\t\tPath:     path,\n   641\t\t\t\t\t})\n   642\t\t\t\t}\n   643\t\t\t}\n   644\t\t\tsa.EnqueueUserInteraction(content, parsedAttachments)\n   645\t\t}\n   646\n   647\t\t// If agent is idle, this is a planning interaction\n   648\t\ta, err := s.db.GetAgent(agentID)\n   649\t\tif err == nil {\n   650\t\t\tif a.State == types.AgentStateIdle {\n   651\t\t\t\t// Only sub-agents use the first message as a \"Mission\" (InitialPrompt)\n   652\t\t\t\t// Top-level agents are governed by their evolving Plan.\n   653\t\t\t\tif a.ParentID != nil && a.InitialPrompt == \"\" {\n   654\t\t\t\t\ts.db.UpdateAgentPrompt(agentID, content)\n   655\t\t\t\t}\n   656\t\t\t\tgo s.handleAgentScopeSetup(agentID)\n   657\t\t\t} else {\n   658\t\t\t\t// For any other state (completed, waiting, running, error), trigger the loop\n   659\t\t\t\tif err := s.resumeAgent(agentID, \"\"); err != nil {\n   660\t\t\t\t\tslog.Error(\"Failed to resume agent from send_message\", \"agent_id\", agentID, \"error\", err)\n   661\t\t\t\t}\n   662\t\t\t}\n   663\t\t}\n   664\n   665\tcase \"list_agents\":\n   666\t\tagents, err := s.db.ListAgents(nil, nil)\n   667\t\tif err != nil {\n   668\t\t\tresp.Status = \"error\"\n   669\t\t\tresp.Error = err.Error()\n   670\t\t} else {\n   671\t\t\tresp.Payload = agents\n   672\t\t}\n   673\n   674\tcase \"list_tasks\":\n   675\t\ttasks, err := s.getTasksWithNextRun()\n   676\t\tif err != nil {\n   677\t\t\tresp.Status = \"error\"\n   678\t\t\tresp.Error = err.Error()\n   679\t\t} else {\n   680\t\t\tresp.Payload = tasks\n   681\t\t}\n   682\n   683\tcase \"delete_task\":\n   684\t\ttaskID, _ := req.Payload[\"id\"].(string)\n   685\t\ts.scheduler.RemoveTask(taskID)\n   686\t\tif err := s.db.DeleteTask(taskID); err != nil {\n   687\t\t\tresp.Status = \"error\"\n   688\t\t\tresp.Error = err.Error()\n   689\t\t} else {\n   690\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"id\": taskID}\n   691\t\t\ttasks, _ := s.getTasksWithNextRun()\n   692\t\t\ts.globalBroadcast(map[string]interface{}{\n   693\t\t\t\t\"type\":  \"tasks_updated\",\n   694\t\t\t\t\"tasks\": tasks,\n   695\t\t\t})\n   696\t\t}\n   697\n   698\tcase \"get_agent\":\n   699\t\tid, _ := req.Payload[\"agent_id\"].(string)\n   700\t\ta, err := s.db.GetAgent(id)\n   701\t\tif err != nil {\n   702\t\t\tresp.Status = \"error\"\n   703\t\t\tresp.Error = err.Error()\n   704\t\t} else {\n   705\t\t\tresp.Payload = a\n   706\t\t}\n   707\n   708\tcase \"list_agent_logs\":\n   709\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n   710\t\tlogs, err := s.db.ListAgentLogs(agentID)\n   711\t\tif err != nil {\n   712\t\t\tresp.Status = \"error\"\n   713\t\t\tresp.Error = err.Error()\n   714\t\t} else {\n   715\t\t\tresp.Payload = logs\n   716\t\t}\n   717\n   718\tcase \"rename_agent\":\n   719\t\tid, _ := req.Payload[\"agent_id\"].(string)\n   720\t\tname, _ := req.Payload[\"name\"].(string)\n   721\t\tif err := s.db.UpdateAgentName(id, name); err != nil {\n   722\t\t\tresp.Status = \"error\"\n   723\t\t\tresp.Error = err.Error()\n   724\t\t} else {\n   725\t\t\tresp.Payload = map[string]string{\"status\": \"renamed\", \"agent_id\": id, \"name\": name}\n   726\t\t\ts.globalBroadcast(map[string]interface{}{\n   727\t\t\t\t\"type\":     \"agent_renamed\",\n   728\t\t\t\t\"agent_id\": id,\n   729\t\t\t\t\"name\":     name,\n   730\t\t\t})\n   731\t\t}\n   732\n   733\tcase \"delete_agent\":\n   734\t\tid, _ := req.Payload[\"agent_id\"].(string)\n   735\n   736\t\t// 1. Database cleanup (collects all child IDs within transaction to avoid race conditions)\n   737\t\tdeletedIDs, err := s.db.DeleteAgent(id)\n   738\t\tif err != nil {\n   739\t\t\tresp.Status = \"error\"\n   740\t\t\tresp.Error = err.Error()\n   741\t\t} else {\n   742\t\t\t// 2. Recursive memory/scheduler cleanup (using IDs from DB deletion)\n   743\t\t\tfor _, deletedID := range deletedIDs {\n   744\t\t\t\ts.cleanupAgentRecursive(deletedID)\n   745\t\t\t}\n   746\n   747\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"agent_id\": id}\n   748\n   749\t\t\t// Broadcast for each deleted agent (recursive)\n   750\t\t\tfor _, deletedID := range deletedIDs {\n   751\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   752\t\t\t\t\t\"type\":     \"agent_deleted\",\n   753\t\t\t\t\t\"agent_id\": deletedID,\n   754\t\t\t\t})\n   755\t\t\t}\n   756\t\t}\n   757\n   758\tcase \"toggle_skill\":\n   759\t\tname, _ := req.Payload[\"name\"].(string)\n   760\t\t// Placeholder for toggle logic\n   761\t\tresp.Payload = map[string]string{\"status\": \"toggled\", \"name\": name}\n   762\n   763\tcase \"get_config\":\n   764\t\tcfg, _ := config.LoadConfig()\n   765\t\tresp.Payload = s.formatConfigResponse(cfg)\n   766\n   767\tcase \"fetch_models\":\n   768\t\tproviderName, _ := req.Payload[\"provider\"].(string)\n   769\t\tif providerName == \"\" {\n   770\t\t\tresp.Status = \"error\"\n   771\t\t\tresp.Error = \"provider name required\"\n   772\t\t\ts.safeWriteJSON(conn, resp)\n   773\t\t\treturn\n   774\t\t}\n   775\n   776\t\tprov, err := s.createProvider(providerName)\n   777\t\tif err != nil {\n   778\t\t\tresp.Status = \"error\"\n   779\t\t\tresp.Error = err.Error()\n   780\t\t\ts.safeWriteJSON(conn, resp)\n   781\t\t\treturn\n   782\t\t}\n   783\n   784\t\tmodels, err := prov.ListModels(context.Background())\n   785\t\tif err != nil {\n   786\t\t\tresp.Status = \"error\"\n   787\t\t\tresp.Error = err.Error()\n   788\t\t} else {\n   789\t\t\tresp.Payload = map[string]interface{}{\n   790\t\t\t\t\"models\": models,\n   791\t\t\t}\n   792\t\t}\n   793\n   794\tcase \"update_config\":\n   795\t\tupdates, _ := req.Payload[\"updates\"].(map[string]interface{})\n   796\t\terr := s.performConfigUpdate(updates)\n   797\t\tif err != nil {\n   798\t\t\tresp.Status = \"error\"\n   799\t\t\tresp.Error = err.Error()\n   800\t\t} else {\n   801\t\t\tresp.Payload = map[string]string{\"status\": \"updated\"}\n   802\t\t}\n   803\n   804\tcase \"list_skills\":\n   805\t\tworkspacePath := getProgramDataPath()\n   806\t\tloader := utils.NewSkillLoader(workspacePath)\n   807\t\tskills, err := loader.LoadSkills()\n   808\t\tif err != nil {\n   809\t\t\tresp.Status = \"error\"\n   810\t\t\tresp.Error = err.Error()\n   811\t\t} else {\n   812\t\t\tresp.Payload = map[string]interface{}{\"skills\": skills, \"total\": len(skills)}\n   813\t\t}\n   814\n   815\tcase \"list_triggers\":\n   816\t\ttriggers := s.triggerManager.ListAvailableTriggers()\n   817\t\tresp.Payload = map[string]interface{}{\"triggers\": triggers}\n   818\n   819\tcase \"list_agent_subscriptions\":\n   820\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n   821\t\tsubs, err := s.db.ListTriggerSubscriptions(agentID)\n   822\t\tif err != nil {\n   823\t\t\tresp.Status = \"error\"\n   824\t\t\tresp.Error = err.Error()\n   825\t\t} else {\n   826\t\t\tresp.Payload = map[string]interface{}{\"subscriptions\": subs}\n   827\t\t}\n   828\n   829\tcase \"save_trigger_subscription\":\n   830\t\tvar sub types.TriggerSubscription\n   831\t\tb, _ := json.Marshal(req.Payload[\"subscription\"])\n   832\t\tjson.Unmarshal(b, &sub)\n   833\t\tif err := s.db.SaveTriggerSubscription(sub); err != nil {\n   834\t\t\tresp.Status = \"error\"\n   835\t\t\tresp.Error = err.Error()\n   836\t\t} else {\n   837\t\t\tresp.Payload = map[string]string{\"status\": \"saved\", \"id\": sub.ID}\n   838\t\t}\n   839\n   840\tcase \"delete_trigger_subscription\":\n   841\t\tid, _ := req.Payload[\"id\"].(string)\n   842\t\tif err := s.db.DeleteTriggerSubscription(id); err != nil {\n   843\t\t\tresp.Status = \"error\"\n   844\t\t\tresp.Error = err.Error()\n   845\t\t} else {\n   846\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\"}\n   847\t\t}\n   848\n   849\tcase \"delete_trigger\":\n   850\t\tid, _ := req.Payload[\"id\"].(string)\n   851\t\ts.triggerManager.Unregister(id)\n   852\t\t// Also delete from disk if it's a script trigger\n   853\t\ttriggerDir := filepath.Join(config.GetConfigDir(), \"triggers\", id)\n   854\t\tif _, err := os.Stat(triggerDir); err == nil {\n   855\t\t\tos.RemoveAll(triggerDir)\n   856\t\t}\n   857\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"id\": id}\n   858\n   859\tcase \"rename_trigger\":\n   860\t\tid, _ := req.Payload[\"id\"].(string)\n   861\t\tnewName, _ := req.Payload[\"new_name\"].(string)\n   862\t\t// This is tricky because we'd need to reload the trigger.\n   863\t\t// For now, let's just rename on disk if it exists.\n   864\t\toldDir := filepath.Join(config.GetConfigDir(), \"triggers\", id)\n   865\t\tnewDir := filepath.Join(config.GetConfigDir(), \"triggers\", newName)\n   866\t\tif _, err := os.Stat(oldDir); err == nil {\n   867\t\t\tos.Rename(oldDir, newDir)\n   868\t\t\t// TODO: Reload trigger manager\n   869\t\t}\n   870\t\tresp.Payload = map[string]string{\"status\": \"renamed\", \"id\": id, \"new_name\": newName}\n   871\n   872\tcase \"delete_skill\":\n   873\t\tname, _ := req.Payload[\"name\"].(string)\n   874\t\tworkspacePath := getProgramDataPath()\n   875\t\tskillDir := filepath.Join(workspacePath, \"skills\", name)\n   876\t\tif _, err := os.Stat(skillDir); err == nil {\n   877\t\t\tos.RemoveAll(skillDir)\n   878\t\t} else {\n   879\t\t\t// Try single file if directory doesn't exist\n   880\t\t\tskillFile := filepath.Join(workspacePath, \"skills\", name+\".md\")\n   881\t\t\tos.Remove(skillFile)\n   882\t\t}\n   883\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"name\": name}\n   884\n   885\tcase \"rename_skill\":\n   886\t\tname, _ := req.Payload[\"name\"].(string)\n   887\t\tnewName, _ := req.Payload[\"new_name\"].(string)\n   888\t\tworkspacePath := getProgramDataPath()\n   889\t\toldDir := filepath.Join(workspacePath, \"skills\", name)\n   890\t\tnewDir := filepath.Join(workspacePath, \"skills\", newName)\n   891\t\tif _, err := os.Stat(oldDir); err == nil {\n   892\t\t\tos.Rename(oldDir, newDir)\n   893\t\t}\n   894\t\tresp.Payload = map[string]string{\"status\": \"renamed\", \"name\": name, \"new_name\": newName}\n   895\n   896\tcase \"restore_default_skills\":\n   897\t\tbackupPath, err := config.RestoreDefaultSkills()\n   898\t\tif err != nil {\n   899\t\t\tresp.Status = \"error\"\n   900\t\t\tresp.Error = err.Error()\n   901\t\t} else {\n   902\t\t\tpayload := map[string]string{\"status\": \"restored\"}\n   903\t\t\tif backupPath != \"\" {\n   904\t\t\t\tpayload[\"backup_path\"] = backupPath\n   905\t\t\t}\n   906\t\t\tresp.Payload = payload\n   907\t\t}\n   908\n   909\tcase \"restore_default_triggers\":\n   910\t\tbackupPath, err := config.RestoreDefaultTriggers()\n   911\t\tif err != nil {\n   912\t\t\tresp.Status = \"error\"\n   913\t\t\tresp.Error = err.Error()\n   914\t\t} else {\n   915\t\t\tcronEnabled, cronErr := config.IsCronTriggerEnabled()\n   916\t\t\tif cronErr != nil {\n   917\t\t\t\tslog.Warn(\"Failed to read cron trigger config after restore\", \"error\", cronErr)\n   918\t\t\t}\n   919\t\t\ts.triggerManager.Clear()\n   920\t\t\tif cronEnabled {\n   921\t\t\t\ts.scheduler = scheduler.NewScheduler(s.db, func(agentID string, prompt string) error {\n   922\t\t\t\t\treturn s.resumeAgent(agentID, prompt)\n   923\t\t\t\t})\n   924\t\t\t\ts.scheduler.OnEvent = func(event map[string]interface{}) {\n   925\t\t\t\t\ts.globalBroadcast(event)\n   926\t\t\t\t}\n   927\t\t\t\ts.triggerManager.Register(s.scheduler)\n   928\t\t\t} else if s.scheduler != nil {\n   929\t\t\t\ts.scheduler.Stop()\n   930\t\t\t\ts.scheduler = nil\n   931\t\t\t}\n   932\n   933\t\t\ttriggerDir := filepath.Join(config.GetConfigDir(), \"triggers\")\n   934\t\t\tloader := agent.NewTriggerLoader(triggerDir)\n   935\t\t\tscripts, loadErr := loader.Load()\n   936\t\t\tif loadErr != nil {\n   937\t\t\t\tslog.Warn(\"Failed to reload triggers after restore\", \"error\", loadErr)\n   938\t\t\t} else {\n   939\t\t\t\tfor _, st := range scripts {\n   940\t\t\t\t\ts.triggerManager.Register(st)\n   941\t\t\t\t}\n   942\t\t\t}\n   943\t\t\ts.triggerManager.Start(context.Background())\n   944\t\t\tif s.scheduler != nil {\n   945\t\t\t\ts.scheduler.Start(context.Background(), func(payload types.TriggerPayload) {\n   946\t\t\t\t\ts.triggerManager.Emit(payload)\n   947\t\t\t\t})\n   948\t\t\t\tif err := s.scheduler.LoadTasks(); err != nil {\n   949\t\t\t\t\tslog.Warn(\"Failed to reload tasks after trigger restore\", \"error\", err)\n   950\t\t\t\t}\n   951\t\t\t}\n   952\t\t\tpayload := map[string]string{\"status\": \"restored\"}\n   953\t\t\tif backupPath != \"\" {\n   954\t\t\t\tpayload[\"backup_path\"] = backupPath\n   955\t\t\t}\n   956\t\t\tresp.Payload = payload\n   957\t\t}\n   958\n   959\tcase \"list_tools\":\n   960\t\tresp.Payload = map[string]interface{}{\"tools\": s.toolRegistry.ListTools()}\n   961\n   962\tcase \"sync_skills\":\n   963\t\tworkspacePath := getProgramDataPath()\n   964\t\tloader := utils.NewSkillLoader(workspacePath)\n   965\t\tskills, err := loader.LoadSkills()\n   966\t\tif err != nil {\n   967\t\t\tresp.Status = \"error\"\n   968\t\t\tresp.Error = err.Error()\n   969\t\t} else {\n   970\t\t\tresp.Payload = map[string]interface{}{\"synced\": len(skills), \"results\": map[string]bool{\"all\": true}}\n   971\t\t}\n   972\n   973\tcase \"get_usage\":\n   974\t\tdays := 30\n   975\t\tif d, ok := req.Payload[\"days\"].(float64); ok {\n   976\t\t\tdays = int(d)\n   977\t\t}\n   978\t\tend := time.Now().UTC()\n   979\t\tstart := end.AddDate(0, 0, -days)\n   980\t\ttotals, _ := s.db.GetUsageTotals(start, end)\n   981\t\tbyModel, _ := s.db.GetUsageSummary(start, end)\n   982\t\tbyAgent, _ := s.db.GetUsageByAgentSummary(start, end)\n   983\t\tbyTool, _ := s.db.GetUsageByToolSummary(start, end)\n   984\t\tbySkill, _ := s.db.GetUsageBySkillSummary(start, end)\n   985\t\tdaily, _ := s.db.GetDailyUsage(days)\n   986\t\tresp.Payload = map[string]interface{}{\n   987\t\t\t\"totals\":   totals,\n   988\t\t\t\"by_model\": byModel,\n   989\t\t\t\"by_agent\": byAgent,\n   990\t\t\t\"by_tool\":  byTool,\n   991\t\t\t\"by_skill\": bySkill,\n   992\t\t\t\"daily\":    daily,\n   993\t\t}\n   994\n   995\tcase \"get_usage_history\":\n   996\t\tlimit := 50\n   997\t\toffset := 0\n   998\t\tif l, ok := req.Payload[\"limit\"].(float64); ok {\n   999\t\t\tlimit = int(l)\n  1000\t\t}\n  1001\t\tif o, ok := req.Payload[\"offset\"].(float64); ok {\n  1002\t\t\toffset = int(o)\n  1003\t\t}\n  1004\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n  1005\t\tprovider, _ := req.Payload[\"provider\"].(string)\n  1006\t\tmodel, _ := req.Payload[\"model\"].(string)\n  1007\n  1008\t\trecords, err := s.db.GetUsageHistory(limit, offset, agentID, provider, model)\n  1009\t\tif err != nil {\n  1010\t\t\tresp.Status = \"error\"\n  1011\t\t\tresp.Error = err.Error()\n  1012\t\t} else {\n  1013\t\t\tresp.Payload = map[string]interface{}{\n  1014\t\t\t\t\"records\": records,\n  1015\t\t\t\t\"limit\":   limit,\n  1016\t\t\t\t\"offset\":  offset,\n  1017\t\t\t}\n  1018\t\t}\n  1019\n  1020\tcase \"get_api_keys\":\n  1021\t\tcfg, _ := config.LoadConfig()\n  1022\t\tproviders := []string{\"openrouter\", \"anthropic\", \"openai\", \"gemini\", \"ollama\", \"lmstudio\"}\n  1023\t\tif cfg != nil && cfg.CustomProviders != nil {\n  1024\t\t\tfor name := range cfg.CustomProviders {\n  1025\t\t\t\tproviders = append(providers, name)\n  1026\t\t\t}\n  1027\t\t}\n  1028\t\tresults := make([]map[string]interface{}, 0)\n  1029\t\tfor _, p := range providers {\n  1030\t\t\tvar configured bool\n  1031\t\t\tif config.MockMode {\n  1032\t\t\t\t// In mock mode, never access keychain or env vars - always return false\n  1033\t\t\t\tconfigured = false\n  1034\t\t\t} else {\n  1035\t\t\t\tswitch p {\n  1036\t\t\t\tcase \"ollama\":\n  1037\t\t\t\t\tconfigured = true // Local provider typically does not require a key\n  1038\t\t\t\tcase \"lmstudio\":\n  1039\t\t\t\t\tconfigured = true // Local provider typically does not require a key\n  1040\t\t\t\tdefault:\n  1041\t\t\t\t\tconfigured = config.GetKeychainPassword(p+\"-api-key\") != \"\"\n  1042\t\t\t\t\tif !configured && cfg != nil && cfg.CustomProviders != nil {\n  1043\t\t\t\t\t\tif cp, ok := cfg.CustomProviders[p]; ok {\n  1044\t\t\t\t\t\t\tconfigured = cp.BaseURL != \"\"\n  1045\t\t\t\t\t\t}\n  1046\t\t\t\t\t}\n  1047\t\t\t\t}\n  1048\t\t\t}\n  1049\n  1050\t\t\tenabled := false\n  1051\t\t\tif cfg != nil && cfg.Providers != nil {\n  1052\t\t\t\tif pc, ok := cfg.Providers[p]; ok && pc.Enabled != nil {\n  1053\t\t\t\t\tenabled = *pc.Enabled\n  1054\t\t\t\t}\n  1055\t\t\t}\n  1056\n  1057\t\t\tresults = append(results, map[string]interface{}{\n  1058\t\t\t\t\"provider\":   p,\n  1059\t\t\t\t\"configured\": configured,\n  1060\t\t\t\t\"enabled\":    enabled,\n  1061\t\t\t})\n  1062\t\t}\n  1063\t\tresp.Payload = results\n  1064\n  1065\tcase \"set_api_key\":\n  1066\t\tprovider, _ := req.Payload[\"provider\"].(string)\n  1067\t\tkey, _ := req.Payload[\"key\"].(string)\n  1068\t\tif config.MockMode {\n  1069\t\t\t// In mock mode, don't actually store API keys - just return success\n  1070\t\t\tslog.Debug(\"Mock mode: skipping API key storage\", \"provider\", provider)\n  1071\t\t\tresp.Payload = map[string]string{\"status\": \"stored\", \"provider\": provider}\n  1072\t\t} else {\n  1073\t\t\terr := config.SetKeychainPassword(provider+\"-api-key\", key)\n  1074\t\t\tif err != nil {\n  1075\t\t\t\tresp.Status = \"error\"\n  1076\t\t\t\tresp.Error = err.Error()\n  1077\t\t\t} else {\n  1078\t\t\t\tresp.Payload = map[string]string{\"status\": \"stored\", \"provider\": provider}\n  1079\t\t\t}\n  1080\t\t}\n  1081\n  1082\tcase \"remove_api_key\":\n  1083\t\tprovider, _ := req.Payload[\"provider\"].(string)\n  1084\t\tif config.MockMode {\n  1085\t\t\t// In mock mode, don't actually delete API keys - just return success\n  1086\t\t\tslog.Debug(\"Mock mode: skipping API key deletion\", \"provider\", provider)\n  1087\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"provider\": provider}\n  1088\t\t} else {\n  1089\t\t\terr := config.DeleteKeychainPassword(provider + \"-api-key\")\n  1090\t\t\tif err != nil {\n  1091\t\t\t\tresp.Status = \"error\"\n  1092\t\t\t\tresp.Error = err.Error()\n  1093\t\t\t} else {\n  1094\t\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"provider\": provider}\n  1095\t\t\t}\n  1096\t\t}\n  1097\n  1098\tcase \"approve_tool\":\n  1099\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n  1100\t\ttoolCallID, _ := req.Payload[\"tool_call_id\"].(string)\n  1101\t\tdecision, _ := req.Payload[\"decision\"].(string) // \"allow\", \"reject\", \"always_allow\"\n  1102\t\ttoolName, _ := req.Payload[\"tool_name\"].(string)\n  1103\t\tpattern, _ := req.Payload[\"pattern\"].(string) // Only for \"always_allow\"\n  1104\n  1105\t\tif decision == \"always_allow\" && pattern != \"\" && toolName != \"\" {\n  1106\t\t\ts.db.SaveToolApproval(toolName, pattern)\n  1107\t\t}\n  1108\n  1109\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n  1110\t\tif err != nil {\n  1111\t\t\tresp.Status = \"error\"\n  1112\t\t\tresp.Error = err.Error()\n  1113\t\t\ts.safeWriteJSON(conn, resp)\n  1114\t\t\treturn\n  1115\t\t}\n  1116\n  1117\t\tif sa != nil {\n  1118\t\t\tsa.ApproveTool(toolCallID, decision)\n  1119\t\t\tresp.Payload = map[string]string{\"status\": \"processed\"}\n  1120\n  1121\t\t\t// If the agent is not running, we need to resume it so it can process the approval\n  1122\t\t\t// (or at least start a new turn if the old loop was lost due to restart)\n  1123\t\t\tif !sa.IsRunning() {\n  1124\t\t\t\tslog.Info(\"Resuming agent after tool approval (agent was not running)\", \"agent_id\", agentID)\n  1125\t\t\t\ts.resumeAgent(agentID, \"\")\n  1126\t\t\t}\n  1127\n  1128\t\t\t// Log the resolution so the frontend can display the result in the history\n  1129\t\t\tpayload := map[string]interface{}{\n  1130\t\t\t\t\"tool_call_id\": toolCallID,\n  1131\t\t\t\t\"tool\":         toolName,\n  1132\t\t\t\t\"decision\":     decision,\n  1133\t\t\t}\n  1134\t\t\ts.db.AppendAgentLog(agentID, \"tool_approval_resolved\", payload)\n  1135\n  1136\t\t\ts.globalBroadcast(map[string]interface{}{\n  1137\t\t\t\t\"type\":       \"execution_log\",\n  1138\t\t\t\t\"agent_id\":   agentID,\n  1139\t\t\t\t\"event_type\": \"tool_approval_resolved\",\n  1140\t\t\t\t\"payload\":    payload,\n  1141\t\t\t})\n  1142\t\t} else {\n  1143\t\t\tresp.Status = \"error\"\n  1144\t\t\tresp.Error = \"Agent not found\"\n  1145\t\t}\n  1146\n  1147\tcase \"list_tool_approvals\":\n  1148\t\tapprovals, err := s.db.ListToolApprovals()\n  1149\t\tif err != nil {\n  1150\t\t\tresp.Status = \"error\"\n  1151\t\t\tresp.Error = err.Error()\n  1152\t\t} else {\n  1153\t\t\tresp.Payload = approvals\n  1154\t\t}\n  1155\n  1156\tcase \"delete_tool_approval\":\n  1157\t\tid, _ := req.Payload[\"id\"].(string)\n  1158\t\tif err := s.db.DeleteToolApproval(id); err != nil {\n  1159\t\t\tresp.Status = \"error\"\n  1160\t\t\tresp.Error = err.Error()\n  1161\t\t} else {\n  1162\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\"}\n  1163\t\t}\n  1164\n  1165\tcase \"list_vault_secrets\":\n  1166\t\tsecrets, err := s.db.ListVaultSecrets()\n  1167\t\tif err != nil {\n  1168\t\t\tresp.Status = \"error\"\n  1169\t\t\tresp.Error = err.Error()\n  1170\t\t} else {\n  1171\t\t\tresp.Payload = secrets\n  1172\t\t}\n  1173\n  1174\tcase \"set_vault_secret\":\n  1175\t\tname, _ := req.Payload[\"name\"].(string)\n  1176\t\tvalue, _ := req.Payload[\"value\"].(string)\n  1177\t\tif name == \"\" || value == \"\" {\n  1178\t\t\tresp.Status = \"error\"\n  1179\t\t\tresp.Error = \"name and value are required\"\n  1180\t\t} else {\n  1181\t\t\tif config.MockMode {\n  1182\t\t\t\tslog.Debug(\"Mock mode: storing secret in memory\", \"name\", name)\n  1183\t\t\t\tconfig.SetMockVaultSecret(name, value)\n  1184\t\t\t\terr := s.db.SaveVaultSecretName(name)\n  1185\t\t\t\tif err != nil {\n  1186\t\t\t\t\tresp.Status = \"error\"\n  1187\t\t\t\t\tresp.Error = err.Error()\n  1188\t\t\t\t} else {\n  1189\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"stored\", \"name\": name}\n  1190\t\t\t\t}\n  1191\t\t\t} else {\n  1192\t\t\t\terr := config.SetKeychainPassword(\"vault-secret-\"+name, value)\n  1193\t\t\t\tif err != nil {\n  1194\t\t\t\t\tresp.Status = \"error\"\n  1195\t\t\t\t\tresp.Error = err.Error()\n  1196\t\t\t\t} else {\n  1197\t\t\t\t\terr = s.db.SaveVaultSecretName(name)\n  1198\t\t\t\t\tif err != nil {\n  1199\t\t\t\t\t\tresp.Status = \"error\"\n  1200\t\t\t\t\t\tresp.Error = err.Error()\n  1201\t\t\t\t\t} else {\n  1202\t\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"stored\", \"name\": name}\n  1203\t\t\t\t\t}\n  1204\t\t\t\t}\n  1205\t\t\t}\n  1206\n  1207\t\t\t// Notify any agents waiting for this secret\n  1208\t\t\ts.mu.Lock()\n  1209\t\t\tfor _, sa := range s.statefulAgents {\n  1210\t\t\t\tsa.SubmitSecret(name)\n  1211\t\t\t}\n  1212\t\t\ts.mu.Unlock()\n  1213\t\t}\n  1214\n  1215\tcase \"remove_vault_secret\":\n  1216\t\tname, _ := req.Payload[\"name\"].(string)\n  1217\t\tif name == \"\" {\n  1218\t\t\tresp.Status = \"error\"\n  1219\t\t\tresp.Error = \"name is required\"\n  1220\t\t} else {\n  1221\t\t\tif config.MockMode {\n  1222\t\t\t\tslog.Debug(\"Mock mode: skipping vault secret deletion\", \"name\", name)\n  1223\t\t\t\terr := s.db.DeleteVaultSecretName(name)\n  1224\t\t\t\tif err != nil {\n  1225\t\t\t\t\tresp.Status = \"error\"\n  1226\t\t\t\t\tresp.Error = err.Error()\n  1227\t\t\t\t} else {\n  1228\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"name\": name}\n  1229\t\t\t\t}\n  1230\t\t\t} else {\n  1231\t\t\t\terr := config.DeleteKeychainPassword(\"vault-secret-\" + name)\n  1232\t\t\t\tif err != nil {\n  1233\t\t\t\t\tresp.Status = \"error\"\n  1234\t\t\t\t\tresp.Error = err.Error()\n  1235\t\t\t\t} else {\n  1236\t\t\t\t\terr = s.db.DeleteVaultSecretName(name)\n  1237\t\t\t\t\tif err != nil {\n  1238\t\t\t\t\t\tresp.Status = \"error\"\n  1239\t\t\t\t\t\tresp.Error = err.Error()\n  1240\t\t\t\t\t} else {\n  1241\t\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"name\": name}\n  1242\t\t\t\t\t}\n  1243\t\t\t\t}\n  1244\t\t\t}\n  1245\t\t}\n  1246\n  1247\tcase \"get_version\":\n  1248\t\tresp.Payload = map[string]string{\"version\": \"0.1.0\"}\n  1249\n  1250\tcase \"list_workspace\":\n  1251\t\tresp.Payload = map[string]string{\"path\": getProgramDataPath()}\n  1252\n  1253\tcase \"open_workspace\":\n  1254\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n  1255\t\tpath := s.getAgentWorkspacePath(agentID)\n  1256\t\t// Ensure it exists\n  1257\t\tos.MkdirAll(path, 0755)\n  1258\n  1259\t\tvar err error\n  1260\t\tif runtime.GOOS == \"darwin\" {\n  1261\t\t\terr = exec.Command(\"open\", path).Run()\n  1262\t\t} else if runtime.GOOS == \"windows\" {\n  1263\t\t\terr = exec.Command(\"explorer\", path).Run()\n  1264\t\t} else {\n  1265\t\t\terr = exec.Command(\"xdg-open\", path).Run()\n  1266\t\t}\n  1267\n  1268\t\tif err != nil {\n  1269\t\t\tresp.Status = \"error\"\n  1270\t\t\tresp.Error = err.Error()\n  1271\t\t} else {\n  1272\t\t\tresp.Payload = map[string]string{\"status\": \"opened\", \"path\": path}\n  1273\t\t}\n  1274\n  1275\tcase \"open_folder\":\n  1276\t\tname, _ := req.Payload[\"name\"].(string)\n  1277\t\tif name == \"\" {\n  1278\t\t\tresp.Status = \"error\"\n  1279\t\t\tresp.Error = \"folder name is required\"\n  1280\t\t\tbreak\n  1281\t\t}\n  1282\n  1283\t\tpath := filepath.Join(config.GetConfigDir(), name)\n  1284\t\t// Ensure it exists\n  1285\t\tos.MkdirAll(path, 0755)\n  1286\n  1287\t\tvar err error\n  1288\t\tif runtime.GOOS == \"darwin\" {\n  1289\t\t\terr = exec.Command(\"open\", path).Run()\n  1290\t\t} else if runtime.GOOS == \"windows\" {\n  1291\t\t\terr = exec.Command(\"explorer\", path).Run()\n  1292\t\t} else {\n  1293\t\t\terr = exec.Command(\"xdg-open\", path).Run()\n  1294\t\t}\n  1295\n  1296\t\tif err != nil {\n  1297\t\t\tresp.Status = \"error\"\n  1298\t\t\tresp.Error = err.Error()\n  1299\t\t} else {\n  1300\t\t\tresp.Payload = map[string]string{\"status\": \"opened\", \"path\": path}\n  1301\t\t}\n  1302\n  1303\tcase \"open_path\":\n  1304\t\tpath, _ := req.Payload[\"path\"].(string)\n  1305\t\tif path == \"\" {\n  1306\t\t\tresp.Status = \"error\"\n  1307\t\t\tresp.Error = \"path is required\"\n  1308\t\t\tbreak\n  1309\t\t}\n  1310\n  1311\t\tvar err error\n  1312\t\tif runtime.GOOS == \"darwin\" {\n  1313\t\t\terr = exec.Command(\"open\", path).Run()\n  1314\t\t} else if runtime.GOOS == \"windows\" {\n  1315\t\t\terr = exec.Command(\"explorer\", path).Run()\n  1316\t\t} else {\n  1317\t\t\terr = exec.Command(\"xdg-open\", path).Run()\n  1318\t\t}\n  1319\n  1320\t\tif err != nil {\n  1321\t\t\tresp.Status = \"error\"\n  1322\t\t\tresp.Error = err.Error()\n  1323\t\t} else {\n  1324\t\t\tresp.Payload = map[string]string{\"status\": \"opened\", \"path\": path}\n  1325\t\t}\n  1326\n  1327\tcase \"get_status\":\n  1328\t\t// Copy auth status for response\n  1329\t\ts.mu.RLock()\n  1330\t\tauth := make(map[string]string)\n  1331\t\tfor k, v := range s.authStatus {\n  1332\t\t\tauth[k] = v\n  1333\t\t}\n  1334\t\tcli := make(map[string]string)\n  1335\t\tfor k, v := range s.cliStatus {\n  1336\t\t\tcli[k] = v\n  1337\t\t}\n  1338\t\ts.mu.RUnlock()\n  1339\n  1340\t\tresp.Payload = map[string]interface{}{\n  1341\t\t\t\"status\": \"ok\",\n  1342\t\t\t\"components\": map[string]string{\n  1343\t\t\t\t\"database\": \"ok\",\n  1344\t\t\t\t\"server\":   \"ok\",\n  1345\t\t\t\t\"claude\":   cli[\"claude\"],\n  1346\t\t\t\t\"codex\":    cli[\"codex\"],\n  1347\t\t\t},\n  1348\t\t\t\"auth\": auth,\n  1349\t\t\t\"browser\": map[string]interface{}{\n  1350\t\t\t\t\"available_engines\": utils.GetBrowserManager().GetAvailableEngines(),\n  1351\t\t\t},\n  1352\t\t}\n  1353\n  1354\tcase \"login_cli\":\n  1355\t\tcli, _ := req.Payload[\"cli\"].(string)\n  1356\t\tvar err error\n  1357\t\tif cli == \"claude\" {\n  1358\t\t\tif runtime.GOOS == \"darwin\" {\n  1359\t\t\t\t// On macOS, open a new Terminal window to run the login\n  1360\t\t\t\tscript := `tell application \"Terminal\" to do script \"claude\"`\n  1361\t\t\t\terr = exec.Command(\"osascript\", \"-e\", script).Run()\n  1362\t\t\t} else {\n  1363\t\t\t\terr = fmt.Errorf(\"login trigger not supported on this OS\")\n  1364\t\t\t}\n  1365\t\t} else if cli == \"codex\" {\n  1366\t\t\tif runtime.GOOS == \"darwin\" {\n  1367\t\t\t\tscript := `tell application \"Terminal\" to do script \"codex login\"`\n  1368\t\t\t\terr = exec.Command(\"osascript\", \"-e\", script).Run()\n  1369\t\t\t} else {\n  1370\t\t\t\terr = fmt.Errorf(\"login trigger not supported on this OS\")\n  1371\t\t\t}\n  1372\t\t} else {\n  1373\t\t\terr = fmt.Errorf(\"unknown CLI: %s\", cli)\n  1374\t\t}\n  1375\n  1376\t\tif err != nil {\n  1377\t\t\tresp.Status = \"error\"\n  1378\t\t\tresp.Error = err.Error()\n  1379\t\t} else {\n  1380\t\t\t// Clear auth cache to force re-check\n  1381\t\t\ts.mu.Lock()\n  1382\t\t\ts.lastAuthCheck = time.Time{}\n  1383\t\t\ts.mu.Unlock()\n  1384\t\t\tresp.Payload = map[string]string{\"status\": \"triggered\"}\n  1385\t\t}\n  1386\n  1387\tcase \"install_cli\":\n  1388\t\tcli, _ := req.Payload[\"cli\"].(string)\n  1389\t\tif cli == \"claude\" {\n  1390\t\t\terr := runInstall(\"npm\", \"install\", \"-g\", \"@anthropic-ai/claude-code\")\n  1391\t\t\tif err != nil {\n  1392\t\t\t\tresp.Status = \"error\"\n  1393\t\t\t\tresp.Error = err.Error()\n  1394\t\t\t}\n  1395\t\t} else if cli == \"codex\" {\n  1396\t\t\t// Replace with actual codex install command when known, assuming npm for now\n  1397\t\t\terr := runInstall(\"npm\", \"install\", \"-g\", \"codex-cli\")\n  1398\t\t\tif err != nil {\n  1399\t\t\t\tresp.Status = \"error\"\n  1400\t\t\t\tresp.Error = err.Error()\n  1401\t\t\t}\n  1402\t\t} else {\n  1403\t\t\tresp.Status = \"error\"\n  1404\t\t\tresp.Error = \"Unknown CLI: \" + cli\n  1405\t\t}\n  1406\n  1407\tcase \"clear_usage\":\n  1408\t\ts.db.ClearUsage()\n  1409\t\tresp.Payload = map[string]string{\"status\": \"cleared\"}\n  1410\n  1411\tcase \"clear_conversation\":\n  1412\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n  1413\t\tslog.Info(\"Clear conversation requested\", \"agent_id\", agentID)\n  1414\n  1415\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n  1416\t\tif err != nil {\n  1417\t\t\tslog.Error(\"Agent not found for clear conversation\", \"agent_id\", agentID, \"error\", err)\n  1418\t\t\tresp.Status = \"error\"\n  1419\t\t\tresp.Error = err.Error()\n  1420\t\t} else {\n  1421\t\t\t// 0. Stop the agent loop completely if running\n  1422\t\t\tif sa.IsRunning() {\n  1423\t\t\t\tslog.Info(\"Stopping agent for conversation clear\", \"agent_id\", agentID)\n  1424\t\t\t\tsa.Cancel()\n  1425\n  1426\t\t\t\t// Wait for the loop to actually exit (up to 2 seconds)\n  1427\t\t\t\tfor i := 0; i < 10; i++ {\n  1428\t\t\t\t\tif !sa.IsRunning() {\n  1429\t\t\t\t\t\tbreak\n  1430\t\t\t\t\t}\n  1431\t\t\t\t\ttime.Sleep(200 * time.Millisecond)\n  1432\t\t\t\t}\n  1433\t\t\t}\n  1434\n  1435\t\t\t// Also stop any active scope creation\n  1436\t\t\tif cancel, ok := s.proposing.Load(agentID); ok {\n  1437\t\t\t\tslog.Info(\"Cancelling active scope creation for conversation clear\", \"agent_id\", agentID)\n  1438\t\t\t\tcancel.(context.CancelFunc)()\n  1439\t\t\t\ts.proposing.Delete(agentID)\n  1440\t\t\t}\n  1441\n  1442\t\t\t// Wait a small amount of time for any pending DB operations to finish\n  1443\t\t\ttime.Sleep(200 * time.Millisecond)\n  1444\n  1445\t\t\t// 1. Clear files and internal state\n  1446\t\t\tarchiveResults, err := sa.ClearConversation(context.Background())\n  1447\t\t\tif err != nil {\n  1448\t\t\t\tslog.Error(\"Failed to clear conversation files\", \"agent_id\", agentID, \"error\", err)\n  1449\t\t\t\tresp.Status = \"error\"\n  1450\t\t\t\tresp.Error = \"Failed to clear conversation files: \" + err.Error()\n  1451\t\t\t} else {\n  1452\t\t\t\t// 2. Clear database logs and current scope\n  1453\t\t\t\tif err := s.db.ClearAgentLogs(agentID); err != nil {\n  1454\t\t\t\t\tslog.Error(\"Failed to clear conversation logs in DB\", \"agent_id\", agentID, \"error\", err)\n  1455\t\t\t\t\tresp.Status = \"error\"\n  1456\t\t\t\t\tresp.Error = \"Failed to clear conversation logs: \" + err.Error()\n  1457\t\t\t\t} else {\n  1458\t\t\t\t\tif err := s.db.ClearAgentScope(agentID); err != nil {\n  1459\t\t\t\t\t\tslog.Error(\"Failed to clear agent scope in DB\", \"agent_id\", agentID, \"error\", err)\n  1460\t\t\t\t\t}\n  1461\t\t\t\t\tslog.Info(\"Conversation logs cleared successfully\", \"agent_id\", agentID)\n  1462\n  1463\t\t\t\t\t// 3. Reset context usage\n  1464\t\t\t\t\ts.db.UpdateAgentContextUsage(agentID, 0, sa.MaxContextTokens)\n  1465\n  1466\t\t\t\t\t// 4. Reset agent state to idle\n  1467\t\t\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateIdle, nil)\n  1468\t\t\t\t\tsa.SetState(types.AgentStateIdle)\n  1469\n  1470\t\t\t\t\t// 5. Add a \"conversation_cleared\" log entry so the UI shows something\n  1471\t\t\t\t\thasArchivedFiles := false\n  1472\t\t\t\t\tlogPayload := map[string]interface{}{}\n  1473\n  1474\t\t\t\t\tif path, ok := archiveResults[\"archive_dir\"]; ok {\n  1475\t\t\t\t\t\tlogPayload[\"archive_dir\"] = path\n  1476\t\t\t\t\t}\n  1477\t\t\t\t\tif path, ok := archiveResults[\"history_archive.md\"]; ok {\n  1478\t\t\t\t\t\tlogPayload[\"archive_path\"] = path\n  1479\t\t\t\t\t\tlogPayload[\"archive_file\"] = filepath.Base(path)\n  1480\t\t\t\t\t\thasArchivedFiles = true\n  1481\t\t\t\t\t}\n  1482\t\t\t\t\tif path, ok := archiveResults[\"full_history.jsonl\"]; ok {\n  1483\t\t\t\t\t\tlogPayload[\"history_path\"] = path\n  1484\t\t\t\t\t\tlogPayload[\"full_history\"] = filepath.Base(path)\n  1485\t\t\t\t\t\thasArchivedFiles = true\n  1486\t\t\t\t\t}\n  1487\n  1488\t\t\t\t\tif hasArchivedFiles {\n  1489\t\t\t\t\t\tlogPayload[\"message\"] = \"Conversation history has been cleared and archived to the workspace.\"\n  1490\t\t\t\t\t} else {\n  1491\t\t\t\t\t\tlogPayload[\"message\"] = \"Conversation history has been cleared. (No previous history files were found to archive.)\"\n  1492\t\t\t\t\t}\n  1493\t\t\t\t\ts.db.AppendAgentLog(agentID, \"conversation_cleared\", logPayload)\n  1494\n  1495\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"cleared\", \"agent_id\": agentID}\n  1496\n  1497\t\t\t\t\t// 6. Broadcast updates\n  1498\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n  1499\t\t\t\t\t\t\"type\":     \"conversation_cleared\",\n  1500\t\t\t\t\t\t\"agent_id\": agentID,\n  1501\t\t\t\t\t})\n  1502\n  1503\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n  1504\t\t\t\t\t\t\"type\":     \"scope_approved\",\n  1505\t\t\t\t\t\t\"agent_id\": agentID,\n  1506\t\t\t\t\t\t\"scope_id\": \"\",\n  1507\t\t\t\t\t})\n  1508\n  1509\t\t\t\t\t// Refresh logs for all clients\n  1510\t\t\t\t\tlogs, _ := s.db.ListAgentLogs(agentID)\n  1511\t\t\t\t\tslog.Info(\"Broadcasting logs_updated\", \"agent_id\", agentID, \"count\", len(logs))\n  1512\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n  1513\t\t\t\t\t\t\"type\":     \"logs_updated\",\n  1514\t\t\t\t\t\t\"agent_id\": agentID,\n  1515\t\t\t\t\t\t\"logs\":     logs,\n  1516\t\t\t\t\t})\n  1517\n  1518\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n  1519\t\t\t\t\t\t\"type\":               \"agent_context_updated\",\n  1520\t\t\t\t\t\t\"agent_id\":           agentID,\n  1521\t\t\t\t\t\t\"context_tokens\":     0,\n  1522\t\t\t\t\t\t\"max_context_tokens\": sa.MaxContextTokens,\n  1523\t\t\t\t\t})\n  1524\n  1525\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n  1526\t\t\t\t\t\t\"type\":         \"agent_state_changed\",\n  1527\t\t\t\t\t\t\"agent_id\":     agentID,\n  1528\t\t\t\t\t\t\"new_state\":    types.AgentStateIdle,\n  1529\t\t\t\t\t\t\"error_detail\": nil,\n  1530\t\t\t\t\t})\n  1531\n  1532\t\t\t\t\t// 7. Broadcast agent updated to clear scope in UI\n  1533\t\t\t\t\tupdatedAgent, _ := s.db.GetAgent(agentID)\n  1534\t\t\t\t\tif updatedAgent != nil {\n  1535\t\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n  1536\t\t\t\t\t\t\t\"type\":     \"agent_updated\",\n  1537\t\t\t\t\t\t\t\"agent_id\": agentID,\n  1538\t\t\t\t\t\t\t\"agent\":    updatedAgent,\n  1539\t\t\t\t\t\t})\n  1540\t\t\t\t\t}\n  1541\t\t\t\t}\n  1542\t\t\t}\n  1543\t\t}\n  1544\n  1545\tcase \"get_system_prompt\":\n  1546\t\tprompt, _ := s.db.GetActiveSystemPrompt()\n  1547\t\tresp.Payload = map[string]interface{}{\n  1548\t\t\t\"content\":   prompt,\n  1549\t\t\t\"is_custom\": false,\n  1550\t\t\t\"version\":   nil,\n  1551\t\t}\n  1552\n  1553\tcase \"get_system_prompt_versions\":\n  1554\t\tprompt, _ := s.db.GetActiveSystemPrompt()\n  1555\t\tresp.Payload = map[string]interface{}{\n  1556\t\t\t\"versions\":        []interface{}{},\n  1557\t\t\t\"default_content\": prompt,\n  1558\t\t}\n  1559\n  1560\tcase \"update_system_prompt\":\n  1561\t\t// Placeholder for update system prompt\n  1562\t\tresp.Payload = map[string]interface{}{\"status\": \"updated\"}\n  1563\n  1564\tcase \"revert_system_prompt\":\n  1565\t\t// Placeholder for revert system prompt\n  1566\t\tresp.Payload = map[string]interface{}{\"status\": \"reverted\"}\n  1567\n  1568\tcase \"reset_system_prompt\":\n  1569\t\t// Placeholder for reset system prompt\n  1570\t\tresp.Payload = map[string]string{\"status\": \"reset\"}\n  1571\n  1572\tdefault:\n  1573\t\tresp.Status = \"error\"\n  1574\t\tresp.Error = \"Unknown request type: \" + req.Type\n  1575\t}\n  1576\n  1577\ts.safeWriteJSON(conn, resp)\n  1578}\n  1579\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a73c1692-0bac-4e3f-99d7-00242f749f3a","timestamp":"2026-01-03T12:10:51.641Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/handlers.go","content":"package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/uuid\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/agent\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/scheduler\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/tools\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/utils\"\n\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n)\n\nfunc (s *Server) handleGlobalWebSocket(c *gin.Context) {\n\tconn, err := upgrader.Upgrade(c.Writer, c.Request, nil)\n\tif err != nil {\n\t\tslog.Error(\"Failed to upgrade global websocket\", \"error\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\ts.mu.Lock()\n\ts.globalClients = append(s.globalClients, conn)\n\ts.mu.Unlock()\n\n\tdefer func() {\n\t\ts.mu.Lock()\n\t\tfor i, v := range s.globalClients {\n\t\t\tif v == conn {\n\t\t\t\ts.globalClients = append(s.globalClients[:i], s.globalClients[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tdelete(s.connLocks, conn)\n\t\ts.mu.Unlock()\n\t}()\n\n\tfor {\n\t\tvar req types.WebSocketRequest\n\t\terr := conn.ReadJSON(&req)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\ts.handleWSRequest(conn, &req)\n\t}\n}\n\nfunc (s *Server) handleWSRequest(conn *websocket.Conn, req *types.WebSocketRequest) {\n\tslog.Debug(\"WS Request received\", \"type\", req.Type)\n\tresp := types.WebSocketResponse{\n\t\tType:      req.Type,\n\t\tRequestID: req.RequestID,\n\t\tStatus:    \"ok\",\n\t}\n\n\tswitch req.Type {\n\tcase \"submit_feedback_manual\":\n\t\tmessage, _ := req.Payload[\"message\"].(string)\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tif message == \"\" {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = \"Message is required\"\n\t\t\ts.safeWriteJSON(conn, resp)\n\t\t\treturn\n\t\t}\n\n\t\ttool := tools.NewFeedbackTool()\n\t\tresult, err := tool.Execute(context.Background(), map[string]interface{}{\"message\": message}, nil)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"submitted\", \"content\": result.Content}\n\t\t\tif agentID != \"\" {\n\t\t\t\ts.db.AppendAgentLog(agentID, \"model_responded\", map[string]interface{}{\n\t\t\t\t\t\"content\": \"Manual feedback submitted successfully. Thank you!\",\n\t\t\t\t})\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":       \"execution_log\",\n\t\t\t\t\t\"agent_id\":   agentID,\n\t\t\t\t\t\"event_type\": \"model_responded\",\n\t\t\t\t\t\"payload\": map[string]interface{}{\n\t\t\t\t\t\t\"content\": \"Manual feedback submitted successfully. Thank you!\",\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\tcase \"restart_onboarding\":\n\t\terr := s.BootstrapOnboarding()\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"restarted\"}\n\t\t}\n\n\tcase \"resolve_missed_tasks\":\n\t\tresolutions, _ := req.Payload[\"resolutions\"].(map[string]interface{})\n\t\tfor taskID, res := range resolutions {\n\t\t\tif resStr, ok := res.(string); ok {\n\t\t\t\ts.scheduler.ResolveMissedTask(taskID, resStr)\n\t\t\t}\n\t\t}\n\t\ts.safeWriteJSON(conn, resp)\n\n\tcase \"create_agent\":\n\t\tmodelConfig, _ := req.Payload[\"model_config\"].(map[string]interface{})\n\t\tinitialPrompt, _ := req.Payload[\"initial_prompt\"].(string)\n\t\tplanEnabled, ok := req.Payload[\"plan_enabled\"].(bool)\n\t\tif !ok {\n\t\t\tplanEnabled = true // Default to enabled\n\t\t}\n\t\tinitialPrompt = strings.TrimSpace(initialPrompt)\n\t\tcfg, _ := config.LoadConfig()\n\n\t\t// Get provider and model, using validated defaults if not specified\n\t\tprovider, _ := modelConfig[\"provider\"].(string)\n\t\tmodel, _ := modelConfig[\"model\"].(string)\n\t\tif provider == \"\" || model == \"\" {\n\t\t\tdefaultProvider, defaultModel := s.getDefaultChatConfig(cfg)\n\t\t\tif provider == \"\" {\n\t\t\t\tprovider = defaultProvider\n\t\t\t}\n\t\t\tif model == \"\" {\n\t\t\t\tmodel = defaultModel\n\t\t\t}\n\t\t}\n\n\t\t// Provider and model will be validated during messaging or resumption.\n\t\t// If they remain empty, the agent will simply be created with empty model config.\n\n\t\tagentID := uuid.New().String()\n\t\tname := utils.GetRandomName()\n\n\t\t// Determine max context tokens\n\t\tcontextLimit := 128000\n\t\tif prov, err := s.createProvider(provider); err == nil {\n\t\t\tcontextLimit = prov.GetContextLimit(model)\n\t\t}\n\n\t\t// Set defaults from global config\n\t\tsubAgentsEnabled := true\n\t\tif cfg.SubAgent.Enabled != nil {\n\t\t\tsubAgentsEnabled = *cfg.SubAgent.Enabled\n\t\t}\n\n\t\tparentID, _ := req.Payload[\"parent_id\"].(string)\n\t\tvar parentIDPtr *string\n\t\tif parentID != \"\" {\n\t\t\tparentIDPtr = &parentID\n\t\t}\n\n\t\tisSkillCreator, _ := req.Payload[\"is_skill_creator\"].(bool)\n\t\tisTriggerArchitect, _ := req.Payload[\"is_trigger_architect\"].(bool)\n\t\tisFeedbackCollector, _ := req.Payload[\"is_feedback_collector\"].(bool)\n\t\tisInternal := false\n\t\tworkingDir := \"\"\n\t\tif isSkillCreator {\n\t\t\tisInternal = true\n\t\t\tname = \"Skill Architect\"\n\t\t\tif skillID, ok := req.Payload[\"skill_id\"].(string); ok && skillID != \"\" {\n\t\t\t\tname = \"Skill Architect: \" + skillID\n\t\t\t}\n\t\t\tworkingDir = filepath.Join(config.GetConfigDir(), \"skills\")\n\t\t\tplanEnabled = false // Skill Architect doesn't need a formal plan\n\t\t} else if isTriggerArchitect {\n\t\t\tisInternal = true\n\t\t\tname = \"Trigger Architect\"\n\t\t\tif triggerID, ok := req.Payload[\"trigger_id\"].(string); ok && triggerID != \"\" {\n\t\t\t\tname = \"Trigger Architect: \" + triggerID\n\t\t\t}\n\t\t\tworkingDir = filepath.Join(config.GetConfigDir(), \"triggers\")\n\t\t\tplanEnabled = false\n\t\t} else if isFeedbackCollector {\n\t\t\tisInternal = true\n\t\t\tname = \"Feedback Collector\"\n\t\t\tplanEnabled = false\n\t\t\tprovider = \"onboarding\"\n\t\t\tmodel = \"scripted\"\n\t\t}\n\n\t\ta := types.Agent{\n\t\t\tID:               agentID,\n\t\t\tParentID:         parentIDPtr,\n\t\t\tType:             types.AgentTypeStandard,\n\t\t\tName:             name,\n\t\t\tState:            types.AgentStateIdle,\n\t\t\tInitialPrompt:    initialPrompt,\n\t\t\tPlanEnabled:      planEnabled,\n\t\t\tSubAgentsEnabled: subAgentsEnabled,\n\t\t\tIsInternal:       isInternal,\n\t\t\tWorkingDirectory: workingDir,\n\t\t\tModelConfig: types.ModelConfig{\n\t\t\t\tProvider: provider,\n\t\t\t\tModel:    model,\n\t\t\t},\n\t\t\tMaxContextTokens: contextLimit,\n\t\t\tCreatedAt:        time.Now().UTC(),\n\t\t\tUpdatedAt:        time.Now().UTC(),\n\t\t}\n\n\t\tif err := s.db.CreateAgent(a); err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\t// Mark onboarding as completed if this is a real agent and provider exists\n\t\t\tif !isInternal && provider != \"onboarding\" {\n\t\t\t\ts.db.SetSetting(\"onboarding_completed\", \"true\")\n\t\t\t}\n\n\t\t\tresp.Payload = a\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":  \"agent_created\",\n\t\t\t\t\"agent\": a,\n\t\t\t})\n\t\t\tif initialPrompt != \"\" {\n\t\t\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"user_interaction\", map[string]interface{}{\n\t\t\t\t\t\"content\": initialPrompt,\n\t\t\t\t})\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":       \"execution_log\",\n\t\t\t\t\t\"agent_id\":   agentID,\n\t\t\t\t\t\"event_type\": \"user_interaction\",\n\t\t\t\t\t\"payload\":    map[string]interface{}{\"id\": logID, \"content\": initialPrompt},\n\t\t\t\t})\n\t\t\t\tgo s.handleAgentScopeSetup(agentID)\n\t\t\t} else {\n\t\t\t\t// Add initial greeting\n\t\t\t\tgreeting := \"What can I help you accomplish today?\"\n\t\t\t\tif isSkillCreator {\n\t\t\t\t\tskillID, _ := req.Payload[\"skill_id\"].(string)\n\t\t\t\t\tif skillID != \"\" {\n\t\t\t\t\t\tgreeting = fmt.Sprintf(\"Hi there! I'm the Skill Architect. I see you want to improve the **%s** skill. I'm here to help you design, implement, and test new capabilities for your personal agent. How would you like to proceed?\\n\\n**Note**: Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them if needed.\", skillID)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgreeting = \"Hi there! I'm the Skill Architect. Familiar Skills are specialized tools and capabilities that you can create to extend my functionality. I'm here to help you design, implement, and test new skills for your personal agent. What would you like to accomplish today?\\n\\n**Note**: Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them if needed.\"\n\t\t\t\t\t}\n\t\t\t\t} else if isTriggerArchitect {\n\t\t\t\t\ttriggerID, _ := req.Payload[\"trigger_id\"].(string)\n\t\t\t\t\tif triggerID != \"\" {\n\t\t\t\t\t\tgreeting = fmt.Sprintf(\"Hi! I'm the Trigger Architect. I see you want to configure the **%s** trigger. I can help you set up a subscription with a prompt template or explain how it works. How would you like to proceed?\\n\\n**Note**: Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them if needed.\", triggerID)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgreeting = \"Hi! I'm the Trigger Architect. I help you connect your personal agent to the outside world through automations and system events. I can help you create scripts that monitor your clipboard, watch files, poll external APIs, or react to schedule-based events. What kind of trigger would you like to set up today?\\n\\n**Note**: Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them if needed.\"\n\t\t\t\t\t}\n\t\t\t\t} else if isFeedbackCollector {\n\t\t\t\t\tgreeting = \"Hi! I'm here to collect your feedback. Would you like my help in gathering details (which uses your AI credits), or would you prefer to just type it out manually?\\n\\n**Please type one of the following:**\\n- **\\\"Yes\\\"**: I'll switch to an AI provider to help you. (Credits will be used)\\n- **\\\"No\\\"**: You can type your feedback directly and I'll send it.\"\n\t\t\t\t}\n\t\t\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"model_responded\", map[string]interface{}{\n\t\t\t\t\t\"content\": greeting,\n\t\t\t\t})\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":       \"execution_log\",\n\t\t\t\t\t\"agent_id\":   agentID,\n\t\t\t\t\t\"event_type\": \"model_responded\",\n\t\t\t\t\t\"payload\":    map[string]interface{}{\"id\": logID, \"content\": greeting},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\tcase \"update_scope\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tcontent, _ := req.Payload[\"content\"].(string)\n\n\t\tvar fmOverride *types.ScopeFrontmatter\n\t\tif fmData, ok := req.Payload[\"frontmatter\"].(map[string]interface{}); ok {\n\t\t\tb, _ := json.Marshal(fmData)\n\t\t\tjson.Unmarshal(b, &fmOverride)\n\t\t}\n\n\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tvar parentScope *types.ScopeDocument\n\t\t\tif sa.ParentID != nil {\n\t\t\t\tparentScope, _ = s.db.GetCurrentScope(*sa.ParentID)\n\t\t\t}\n\t\t\tdoc, err := sa.ParseScopeDocument(content, fmOverride, parentScope)\n\t\t\tif err != nil {\n\t\t\t\tresp.Status = \"error\"\n\t\t\t\tresp.Error = \"Invalid scope format: \" + err.Error()\n\t\t\t} else {\n\t\t\t\t// Maintain version if it was already set in the document or by the sa\n\t\t\t\tif sa.CurrentScope != nil && doc.Version <= sa.CurrentScope.Version {\n\t\t\t\t\tdoc.Version = sa.CurrentScope.Version + 1\n\t\t\t\t\tdoc.Frontmatter.Version = doc.Version\n\t\t\t\t}\n\n\t\t\t\tnow := time.Now().UTC()\n\t\t\t\tdoc.ApprovedAt = &now\n\n\t\t\t\tif err := s.db.CreateScopeDocument(*doc); err != nil {\n\t\t\t\t\tresp.Status = \"error\"\n\t\t\t\t\tresp.Error = \"Failed to save scope: \" + err.Error()\n\t\t\t\t} else {\n\t\t\t\t\tif err := s.db.ApproveScope(agentID, doc.ID); err != nil {\n\t\t\t\t\t\tslog.Error(\"Failed to mark scope as approved\", \"agent_id\", agentID, \"error\", err)\n\t\t\t\t\t}\n\n\t\t\t\t\tsa.SetScope(doc)\n\n\t\t\t\t\tresp.Payload = doc\n\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\t\"type\":     \"scope_updated\",\n\t\t\t\t\t\t\"agent_id\": agentID,\n\t\t\t\t\t\t\"scope\":    doc,\n\t\t\t\t\t})\n\n\t\t\t\t\tif updatedAgent, err := s.db.GetAgent(agentID); err == nil {\n\t\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\t\t\"type\":  \"agent_updated\",\n\t\t\t\t\t\t\t\"agent\": updatedAgent,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tcase \"approve_scope\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tscopeID, _ := req.Payload[\"scope_id\"].(string)\n\n\t\t// Parse no_resume robustly\n\t\tnoResume := false\n\t\tif nr, ok := req.Payload[\"no_resume\"].(bool); ok {\n\t\t\tnoResume = nr\n\t\t}\n\n\t\tslog.Info(\"Approving scope\", \"agent_id\", agentID, \"scope_id\", scopeID, \"no_resume\", noResume)\n\t\terr := s.db.ApproveScope(agentID, scopeID)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateWaiting, nil)\n\n\t\t\t// Fetch updated agent\n\t\t\tupdatedAgent, err := s.db.GetAgent(agentID)\n\t\t\tif err != nil {\n\t\t\t\tslog.Error(\"Failed to fetch updated agent\", \"agent_id\", agentID, \"error\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresp.Payload = map[string]string{\"status\": \"approved\", \"scope_id\": scopeID}\n\n\t\t\t// Broadcast updated agent and state change\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":      \"agent_state_changed\",\n\t\t\t\t\"agent\":     updatedAgent,\n\t\t\t\t\"agent_id\":  agentID,\n\t\t\t\t\"new_state\": types.AgentStateWaiting,\n\t\t\t})\n\n\t\t\t// Broadcast scope_approved\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":     \"scope_approved\",\n\t\t\t\t\"agent_id\": agentID,\n\t\t\t\t\"scope_id\": scopeID,\n\t\t\t})\n\n\t\t\t// Update the stateful agent's scope if it exists\n\t\t\tsa, errSa := s.getOrCreateStatefulAgent(agentID)\n\t\t\tif errSa == nil && sa != nil {\n\t\t\t\tscope, _ := s.db.GetCurrentScope(agentID)\n\t\t\t\tsa.SetScope(scope)\n\t\t\t\tsa.SetState(types.AgentStateWaiting)\n\t\t\t}\n\n\t\t\t// Automatically start running the task unless no_resume is requested\n\t\t\tif !noResume {\n\t\t\t\tslog.Info(\"Resuming agent after scope approval\", \"agent_id\", agentID)\n\t\t\t\ts.resumeAgent(agentID, \"\")\n\t\t\t} else {\n\t\t\t\tslog.Info(\"Skipping agent resume as requested\", \"agent_id\", agentID)\n\t\t\t}\n\t\t}\n\n\tcase \"reject_scope\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tscopeID, _ := req.Payload[\"scope_id\"].(string)\n\t\tfeedback, _ := req.Payload[\"feedback\"].(string)\n\n\t\tslog.Info(\"Scope rejected\", \"agent_id\", agentID, \"scope_id\", scopeID, \"feedback\", feedback)\n\n\t\terr := s.db.UpdateAgentState(agentID, types.AgentStateIdle, nil)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\ts.db.AppendAgentLog(agentID, \"scope_rejected\", map[string]string{\n\t\t\t\t\"scope_id\": scopeID,\n\t\t\t\t\"feedback\": feedback,\n\t\t\t})\n\n\t\t\tresp.Payload = map[string]string{\"status\": \"rejected\", \"agent_id\": agentID}\n\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":     \"scope_rejected\",\n\t\t\t\t\"agent_id\": agentID,\n\t\t\t\t\"scope_id\": scopeID,\n\t\t\t\t\"feedback\": feedback,\n\t\t\t})\n\t\t}\n\n\tcase \"update_agent_state\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\taction, _ := req.Payload[\"action\"].(string)\n\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\tswitch action {\n\t\tcase \"pause\":\n\t\t\tsa.Pause()\n\t\t\t// Broadcast state change immediately so UI updates even if agent is stuck\n\t\t\tupdatedAgent, _ := s.db.GetAgent(agentID)\n\t\t\tif updatedAgent != nil {\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":      \"agent_state_changed\",\n\t\t\t\t\t\"agent\":     updatedAgent,\n\t\t\t\t\t\"agent_id\":  agentID,\n\t\t\t\t\t\"new_state\": types.AgentStatePaused,\n\t\t\t\t})\n\t\t\t}\n\t\tcase \"pause_tree\":\n\t\t\ts.pauseAgentRecursive(agentID)\n\t\tcase \"resume\":\n\t\t\tif err := s.resumeAgent(agentID, \"\"); err != nil {\n\t\t\t\tresp.Status = \"error\"\n\t\t\t\tresp.Error = err.Error()\n\t\t\t}\n\t\tcase \"resume_tree\":\n\t\t\ts.resumeAgentRecursive(agentID)\n\t\t\tcase \"cancel\":\n\t\t\t\tsa.Cancel()\n\t\t\tcase \"repair\":\n\t\t\t\tslog.Info(\"Repairing agent history via forced compaction\", \"agent_id\", agentID)\n\n\t\t\t\thistory, _ := s.db.ListAgentLogs(agentID)\n\t\t\t\ta, _ := s.db.GetAgent(agentID)\n\t\t\t\tvar parentScope *types.ScopeDocument\n\t\t\t\tif a != nil && a.ParentID != nil {\n\t\t\t\t\tparentScope, _ = s.db.GetCurrentScope(*a.ParentID)\n\t\t\t\t}\n\n\t\t\t\tif !sa.CanCompact(history, parentScope) {\n\t\t\t\t\tslog.Info(\"Compaction skipped: not enough history to compact\", \"agent_id\", agentID)\n\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"skipped\", \"reason\": \"not_enough_history\"}\n\t\t\t\t\ts.safeWriteJSON(conn, resp)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif sa.IsRunning() {\n\t\t\t\t\t// Ensure the agent stops after its current turn if it's running.\n\t\t\t\t\tsa.Pause()\n\t\t\t\t\t// Set the flag so it compacts at the start of its next turn (or when resumed).\n\t\t\t\t\tsa.ForceCompaction(\"user_request\", \"\")\n\t\t\t\t\tslog.Info(\"Agent is running; set to pause and compact on next turn\", \"agent_id\", agentID)\n\t\t\t\t} else {\n\t\t\t\t\t// Log the request\n\t\t\t\t\tsa.OnLog(agentID, \"compaction_requested\", map[string]interface{}{\"requested_by\": \"user_request\"})\n\t\t\t\t\tif err := sa.PerformCompaction(context.Background(), history, parentScope, true, \"\"); err != nil {\n\t\t\t\t\t\tslog.Error(\"Failed manual compaction\", \"agent_id\", agentID, \"error\", err)\n\t\t\t\t\t\tresp.Status = \"error\"\n\t\t\t\t\t\tresp.Error = \"Compaction failed: \" + err.Error()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresp.Payload = map[string]string{\"status\": action, \"agent_id\": agentID}\n\t\t}\n\n\tcase \"update_agent_config\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tconfigData, _ := req.Payload[\"model_config\"].(map[string]interface{})\n\n\t\t// Load existing agent to merge config\n\t\texistingAgent, err := s.db.GetAgent(agentID)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = \"Agent not found: \" + err.Error()\n\t\t\ts.safeWriteJSON(conn, resp)\n\t\t\treturn\n\t\t}\n\n\t\t// Handle plan_enabled if present\n\t\tif planEnabled, ok := req.Payload[\"plan_enabled\"].(bool); ok {\n\t\t\tif err := s.db.UpdateAgentPlanEnabled(agentID, planEnabled); err != nil {\n\t\t\t\tresp.Status = \"error\"\n\t\t\t\tresp.Error = \"Failed to update planning mode: \" + err.Error()\n\t\t\t\ts.safeWriteJSON(conn, resp)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Handle sub_agents_enabled if present\n\t\tif subAgentsEnabled, ok := req.Payload[\"sub_agents_enabled\"].(bool); ok {\n\t\t\tif err := s.db.UpdateAgentSubAgentsEnabled(agentID, subAgentsEnabled); err != nil {\n\t\t\t\tresp.Status = \"error\"\n\t\t\t\tresp.Error = \"Failed to update sub-agents mode: \" + err.Error()\n\t\t\t\ts.safeWriteJSON(conn, resp)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Merge model config\n\t\tmodelConfig := existingAgent.ModelConfig\n\t\t// Safely merge partial model config from frontend\n\t\tif configBytes, err := json.Marshal(configData); err == nil {\n\t\t\tif err := json.Unmarshal(configBytes, &modelConfig); err != nil {\n\t\t\t\tslog.Error(\"Failed to unmarshal partial model config\", \"error\", err)\n\t\t\t}\n\t\t}\n\n\t\tif err := s.db.UpdateAgentModelConfig(agentID, modelConfig); err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\t// Update in-memory stateful agent if it exists\n\t\t\t// This will also validate the provider if getOrCreateStatefulAgent is called\n\t\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n\t\t\tif err != nil {\n\t\t\t\t// Provider is likely disabled or invalid\n\t\t\t\tresp.Status = \"error\"\n\t\t\t\tresp.Error = err.Error()\n\t\t\t\ts.safeWriteJSON(conn, resp)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif sa != nil {\n\t\t\t\tnewProvider, err := s.createProvider(modelConfig.Provider)\n\t\t\t\tif err == nil {\n\t\t\t\t\tsa.UpdateModelConfig(modelConfig, newProvider)\n\t\t\t\t} else {\n\t\t\t\t\tslog.Error(\"Failed to create new provider during config update\", \"error\", err)\n\t\t\t\t\t// Fallback: update model only\n\t\t\t\t\tsa.UpdateModelConfig(modelConfig, nil)\n\t\t\t\t}\n\t\t\t\t// Update max_context_tokens in database when model changes\n\t\t\t\tmaxContextTokens := sa.MaxContextTokens\n\t\t\t\tagent, _ := s.db.GetAgent(agentID)\n\t\t\t\tif agent != nil {\n\t\t\t\t\ts.db.UpdateAgentContextUsage(agentID, agent.ContextTokens, maxContextTokens)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresp.Payload = map[string]string{\"status\": \"updated\", \"agent_id\": agentID}\n\n\t\t\t// Broadcast updated agent\n\t\t\tupdatedAgent, err := s.db.GetAgent(agentID)\n\t\t\tif err == nil {\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":  \"agent_updated\",\n\t\t\t\t\t\"agent\": updatedAgent,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\tcase \"send_message\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tcontent, _ := req.Payload[\"content\"].(string)\n\t\tattachments, _ := req.Payload[\"attachments\"].([]interface{})\n\n\t\tslog.Info(\"Message sent to agent\", \"agent_id\", agentID, \"content\", content, \"attachments\", len(attachments))\n\n\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"user_interaction\", map[string]interface{}{\n\t\t\t\"content\":     content,\n\t\t\t\"attachments\": attachments,\n\t\t})\n\n\t\tresp.Payload = map[string]string{\"status\": \"received\", \"agent_id\": agentID}\n\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":       \"execution_log\",\n\t\t\t\"agent_id\":   agentID,\n\t\t\t\"event_type\": \"user_interaction\",\n\t\t\t\"payload\":    map[string]interface{}{\"id\": logID, \"content\": content, \"attachments\": attachments},\n\t\t})\n\n\t\t// Enqueue message if agent is already running to avoid missing it in the current loop\n\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n\t\tif err != nil {\n\t\t\tslog.Error(\"Failed to get agent for message\", \"agent_id\", agentID, \"error\", err)\n\t\t\terrDetail := &types.ErrorDetail{\n\t\t\t\tCategory:    types.ErrorInitialization,\n\t\t\t\tMessage:     err.Error(),\n\t\t\t\tRecoverable: true,\n\t\t\t}\n\t\t\tpayload := map[string]interface{}{\n\t\t\t\t\"message\": err.Error(),\n\t\t\t}\n\t\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"agent_error\", payload)\n\t\t\tpayload[\"id\"] = logID\n\n\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateError, errDetail)\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":         \"agent_state_changed\",\n\t\t\t\t\"agent_id\":     agentID,\n\t\t\t\t\"new_state\":    types.AgentStateError,\n\t\t\t\t\"error_detail\": errDetail,\n\t\t\t})\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":       \"execution_log\",\n\t\t\t\t\"agent_id\":   agentID,\n\t\t\t\t\"event_type\": \"agent_error\",\n\t\t\t\t\"payload\":    payload,\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tif sa != nil {\n\t\t\tvar parsedAttachments []types.Attachment\n\t\t\tfor _, att := range attachments {\n\t\t\t\tif a, ok := att.(map[string]interface{}); ok {\n\t\t\t\t\tid, _ := a[\"id\"].(string)\n\t\t\t\t\ttp, _ := a[\"type\"].(string)\n\t\t\t\t\tname, _ := a[\"name\"].(string)\n\t\t\t\t\tmime, _ := a[\"mimeType\"].(string)\n\t\t\t\t\tdata, _ := a[\"data\"].(string)\n\t\t\t\t\tsize, _ := a[\"size\"].(float64)\n\t\t\t\t\tpath, _ := a[\"path\"].(string)\n\t\t\t\t\tparsedAttachments = append(parsedAttachments, types.Attachment{\n\t\t\t\t\t\tID:       id,\n\t\t\t\t\t\tType:     tp,\n\t\t\t\t\t\tName:     name,\n\t\t\t\t\t\tMimeType: mime,\n\t\t\t\t\t\tData:     data,\n\t\t\t\t\t\tSize:     int64(size),\n\t\t\t\t\t\tPath:     path,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tsa.EnqueueUserInteraction(content, parsedAttachments)\n\t\t}\n\n\t\t// If agent is idle, this is a planning interaction\n\t\ta, err := s.db.GetAgent(agentID)\n\t\tif err == nil {\n\t\t\tif a.State == types.AgentStateIdle {\n\t\t\t\t// Only sub-agents use the first message as a \"Mission\" (InitialPrompt)\n\t\t\t\t// Top-level agents are governed by their evolving Plan.\n\t\t\t\tif a.ParentID != nil && a.InitialPrompt == \"\" {\n\t\t\t\t\ts.db.UpdateAgentPrompt(agentID, content)\n\t\t\t\t}\n\t\t\t\tgo s.handleAgentScopeSetup(agentID)\n\t\t\t} else {\n\t\t\t\t// For any other state (completed, waiting, running, error), trigger the loop\n\t\t\t\tif err := s.resumeAgent(agentID, \"\"); err != nil {\n\t\t\t\t\tslog.Error(\"Failed to resume agent from send_message\", \"agent_id\", agentID, \"error\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tcase \"list_agents\":\n\t\tagents, err := s.db.ListAgents(nil, nil)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = agents\n\t\t}\n\n\tcase \"list_tasks\":\n\t\ttasks, err := s.getTasksWithNextRun()\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = tasks\n\t\t}\n\n\tcase \"delete_task\":\n\t\ttaskID, _ := req.Payload[\"id\"].(string)\n\t\ts.scheduler.RemoveTask(taskID)\n\t\tif err := s.db.DeleteTask(taskID); err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"id\": taskID}\n\t\t\ttasks, _ := s.getTasksWithNextRun()\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":  \"tasks_updated\",\n\t\t\t\t\"tasks\": tasks,\n\t\t\t})\n\t\t}\n\n\tcase \"get_agent\":\n\t\tid, _ := req.Payload[\"agent_id\"].(string)\n\t\ta, err := s.db.GetAgent(id)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = a\n\t\t}\n\n\tcase \"list_agent_logs\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tlogs, err := s.db.ListAgentLogs(agentID)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = logs\n\t\t}\n\n\tcase \"rename_agent\":\n\t\tid, _ := req.Payload[\"agent_id\"].(string)\n\t\tname, _ := req.Payload[\"name\"].(string)\n\t\tif err := s.db.UpdateAgentName(id, name); err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"renamed\", \"agent_id\": id, \"name\": name}\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":     \"agent_renamed\",\n\t\t\t\t\"agent_id\": id,\n\t\t\t\t\"name\":     name,\n\t\t\t})\n\t\t}\n\n\tcase \"delete_agent\":\n\t\tid, _ := req.Payload[\"agent_id\"].(string)\n\n\t\t// 1. Database cleanup (collects all child IDs within transaction to avoid race conditions)\n\t\tdeletedIDs, err := s.db.DeleteAgent(id)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\t// 2. Recursive memory/scheduler cleanup (using IDs from DB deletion)\n\t\t\tfor _, deletedID := range deletedIDs {\n\t\t\t\ts.cleanupAgentRecursive(deletedID)\n\t\t\t}\n\n\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"agent_id\": id}\n\n\t\t\t// Broadcast for each deleted agent (recursive)\n\t\t\tfor _, deletedID := range deletedIDs {\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":     \"agent_deleted\",\n\t\t\t\t\t\"agent_id\": deletedID,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\tcase \"toggle_skill\":\n\t\tname, _ := req.Payload[\"name\"].(string)\n\t\t// Placeholder for toggle logic\n\t\tresp.Payload = map[string]string{\"status\": \"toggled\", \"name\": name}\n\n\tcase \"get_config\":\n\t\tcfg, _ := config.LoadConfig()\n\t\tresp.Payload = s.formatConfigResponse(cfg)\n\n\tcase \"fetch_models\":\n\t\tproviderName, _ := req.Payload[\"provider\"].(string)\n\t\tif providerName == \"\" {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = \"provider name required\"\n\t\t\ts.safeWriteJSON(conn, resp)\n\t\t\treturn\n\t\t}\n\n\t\tprov, err := s.createProvider(providerName)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t\ts.safeWriteJSON(conn, resp)\n\t\t\treturn\n\t\t}\n\n\t\tmodels, err := prov.ListModels(context.Background())\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]interface{}{\n\t\t\t\t\"models\": models,\n\t\t\t}\n\t\t}\n\n\tcase \"update_config\":\n\t\tupdates, _ := req.Payload[\"updates\"].(map[string]interface{})\n\t\terr := s.performConfigUpdate(updates)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"updated\"}\n\t\t}\n\n\tcase \"list_skills\":\n\t\tworkspacePath := getProgramDataPath()\n\t\tloader := utils.NewSkillLoader(workspacePath)\n\t\tskills, err := loader.LoadSkills()\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]interface{}{\"skills\": skills, \"total\": len(skills)}\n\t\t}\n\n\tcase \"list_triggers\":\n\t\ttriggers := s.triggerManager.ListAvailableTriggers()\n\t\tresp.Payload = map[string]interface{}{\"triggers\": triggers}\n\n\tcase \"list_agent_subscriptions\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tsubs, err := s.db.ListTriggerSubscriptions(agentID)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]interface{}{\"subscriptions\": subs}\n\t\t}\n\n\tcase \"save_trigger_subscription\":\n\t\tvar sub types.TriggerSubscription\n\t\tb, _ := json.Marshal(req.Payload[\"subscription\"])\n\t\tjson.Unmarshal(b, &sub)\n\t\tif err := s.db.SaveTriggerSubscription(sub); err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"saved\", \"id\": sub.ID}\n\t\t}\n\n\tcase \"delete_trigger_subscription\":\n\t\tid, _ := req.Payload[\"id\"].(string)\n\t\tif err := s.db.DeleteTriggerSubscription(id); err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\"}\n\t\t}\n\n\tcase \"delete_trigger\":\n\t\tid, _ := req.Payload[\"id\"].(string)\n\t\ts.triggerManager.Unregister(id)\n\t\t// Also delete from disk if it's a script trigger\n\t\ttriggerDir := filepath.Join(config.GetConfigDir(), \"triggers\", id)\n\t\tif _, err := os.Stat(triggerDir); err == nil {\n\t\t\tos.RemoveAll(triggerDir)\n\t\t}\n\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"id\": id}\n\n\tcase \"rename_trigger\":\n\t\tid, _ := req.Payload[\"id\"].(string)\n\t\tnewName, _ := req.Payload[\"new_name\"].(string)\n\t\t// This is tricky because we'd need to reload the trigger.\n\t\t// For now, let's just rename on disk if it exists.\n\t\toldDir := filepath.Join(config.GetConfigDir(), \"triggers\", id)\n\t\tnewDir := filepath.Join(config.GetConfigDir(), \"triggers\", newName)\n\t\tif _, err := os.Stat(oldDir); err == nil {\n\t\t\tos.Rename(oldDir, newDir)\n\t\t\t// TODO: Reload trigger manager\n\t\t}\n\t\tresp.Payload = map[string]string{\"status\": \"renamed\", \"id\": id, \"new_name\": newName}\n\n\tcase \"delete_skill\":\n\t\tname, _ := req.Payload[\"name\"].(string)\n\t\tworkspacePath := getProgramDataPath()\n\t\tskillDir := filepath.Join(workspacePath, \"skills\", name)\n\t\tif _, err := os.Stat(skillDir); err == nil {\n\t\t\tos.RemoveAll(skillDir)\n\t\t} else {\n\t\t\t// Try single file if directory doesn't exist\n\t\t\tskillFile := filepath.Join(workspacePath, \"skills\", name+\".md\")\n\t\t\tos.Remove(skillFile)\n\t\t}\n\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"name\": name}\n\n\tcase \"rename_skill\":\n\t\tname, _ := req.Payload[\"name\"].(string)\n\t\tnewName, _ := req.Payload[\"new_name\"].(string)\n\t\tworkspacePath := getProgramDataPath()\n\t\toldDir := filepath.Join(workspacePath, \"skills\", name)\n\t\tnewDir := filepath.Join(workspacePath, \"skills\", newName)\n\t\tif _, err := os.Stat(oldDir); err == nil {\n\t\t\tos.Rename(oldDir, newDir)\n\t\t}\n\t\tresp.Payload = map[string]string{\"status\": \"renamed\", \"name\": name, \"new_name\": newName}\n\n\tcase \"restore_default_skills\":\n\t\tbackupPath, err := config.RestoreDefaultSkills()\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tpayload := map[string]string{\"status\": \"restored\"}\n\t\t\tif backupPath != \"\" {\n\t\t\t\tpayload[\"backup_path\"] = backupPath\n\t\t\t}\n\t\t\tresp.Payload = payload\n\t\t}\n\n\tcase \"restore_default_triggers\":\n\t\tbackupPath, err := config.RestoreDefaultTriggers()\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tcronEnabled, cronErr := config.IsCronTriggerEnabled()\n\t\t\tif cronErr != nil {\n\t\t\t\tslog.Warn(\"Failed to read cron trigger config after restore\", \"error\", cronErr)\n\t\t\t}\n\t\t\ts.triggerManager.Clear()\n\t\t\tif cronEnabled {\n\t\t\t\ts.scheduler = scheduler.NewScheduler(s.db, func(agentID string, prompt string) error {\n\t\t\t\t\treturn s.resumeAgent(agentID, prompt)\n\t\t\t\t})\n\t\t\t\ts.scheduler.OnEvent = func(event map[string]interface{}) {\n\t\t\t\t\ts.globalBroadcast(event)\n\t\t\t\t}\n\t\t\t\ts.triggerManager.Register(s.scheduler)\n\t\t\t} else if s.scheduler != nil {\n\t\t\t\ts.scheduler.Stop()\n\t\t\t\ts.scheduler = nil\n\t\t\t}\n\n\t\t\ttriggerDir := filepath.Join(config.GetConfigDir(), \"triggers\")\n\t\t\tloader := agent.NewTriggerLoader(triggerDir)\n\t\t\tscripts, loadErr := loader.Load()\n\t\t\tif loadErr != nil {\n\t\t\t\tslog.Warn(\"Failed to reload triggers after restore\", \"error\", loadErr)\n\t\t\t} else {\n\t\t\t\tfor _, st := range scripts {\n\t\t\t\t\ts.triggerManager.Register(st)\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.triggerManager.Start(context.Background())\n\t\t\tif s.scheduler != nil {\n\t\t\t\ts.scheduler.Start(context.Background(), func(payload types.TriggerPayload) {\n\t\t\t\t\ts.triggerManager.Emit(payload)\n\t\t\t\t})\n\t\t\t\tif err := s.scheduler.LoadTasks(); err != nil {\n\t\t\t\t\tslog.Warn(\"Failed to reload tasks after trigger restore\", \"error\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tpayload := map[string]string{\"status\": \"restored\"}\n\t\t\tif backupPath != \"\" {\n\t\t\t\tpayload[\"backup_path\"] = backupPath\n\t\t\t}\n\t\t\tresp.Payload = payload\n\t\t}\n\n\tcase \"list_tools\":\n\t\tresp.Payload = map[string]interface{}{\"tools\": s.toolRegistry.ListTools()}\n\n\tcase \"sync_skills\":\n\t\tworkspacePath := getProgramDataPath()\n\t\tloader := utils.NewSkillLoader(workspacePath)\n\t\tskills, err := loader.LoadSkills()\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]interface{}{\"synced\": len(skills), \"results\": map[string]bool{\"all\": true}}\n\t\t}\n\n\tcase \"get_usage\":\n\t\tdays := 30\n\t\tif d, ok := req.Payload[\"days\"].(float64); ok {\n\t\t\tdays = int(d)\n\t\t}\n\t\tend := time.Now().UTC()\n\t\tstart := end.AddDate(0, 0, -days)\n\t\ttotals, _ := s.db.GetUsageTotals(start, end)\n\t\tbyModel, _ := s.db.GetUsageSummary(start, end)\n\t\tbyAgent, _ := s.db.GetUsageByAgentSummary(start, end)\n\t\tbyTool, _ := s.db.GetUsageByToolSummary(start, end)\n\t\tbySkill, _ := s.db.GetUsageBySkillSummary(start, end)\n\t\tdaily, _ := s.db.GetDailyUsage(days)\n\t\tresp.Payload = map[string]interface{}{\n\t\t\t\"totals\":   totals,\n\t\t\t\"by_model\": byModel,\n\t\t\t\"by_agent\": byAgent,\n\t\t\t\"by_tool\":  byTool,\n\t\t\t\"by_skill\": bySkill,\n\t\t\t\"daily\":    daily,\n\t\t}\n\n\tcase \"get_usage_history\":\n\t\tlimit := 50\n\t\toffset := 0\n\t\tif l, ok := req.Payload[\"limit\"].(float64); ok {\n\t\t\tlimit = int(l)\n\t\t}\n\t\tif o, ok := req.Payload[\"offset\"].(float64); ok {\n\t\t\toffset = int(o)\n\t\t}\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tprovider, _ := req.Payload[\"provider\"].(string)\n\t\tmodel, _ := req.Payload[\"model\"].(string)\n\n\t\trecords, err := s.db.GetUsageHistory(limit, offset, agentID, provider, model)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]interface{}{\n\t\t\t\t\"records\": records,\n\t\t\t\t\"limit\":   limit,\n\t\t\t\t\"offset\":  offset,\n\t\t\t}\n\t\t}\n\n\tcase \"get_api_keys\":\n\t\tcfg, _ := config.LoadConfig()\n\t\tproviders := []string{\"openrouter\", \"anthropic\", \"openai\", \"gemini\", \"ollama\", \"lmstudio\"}\n\t\tif cfg != nil && cfg.CustomProviders != nil {\n\t\t\tfor name := range cfg.CustomProviders {\n\t\t\t\tproviders = append(providers, name)\n\t\t\t}\n\t\t}\n\t\tresults := make([]map[string]interface{}, 0)\n\t\tfor _, p := range providers {\n\t\t\tvar configured bool\n\t\t\tif config.MockMode {\n\t\t\t\t// In mock mode, never access keychain or env vars - always return false\n\t\t\t\tconfigured = false\n\t\t\t} else {\n\t\t\t\tswitch p {\n\t\t\t\tcase \"ollama\":\n\t\t\t\t\tconfigured = true // Local provider typically does not require a key\n\t\t\t\tcase \"lmstudio\":\n\t\t\t\t\tconfigured = true // Local provider typically does not require a key\n\t\t\t\tdefault:\n\t\t\t\t\tconfigured = config.GetKeychainPassword(p+\"-api-key\") != \"\"\n\t\t\t\t\tif !configured && cfg != nil && cfg.CustomProviders != nil {\n\t\t\t\t\t\tif cp, ok := cfg.CustomProviders[p]; ok {\n\t\t\t\t\t\t\tconfigured = cp.BaseURL != \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tenabled := false\n\t\t\tif cfg != nil && cfg.Providers != nil {\n\t\t\t\tif pc, ok := cfg.Providers[p]; ok && pc.Enabled != nil {\n\t\t\t\t\tenabled = *pc.Enabled\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresults = append(results, map[string]interface{}{\n\t\t\t\t\"provider\":   p,\n\t\t\t\t\"configured\": configured,\n\t\t\t\t\"enabled\":    enabled,\n\t\t\t})\n\t\t}\n\t\tresp.Payload = results\n\n\tcase \"set_api_key\":\n\t\tprovider, _ := req.Payload[\"provider\"].(string)\n\t\tkey, _ := req.Payload[\"key\"].(string)\n\t\tif config.MockMode {\n\t\t\t// In mock mode, don't actually store API keys - just return success\n\t\t\tslog.Debug(\"Mock mode: skipping API key storage\", \"provider\", provider)\n\t\t\tresp.Payload = map[string]string{\"status\": \"stored\", \"provider\": provider}\n\t\t} else {\n\t\t\terr := config.SetKeychainPassword(provider+\"-api-key\", key)\n\t\t\tif err != nil {\n\t\t\t\tresp.Status = \"error\"\n\t\t\t\tresp.Error = err.Error()\n\t\t\t} else {\n\t\t\t\tresp.Payload = map[string]string{\"status\": \"stored\", \"provider\": provider}\n\t\t\t}\n\t\t}\n\n\tcase \"remove_api_key\":\n\t\tprovider, _ := req.Payload[\"provider\"].(string)\n\t\tif config.MockMode {\n\t\t\t// In mock mode, don't actually delete API keys - just return success\n\t\t\tslog.Debug(\"Mock mode: skipping API key deletion\", \"provider\", provider)\n\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"provider\": provider}\n\t\t} else {\n\t\t\terr := config.DeleteKeychainPassword(provider + \"-api-key\")\n\t\t\tif err != nil {\n\t\t\t\tresp.Status = \"error\"\n\t\t\t\tresp.Error = err.Error()\n\t\t\t} else {\n\t\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"provider\": provider}\n\t\t\t}\n\t\t}\n\n\tcase \"approve_tool\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\ttoolCallID, _ := req.Payload[\"tool_call_id\"].(string)\n\t\tdecision, _ := req.Payload[\"decision\"].(string) // \"allow\", \"reject\", \"always_allow\"\n\t\ttoolName, _ := req.Payload[\"tool_name\"].(string)\n\t\tpattern, _ := req.Payload[\"pattern\"].(string) // Only for \"always_allow\"\n\n\t\tif decision == \"always_allow\" && pattern != \"\" && toolName != \"\" {\n\t\t\ts.db.SaveToolApproval(toolName, pattern)\n\t\t}\n\n\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t\ts.safeWriteJSON(conn, resp)\n\t\t\treturn\n\t\t}\n\n\t\tif sa != nil {\n\t\t\tsa.ApproveTool(toolCallID, decision)\n\t\t\tresp.Payload = map[string]string{\"status\": \"processed\"}\n\n\t\t\t// If the agent is not running, we need to resume it so it can process the approval\n\t\t\t// (or at least start a new turn if the old loop was lost due to restart)\n\t\t\tif !sa.IsRunning() {\n\t\t\t\tslog.Info(\"Resuming agent after tool approval (agent was not running)\", \"agent_id\", agentID)\n\t\t\t\ts.resumeAgent(agentID, \"\")\n\t\t\t}\n\n\t\t\t// Log the resolution so the frontend can display the result in the history\n\t\t\tpayload := map[string]interface{}{\n\t\t\t\t\"tool_call_id\": toolCallID,\n\t\t\t\t\"tool\":         toolName,\n\t\t\t\t\"decision\":     decision,\n\t\t\t}\n\t\t\ts.db.AppendAgentLog(agentID, \"tool_approval_resolved\", payload)\n\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":       \"execution_log\",\n\t\t\t\t\"agent_id\":   agentID,\n\t\t\t\t\"event_type\": \"tool_approval_resolved\",\n\t\t\t\t\"payload\":    payload,\n\t\t\t})\n\t\t} else {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = \"Agent not found\"\n\t\t}\n\n\tcase \"list_tool_approvals\":\n\t\tapprovals, err := s.db.ListToolApprovals()\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = approvals\n\t\t}\n\n\tcase \"delete_tool_approval\":\n\t\tid, _ := req.Payload[\"id\"].(string)\n\t\tif err := s.db.DeleteToolApproval(id); err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\"}\n\t\t}\n\n\tcase \"list_vault_secrets\":\n\t\tsecrets, err := s.db.ListVaultSecrets()\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = secrets\n\t\t}\n\n\tcase \"set_vault_secret\":\n\t\tname, _ := req.Payload[\"name\"].(string)\n\t\tvalue, _ := req.Payload[\"value\"].(string)\n\t\tif name == \"\" || value == \"\" {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = \"name and value are required\"\n\t\t} else {\n\t\t\tif config.MockMode {\n\t\t\t\tslog.Debug(\"Mock mode: storing secret in memory\", \"name\", name)\n\t\t\t\tconfig.SetMockVaultSecret(name, value)\n\t\t\t\terr := s.db.SaveVaultSecretName(name)\n\t\t\t\tif err != nil {\n\t\t\t\t\tresp.Status = \"error\"\n\t\t\t\t\tresp.Error = err.Error()\n\t\t\t\t} else {\n\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"stored\", \"name\": name}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr := config.SetKeychainPassword(\"vault-secret-\"+name, value)\n\t\t\t\tif err != nil {\n\t\t\t\t\tresp.Status = \"error\"\n\t\t\t\t\tresp.Error = err.Error()\n\t\t\t\t} else {\n\t\t\t\t\terr = s.db.SaveVaultSecretName(name)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tresp.Status = \"error\"\n\t\t\t\t\t\tresp.Error = err.Error()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"stored\", \"name\": name}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Notify any agents waiting for this secret\n\t\t\ts.mu.Lock()\n\t\t\tfor _, sa := range s.statefulAgents {\n\t\t\t\tsa.SubmitSecret(name)\n\t\t\t}\n\t\t\ts.mu.Unlock()\n\t\t}\n\n\tcase \"remove_vault_secret\":\n\t\tname, _ := req.Payload[\"name\"].(string)\n\t\tif name == \"\" {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = \"name is required\"\n\t\t} else {\n\t\t\tif config.MockMode {\n\t\t\t\tslog.Debug(\"Mock mode: skipping vault secret deletion\", \"name\", name)\n\t\t\t\terr := s.db.DeleteVaultSecretName(name)\n\t\t\t\tif err != nil {\n\t\t\t\t\tresp.Status = \"error\"\n\t\t\t\t\tresp.Error = err.Error()\n\t\t\t\t} else {\n\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"name\": name}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr := config.DeleteKeychainPassword(\"vault-secret-\" + name)\n\t\t\t\tif err != nil {\n\t\t\t\t\tresp.Status = \"error\"\n\t\t\t\t\tresp.Error = err.Error()\n\t\t\t\t} else {\n\t\t\t\t\terr = s.db.DeleteVaultSecretName(name)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tresp.Status = \"error\"\n\t\t\t\t\t\tresp.Error = err.Error()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"deleted\", \"name\": name}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tcase \"get_version\":\n\t\tresp.Payload = map[string]string{\"version\": \"0.1.0\"}\n\n\tcase \"list_workspace\":\n\t\tresp.Payload = map[string]string{\"path\": getProgramDataPath()}\n\n\tcase \"open_workspace\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tpath := s.getAgentWorkspacePath(agentID)\n\t\t// Ensure it exists\n\t\tos.MkdirAll(path, 0755)\n\n\t\tvar err error\n\t\tif runtime.GOOS == \"darwin\" {\n\t\t\terr = exec.Command(\"open\", path).Run()\n\t\t} else if runtime.GOOS == \"windows\" {\n\t\t\terr = exec.Command(\"explorer\", path).Run()\n\t\t} else {\n\t\t\terr = exec.Command(\"xdg-open\", path).Run()\n\t\t}\n\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"opened\", \"path\": path}\n\t\t}\n\n\tcase \"open_folder\":\n\t\tname, _ := req.Payload[\"name\"].(string)\n\t\tif name == \"\" {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = \"folder name is required\"\n\t\t\tbreak\n\t\t}\n\n\t\tpath := filepath.Join(config.GetConfigDir(), name)\n\t\t// Ensure it exists\n\t\tos.MkdirAll(path, 0755)\n\n\t\tvar err error\n\t\tif runtime.GOOS == \"darwin\" {\n\t\t\terr = exec.Command(\"open\", path).Run()\n\t\t} else if runtime.GOOS == \"windows\" {\n\t\t\terr = exec.Command(\"explorer\", path).Run()\n\t\t} else {\n\t\t\terr = exec.Command(\"xdg-open\", path).Run()\n\t\t}\n\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"opened\", \"path\": path}\n\t\t}\n\n\tcase \"open_path\":\n\t\tpath, _ := req.Payload[\"path\"].(string)\n\t\tif path == \"\" {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = \"path is required\"\n\t\t\tbreak\n\t\t}\n\n\t\tvar err error\n\t\tif runtime.GOOS == \"darwin\" {\n\t\t\terr = exec.Command(\"open\", path).Run()\n\t\t} else if runtime.GOOS == \"windows\" {\n\t\t\terr = exec.Command(\"explorer\", path).Run()\n\t\t} else {\n\t\t\terr = exec.Command(\"xdg-open\", path).Run()\n\t\t}\n\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\tresp.Payload = map[string]string{\"status\": \"opened\", \"path\": path}\n\t\t}\n\n\tcase \"get_status\":\n\t\t// Copy auth status for response\n\t\ts.mu.RLock()\n\t\tauth := make(map[string]string)\n\t\tfor k, v := range s.authStatus {\n\t\t\tauth[k] = v\n\t\t}\n\t\tcli := make(map[string]string)\n\t\tfor k, v := range s.cliStatus {\n\t\t\tcli[k] = v\n\t\t}\n\t\ts.mu.RUnlock()\n\n\t\tresp.Payload = map[string]interface{}{\n\t\t\t\"status\": \"ok\",\n\t\t\t\"components\": map[string]string{\n\t\t\t\t\"database\": \"ok\",\n\t\t\t\t\"server\":   \"ok\",\n\t\t\t\t\"claude\":   cli[\"claude\"],\n\t\t\t\t\"codex\":    cli[\"codex\"],\n\t\t\t},\n\t\t\t\"auth\": auth,\n\t\t\t\"browser\": map[string]interface{}{\n\t\t\t\t\"available_engines\": utils.GetBrowserManager().GetAvailableEngines(),\n\t\t\t},\n\t\t}\n\n\tcase \"login_cli\":\n\t\tcli, _ := req.Payload[\"cli\"].(string)\n\t\tvar err error\n\t\tif cli == \"claude\" {\n\t\t\tif runtime.GOOS == \"darwin\" {\n\t\t\t\t// On macOS, open a new Terminal window to run the login\n\t\t\t\tscript := `tell application \"Terminal\" to do script \"claude\"`\n\t\t\t\terr = exec.Command(\"osascript\", \"-e\", script).Run()\n\t\t\t} else {\n\t\t\t\terr = fmt.Errorf(\"login trigger not supported on this OS\")\n\t\t\t}\n\t\t} else if cli == \"codex\" {\n\t\t\tif runtime.GOOS == \"darwin\" {\n\t\t\t\tscript := `tell application \"Terminal\" to do script \"codex login\"`\n\t\t\t\terr = exec.Command(\"osascript\", \"-e\", script).Run()\n\t\t\t} else {\n\t\t\t\terr = fmt.Errorf(\"login trigger not supported on this OS\")\n\t\t\t}\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"unknown CLI: %s\", cli)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\t// Clear auth cache to force re-check\n\t\t\ts.mu.Lock()\n\t\t\ts.lastAuthCheck = time.Time{}\n\t\t\ts.mu.Unlock()\n\t\t\tresp.Payload = map[string]string{\"status\": \"triggered\"}\n\t\t}\n\n\tcase \"install_cli\":\n\t\tcli, _ := req.Payload[\"cli\"].(string)\n\t\tif cli == \"claude\" {\n\t\t\terr := runInstall(\"npm\", \"install\", \"-g\", \"@anthropic-ai/claude-code\")\n\t\t\tif err != nil {\n\t\t\t\tresp.Status = \"error\"\n\t\t\t\tresp.Error = err.Error()\n\t\t\t}\n\t\t} else if cli == \"codex\" {\n\t\t\t// Replace with actual codex install command when known, assuming npm for now\n\t\t\terr := runInstall(\"npm\", \"install\", \"-g\", \"codex-cli\")\n\t\t\tif err != nil {\n\t\t\t\tresp.Status = \"error\"\n\t\t\t\tresp.Error = err.Error()\n\t\t\t}\n\t\t} else {\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = \"Unknown CLI: \" + cli\n\t\t}\n\n\tcase \"clear_usage\":\n\t\ts.db.ClearUsage()\n\t\tresp.Payload = map[string]string{\"status\": \"cleared\"}\n\n\tcase \"clear_conversation\":\n\t\tagentID, _ := req.Payload[\"agent_id\"].(string)\n\t\tslog.Info(\"Clear conversation requested\", \"agent_id\", agentID)\n\n\t\tsa, err := s.getOrCreateStatefulAgent(agentID)\n\t\tif err != nil {\n\t\t\tslog.Error(\"Agent not found for clear conversation\", \"agent_id\", agentID, \"error\", err)\n\t\t\tresp.Status = \"error\"\n\t\t\tresp.Error = err.Error()\n\t\t} else {\n\t\t\t// 0. Stop the agent loop completely if running\n\t\t\tif sa.IsRunning() {\n\t\t\t\tslog.Info(\"Stopping agent for conversation clear\", \"agent_id\", agentID)\n\t\t\t\tsa.Cancel()\n\n\t\t\t\t// Wait for the loop to actually exit (up to 2 seconds)\n\t\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t\tif !sa.IsRunning() {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\ttime.Sleep(200 * time.Millisecond)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Also stop any active scope creation\n\t\t\tif cancel, ok := s.proposing.Load(agentID); ok {\n\t\t\t\tslog.Info(\"Cancelling active scope creation for conversation clear\", \"agent_id\", agentID)\n\t\t\t\tcancel.(context.CancelFunc)()\n\t\t\t\ts.proposing.Delete(agentID)\n\t\t\t}\n\n\t\t\t// Wait a small amount of time for any pending DB operations to finish\n\t\t\ttime.Sleep(200 * time.Millisecond)\n\n\t\t\t// 1. Clear files and internal state\n\t\t\tarchiveResults, err := sa.ClearConversation(context.Background())\n\t\t\tif err != nil {\n\t\t\t\tslog.Error(\"Failed to clear conversation files\", \"agent_id\", agentID, \"error\", err)\n\t\t\t\tresp.Status = \"error\"\n\t\t\t\tresp.Error = \"Failed to clear conversation files: \" + err.Error()\n\t\t\t} else {\n\t\t\t\t// 2. Clear database logs and current scope\n\t\t\t\tif err := s.db.ClearAgentLogs(agentID); err != nil {\n\t\t\t\t\tslog.Error(\"Failed to clear conversation logs in DB\", \"agent_id\", agentID, \"error\", err)\n\t\t\t\t\tresp.Status = \"error\"\n\t\t\t\t\tresp.Error = \"Failed to clear conversation logs: \" + err.Error()\n\t\t\t\t} else {\n\t\t\t\t\tif err := s.db.ClearAgentScope(agentID); err != nil {\n\t\t\t\t\t\tslog.Error(\"Failed to clear agent scope in DB\", \"agent_id\", agentID, \"error\", err)\n\t\t\t\t\t}\n\t\t\t\t\tslog.Info(\"Conversation logs cleared successfully\", \"agent_id\", agentID)\n\n\t\t\t\t\t// 3. Reset context usage\n\t\t\t\t\ts.db.UpdateAgentContextUsage(agentID, 0, sa.MaxContextTokens)\n\n\t\t\t\t\t// 4. Reset agent state to idle\n\t\t\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateIdle, nil)\n\t\t\t\t\tsa.SetState(types.AgentStateIdle)\n\n\t\t\t\t\t// 5. Add a \"conversation_cleared\" log entry so the UI shows something\n\t\t\t\t\thasArchivedFiles := false\n\t\t\t\t\tlogPayload := map[string]interface{}{}\n\n\t\t\t\t\tif path, ok := archiveResults[\"archive_dir\"]; ok {\n\t\t\t\t\t\tlogPayload[\"archive_dir\"] = path\n\t\t\t\t\t}\n\t\t\t\t\tif path, ok := archiveResults[\"history_archive.md\"]; ok {\n\t\t\t\t\t\tlogPayload[\"archive_path\"] = path\n\t\t\t\t\t\tlogPayload[\"archive_file\"] = filepath.Base(path)\n\t\t\t\t\t\thasArchivedFiles = true\n\t\t\t\t\t}\n\t\t\t\t\tif path, ok := archiveResults[\"full_history.jsonl\"]; ok {\n\t\t\t\t\t\tlogPayload[\"history_path\"] = path\n\t\t\t\t\t\tlogPayload[\"full_history\"] = filepath.Base(path)\n\t\t\t\t\t\thasArchivedFiles = true\n\t\t\t\t\t}\n\n\t\t\t\t\tif hasArchivedFiles {\n\t\t\t\t\t\tlogPayload[\"message\"] = \"Conversation history has been cleared and archived to the workspace.\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogPayload[\"message\"] = \"Conversation history has been cleared. (No previous history files were found to archive.)\"\n\t\t\t\t\t}\n\t\t\t\t\ts.db.AppendAgentLog(agentID, \"conversation_cleared\", logPayload)\n\n\t\t\t\t\tresp.Payload = map[string]string{\"status\": \"cleared\", \"agent_id\": agentID}\n\n\t\t\t\t\t// 6. Broadcast updates\n\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\t\"type\":     \"conversation_cleared\",\n\t\t\t\t\t\t\"agent_id\": agentID,\n\t\t\t\t\t})\n\n\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\t\"type\":     \"scope_approved\",\n\t\t\t\t\t\t\"agent_id\": agentID,\n\t\t\t\t\t\t\"scope_id\": \"\",\n\t\t\t\t\t})\n\n\t\t\t\t\t// Refresh logs for all clients\n\t\t\t\t\tlogs, _ := s.db.ListAgentLogs(agentID)\n\t\t\t\t\tslog.Info(\"Broadcasting logs_updated\", \"agent_id\", agentID, \"count\", len(logs))\n\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\t\"type\":     \"logs_updated\",\n\t\t\t\t\t\t\"agent_id\": agentID,\n\t\t\t\t\t\t\"logs\":     logs,\n\t\t\t\t\t})\n\n\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\t\"type\":               \"agent_context_updated\",\n\t\t\t\t\t\t\"agent_id\":           agentID,\n\t\t\t\t\t\t\"context_tokens\":     0,\n\t\t\t\t\t\t\"max_context_tokens\": sa.MaxContextTokens,\n\t\t\t\t\t})\n\n\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\t\"type\":         \"agent_state_changed\",\n\t\t\t\t\t\t\"agent_id\":     agentID,\n\t\t\t\t\t\t\"new_state\":    types.AgentStateIdle,\n\t\t\t\t\t\t\"error_detail\": nil,\n\t\t\t\t\t})\n\n\t\t\t\t\t// 7. Broadcast agent updated to clear scope in UI\n\t\t\t\t\tupdatedAgent, _ := s.db.GetAgent(agentID)\n\t\t\t\t\tif updatedAgent != nil {\n\t\t\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\t\t\"type\":     \"agent_updated\",\n\t\t\t\t\t\t\t\"agent_id\": agentID,\n\t\t\t\t\t\t\t\"agent\":    updatedAgent,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tcase \"get_system_prompt\":\n\t\tprompt, _ := s.db.GetActiveSystemPrompt()\n\t\tresp.Payload = map[string]interface{}{\n\t\t\t\"content\":   prompt,\n\t\t\t\"is_custom\": false,\n\t\t\t\"version\":   nil,\n\t\t}\n\n\tcase \"get_system_prompt_versions\":\n\t\tprompt, _ := s.db.GetActiveSystemPrompt()\n\t\tresp.Payload = map[string]interface{}{\n\t\t\t\"versions\":        []interface{}{},\n\t\t\t\"default_content\": prompt,\n\t\t}\n\n\tcase \"update_system_prompt\":\n\t\t// Placeholder for update system prompt\n\t\tresp.Payload = map[string]interface{}{\"status\": \"updated\"}\n\n\tcase \"revert_system_prompt\":\n\t\t// Placeholder for revert system prompt\n\t\tresp.Payload = map[string]interface{}{\"status\": \"reverted\"}\n\n\tcase \"reset_system_prompt\":\n\t\t// Placeholder for reset system prompt\n\t\tresp.Payload = map[string]string{\"status\": \"reset\"}\n\n\tdefault:\n\t\tresp.Status = \"error\"\n\t\tresp.Error = \"Unknown request type: \" + req.Type\n\t}\n\n\ts.safeWriteJSON(conn, resp)\n}\n","numLines":1579,"startLine":1,"totalLines":1579}}}
{"parentUuid":"a73c1692-0bac-4e3f-99d7-00242f749f3a","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KYNVg8hgqZHnEfkSxQKWnq","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the API file and examine an existing provider like OpenAI or OpenRouter for reference. I also want to see if there are any reference implementations for OAuth:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34644,"cache_creation_input_tokens":22642,"cache_read_input_tokens":35240,"cache_creation":{"ephemeral_5m_input_tokens":22642,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWkRQUmLPxXBhay2UqQPR","type":"assistant","uuid":"1d830386-786a-4dbb-9cbe-94abe6a8dfcd","timestamp":"2026-01-03T12:10:58.568Z"}
{"parentUuid":"1d830386-786a-4dbb-9cbe-94abe6a8dfcd","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KYNVg8hgqZHnEfkSxQKWnq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01G9gjvgzhfCzy2vHg8ZTjtE","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/api.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34644,"cache_creation_input_tokens":22642,"cache_read_input_tokens":35240,"cache_creation":{"ephemeral_5m_input_tokens":22642,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWkRQUmLPxXBhay2UqQPR","type":"assistant","uuid":"4be56340-130b-47fc-8608-99b949d846fa","timestamp":"2026-01-03T12:10:59.450Z"}
{"parentUuid":"4be56340-130b-47fc-8608-99b949d846fa","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KYNVg8hgqZHnEfkSxQKWnq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FU75CN5sMoDKb69smqCmEw","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openai.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34644,"cache_creation_input_tokens":22642,"cache_read_input_tokens":35240,"cache_creation":{"ephemeral_5m_input_tokens":22642,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWkRQUmLPxXBhay2UqQPR","type":"assistant","uuid":"42479275-f651-4ba1-bc7f-d376c885eafd","timestamp":"2026-01-03T12:11:00.231Z"}
{"parentUuid":"42479275-f651-4ba1-bc7f-d376c885eafd","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KYNVg8hgqZHnEfkSxQKWnq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SBou1GifFkPbcR9KWSpLMe","name":"Bash","input":{"command":"cat ~/.claude/oauth_token.json 2>/dev/null || echo \"File not found or empty\"","description":"Check Claude OAuth token file format"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34644,"cache_creation_input_tokens":22642,"cache_read_input_tokens":35240,"cache_creation":{"ephemeral_5m_input_tokens":22642,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWkRQUmLPxXBhay2UqQPR","type":"assistant","uuid":"fe2fd364-48fa-42c3-ab5f-58ef858633d6","timestamp":"2026-01-03T12:11:01.477Z"}
{"parentUuid":"fe2fd364-48fa-42c3-ab5f-58ef858633d6","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G9gjvgzhfCzy2vHg8ZTjtE","type":"tool_result","content":"     1import { globalWS } from './websocket';\n     2\n     3export interface Attachment {\n     4  id: string;\n     5  type: 'image' | 'file';\n     6  name: string;\n     7  mimeType: string;\n     8  data: string;\n     9  size: number;\n    10  previewUrl?: string;\n    11  path?: string;\n    12}\n    13\n    14export interface ScopeDocument {\n    15  id: string;\n    16  agent_id: string;\n    17  version: number;\n    18  frontmatter: {\n    19    agent_id: string;\n    20    version: number;\n    21    permissions: {\n    22      tools: string[];\n    23      skills: string[];\n    24    };\n    25    resource_limits: {\n    26      max_loops: number;\n    27    };\n    28  };\n    29  content: string;\n    30  created_at: string;\n    31  approved_at?: string;\n    32}\n    33\n    34export interface AgentTask {\n    35  id: string;\n    36  parent_agent_id: string;\n    37  target_agent_id?: string;\n    38  trigger_at?: string;\n    39  recurrence: string;\n    40  task_prompt: string;\n    41  is_self: boolean;\n    42  status: 'pending' | 'running' | 'completed' | 'failed';\n    43  created_at: string;\n    44  last_run_at?: string;\n    45  last_result?: string;\n    46  run_count: number;\n    47  next_run_at?: string;\n    48}\n    49\n    50export interface Agent {\n    51  id: string;\n    52  parent_id?: string;\n    53  type: 'standard';\n    54  name: string;\n    55  state: 'idle' | 'running' | 'waiting' | 'error' | 'completed' | 'awaiting_approval' | 'paused' | 'awaiting_secret';\n    56  current_scope_id: string;\n    57  current_scope?: ScopeDocument;\n    58  initial_prompt?: string;\n    59  plan_enabled: boolean;\n    60  sub_agents_enabled: boolean;\n    61  is_internal?: boolean;\n    62  error_detail?: {\n    63    category: string;\n    64    message: string;\n    65    tool_name?: string;\n    66    recoverable: boolean;\n    67  };\n    68  model_config: {\n    69    provider: string;\n    70    model: string;\n    71    temperature?: number;\n    72    max_tokens?: number;\n    73  };\n    74  context_tokens: number;\n    75  max_context_tokens: number;\n    76  is_compacting: boolean;\n    77  created_at: string;\n    78  updated_at: string;\n    79}\n    80\n    81export interface Skill {\n    82  name: string;\n    83  description: string;\n    84  path: string;\n    85  license?: string;\n    86  compatibility?: string;\n    87  metadata?: Record<string, unknown>;\n    88  allowed_tools: string[];\n    89  source?: string;\n    90  enabled?: boolean;\n    91}\n    92\n    93export interface TriggerSubscription {\n    94  id: string;\n    95  agent_id: string;\n    96  trigger_name: string;\n    97  prompt_template: string;\n    98  enabled: boolean;\n    99}\n   100\n   101export interface SkillsResponse {\n   102  skills: Skill[];\n   103  total: number;\n   104}\n   105\n   106export interface SkillFile {\n   107  name: string;\n   108  path: string;\n   109  content?: string;\n   110}\n   111\n   112export interface SkillDetail extends Skill {\n   113  content: string;\n   114  files: SkillFile[];\n   115}\n   116\n   117export interface UsageSummaryItem {\n   118  provider: string;\n   119  model: string;\n   120  total_requests: number;\n   121  total_input_tokens: number;\n   122  total_output_tokens: number;\n   123  total_tokens: number;\n   124  total_cost: number | null;\n   125}\n   126\n   127export interface UsageAgentSummaryItem {\n   128  agent_id: string;\n   129  agent_name: string;\n   130  total_requests: number;\n   131  total_input_tokens: number;\n   132  total_output_tokens: number;\n   133  total_tokens: number;\n   134  total_cost: number | null;\n   135}\n   136\n   137export interface UsageToolSummaryItem {\n   138  tool: string;\n   139  total_calls: number;\n   140  total_volume_tk: number;\n   141}\n   142\n   143export interface UsageSkillSummaryItem {\n   144  skill: string;\n   145  total_calls: number;\n   146  total_volume_tk: number;\n   147}\n   148\n   149export interface UsageTotals {\n   150  total_requests: number;\n   151  total_input_tokens: number;\n   152  total_output_tokens: number;\n   153  total_tokens: number;\n   154  total_cost: number | null;\n   155}\n   156\n   157export interface DailyUsage {\n   158  date: string;\n   159  input_tokens: number;\n   160  output_tokens: number;\n   161  total_tokens: number;\n   162  cost: number | null;\n   163  requests: number;\n   164}\n   165\n   166export interface UsageResponse {\n   167  totals: UsageTotals;\n   168  by_model: UsageSummaryItem[];\n   169  by_agent: UsageAgentSummaryItem[];\n   170  by_tool: UsageToolSummaryItem[];\n   171  by_skill: UsageSkillSummaryItem[];\n   172  daily: DailyUsage[];\n   173}\n   174\n   175export interface ProcessedMessage {\n   176  id: string;\n   177  role: 'user' | 'assistant' | 'system' | 'tool';\n   178  content: string;\n   179  created_at: string;\n   180  segments?: any[];\n   181  tool_calls?: any[];\n   182  timestamp?: number;\n   183  attachments?: any[];\n   184}\n   185\n   186export interface Config {\n   187  ui?: {\n   188    theme?: string;\n   189    show_resources?: boolean;\n   190    hotkeys?: Record<string, string>;\n   191  };\n   192  inference?: {\n   193    chat?: {\n   194      provider: string;\n   195      model: string;\n   196    };\n   197  };\n   198  sub_agent?: {\n   199    enabled: boolean;\n   200  };\n   201  agent?: {\n   202    auto_compaction_enabled: boolean;\n   203  };\n   204  custom_providers?: Record<string, { base_url: string }>;\n   205  available_models?: Record<string, Record<string, string[]>>;\n   206  model_pricing?: Record<string, Record<string, Record<string, { prompt: number; completion: number }>>>;\n   207  [key: string]: any;\n   208}\n   209\n   210export interface SystemStatus {\n   211  status: 'ok' | 'degraded' | 'error';\n   212  components: Record<string, string>;\n   213  auth?: Record<string, string>;\n   214  browser?: {\n   215    available_engines: string[];\n   216  };\n   217}\n   218\n   219export interface VaultSecret {\n   220  name: string;\n   221  created_at: string;\n   222}\n   223\n   224export interface Trigger {\n   225  id: string;\n   226  type: string;\n   227  description?: string;\n   228  enabled?: boolean;\n   229}\n   230\n   231export interface TriggersResponse {\n   232  triggers: string[];\n   233}\n   234\n   235export const api = {\n   236  // Agents\n   237  listAgents: (): Promise<Agent[]> => globalWS.send({ type: 'list_agents' }),\n   238  getAgent: (id: string): Promise<Agent> => globalWS.send({ type: 'get_agent', payload: { agent_id: id } }),\n   239  createAgent: (config: { provider: string; model: string; temperature?: number; max_tokens?: number }, prompt?: string): Promise<Agent> =>\n   240    globalWS.send({ type: 'create_agent', payload: { model_config: config, initial_prompt: prompt } }),\n   241  updateAgentState: (id: string, action: string) =>\n   242    globalWS.send({ type: 'update_agent_state', payload: { agent_id: id, action } }),\n   243  openWorkspace: (agentId: string) =>\n   244    globalWS.send({ type: 'open_workspace', payload: { agent_id: agentId } }),\n   245  openFolder: (name: string) =>\n   246    globalWS.send({ type: 'open_folder', payload: { name } }),\n   247  openPath: (path: string) =>\n   248    globalWS.send({ type: 'open_path', payload: { path } }),\n   249  approveScope: (agentId: string, scopeId: string) =>\n   250    globalWS.send({ type: 'approve_scope', payload: { agent_id: agentId, scope_id: scopeId } }),\n   251  renameAgent: (id: string, name: string) =>\n   252    globalWS.send({ type: 'rename_agent', payload: { agent_id: id, name } }),\n   253  approveTool: (agentId: string, toolCallId: string, decision: 'allow' | 'reject' | 'always_allow', toolName?: string, pattern?: string) =>\n   254    globalWS.send({ type: 'approve_tool', payload: { agent_id: agentId, tool_call_id: toolCallId, decision, tool_name: toolName, pattern } }),\n   255\n   256  // Skills\n   257  getSkills: (): Promise<SkillsResponse> => globalWS.send({ type: 'list_skills' }),\n   258  getAllSkills: (): Promise<SkillsResponse> => globalWS.send({ type: 'list_skills', payload: { all: true } }),\n   259  getSkillDetail: (name: string): Promise<SkillDetail> => globalWS.send({ type: 'get_skill_detail', payload: { name } }),\n   260  syncSkills: () => globalWS.send({ type: 'sync_skills' }),\n   261  toggleSkill: (name: string) => globalWS.send({ type: 'toggle_skill', payload: { name } }),\n   262  deleteSkill: (name: string) => globalWS.send({ type: 'delete_skill', payload: { name } }),\n   263  renameSkill: (name: string, newName: string) => globalWS.send({ type: 'rename_skill', payload: { name, new_name: newName } }),\n   264\n   265  // Triggers\n   266  listTriggers: (): Promise<TriggersResponse> => globalWS.send({ type: 'list_triggers' }),\n   267  listAgentSubscriptions: (agentId: string): Promise<{ subscriptions: TriggerSubscription[] }> => globalWS.send({ type: 'list_agent_subscriptions', payload: { agent_id: agentId } }),\n   268  saveTriggerSubscription: (subscription: Partial<TriggerSubscription>): Promise<{ status: string, id: string }> => globalWS.send({ type: 'save_trigger_subscription', payload: { subscription } }),\n   269  deleteTriggerSubscription: (id: string): Promise<{ status: string }> => globalWS.send({ type: 'delete_trigger_subscription', payload: { id } }),\n   270  deleteTrigger: (id: string) => globalWS.send({ type: 'delete_trigger', payload: { id } }),\n   271  renameTrigger: (id: string, newName: string) => globalWS.send({ type: 'rename_trigger', payload: { id, new_name: newName } }),\n   272\n   273  // Status\n   274  getStatus: (): Promise<SystemStatus> => globalWS.send({ type: 'get_status' }),\n   275  getVersion: (): Promise<{ version: string }> => globalWS.send({ type: 'get_version' }),\n   276  health: (): Promise<boolean> => globalWS.send({ type: 'get_status' }).then(() => true).catch(() => false),\n   277  listWorkspace: (): Promise<{ path: string }> => globalWS.send({ type: 'list_workspace' }),\n   278  installCLI: (cli: string): Promise<any> => globalWS.send({ type: 'install_cli', payload: { cli } }),\n   279  loginCLI: (cli: string): Promise<any> => globalWS.send({ type: 'login_cli', payload: { cli } }),\n   280\n   281  // Tool Approvals\n   282  listToolApprovals: (): Promise<{ id: string, tool_name: string, pattern: string, created_at: string }[]> => globalWS.send({ type: 'list_tool_approvals' }),\n   283  deleteToolApproval: (id: string) => globalWS.send({ type: 'delete_tool_approval', payload: { id } }),\n   284\n   285  // Tasks\n   286  listTasks: (): Promise<AgentTask[]> => globalWS.send({ type: 'list_tasks' }),\n   287  deleteTask: (id: string) => globalWS.send({ type: 'delete_task', payload: { id } }),\n   288\n   289  // Vault\n   290  listVaultSecrets: (): Promise<VaultSecret[]> => globalWS.send({ type: 'list_vault_secrets' }),\n   291  setVaultSecret: (name: string, value: string) => globalWS.send({ type: 'set_vault_secret', payload: { name, value } }),\n   292  removeVaultSecret: (name: string) => globalWS.send({ type: 'remove_vault_secret', payload: { name } }),\n   293\n   294  // Config\n   295  getConfig: (): Promise<Config> => globalWS.send({ type: 'get_config' }),\n   296  updateConfig: (updates: Record<string, unknown>) => globalWS.send({ type: 'update_config', payload: { updates } }),\n   297  getApiKeys: (): Promise<{ provider: string, configured: boolean, enabled: boolean }[]> => globalWS.send({ type: 'get_api_keys' }),\n   298  setApiKey: (provider: string, key: string) => globalWS.send({ type: 'set_api_key', payload: { provider, key } }),\n   299  removeApiKey: (provider: string) => globalWS.send({ type: 'remove_api_key', payload: { provider } }),\n   300\n   301  // Usage\n   302  getUsage: (days: number = 30): Promise<UsageResponse> => globalWS.send({ type: 'get_usage', payload: { days } }),\n   303  clearUsage: () => globalWS.send({ type: 'clear_usage' }),\n   304  getProcessedHistory: (agentId: string): Promise<{ messages: ProcessedMessage[] }> => globalWS.send({ type: 'get_processed_history', payload: { agent_id: agentId } }),\n   305\n   306  // Feedback\n   307  submitFeedbackManual: (agentId: string, message: string) => globalWS.send({ type: 'submit_feedback_manual', payload: { agent_id: agentId, message } }),\n   308\n   309  // Onboarding\n   310  restartOnboarding: () => globalWS.send({ type: 'restart_onboarding' }),\n   311\n   312  // Defaults\n   313  restoreDefaultSkills: () => globalWS.send({ type: 'restore_default_skills' }),\n   314  restoreDefaultTriggers: () => globalWS.send({ type: 'restore_default_triggers' }),\n   315\n   316  // Model Discovery\n   317  fetchModels: (provider: string): Promise<{ models: string[] }> =>\n   318    globalWS.send({ type: 'fetch_models', payload: { provider } }),\n   319};\n   320\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5df11006-6797-4872-8cbc-96775ab36d89","timestamp":"2026-01-03T12:11:01.537Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/api.ts","content":"import { globalWS } from './websocket';\n\nexport interface Attachment {\n  id: string;\n  type: 'image' | 'file';\n  name: string;\n  mimeType: string;\n  data: string;\n  size: number;\n  previewUrl?: string;\n  path?: string;\n}\n\nexport interface ScopeDocument {\n  id: string;\n  agent_id: string;\n  version: number;\n  frontmatter: {\n    agent_id: string;\n    version: number;\n    permissions: {\n      tools: string[];\n      skills: string[];\n    };\n    resource_limits: {\n      max_loops: number;\n    };\n  };\n  content: string;\n  created_at: string;\n  approved_at?: string;\n}\n\nexport interface AgentTask {\n  id: string;\n  parent_agent_id: string;\n  target_agent_id?: string;\n  trigger_at?: string;\n  recurrence: string;\n  task_prompt: string;\n  is_self: boolean;\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  created_at: string;\n  last_run_at?: string;\n  last_result?: string;\n  run_count: number;\n  next_run_at?: string;\n}\n\nexport interface Agent {\n  id: string;\n  parent_id?: string;\n  type: 'standard';\n  name: string;\n  state: 'idle' | 'running' | 'waiting' | 'error' | 'completed' | 'awaiting_approval' | 'paused' | 'awaiting_secret';\n  current_scope_id: string;\n  current_scope?: ScopeDocument;\n  initial_prompt?: string;\n  plan_enabled: boolean;\n  sub_agents_enabled: boolean;\n  is_internal?: boolean;\n  error_detail?: {\n    category: string;\n    message: string;\n    tool_name?: string;\n    recoverable: boolean;\n  };\n  model_config: {\n    provider: string;\n    model: string;\n    temperature?: number;\n    max_tokens?: number;\n  };\n  context_tokens: number;\n  max_context_tokens: number;\n  is_compacting: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface Skill {\n  name: string;\n  description: string;\n  path: string;\n  license?: string;\n  compatibility?: string;\n  metadata?: Record<string, unknown>;\n  allowed_tools: string[];\n  source?: string;\n  enabled?: boolean;\n}\n\nexport interface TriggerSubscription {\n  id: string;\n  agent_id: string;\n  trigger_name: string;\n  prompt_template: string;\n  enabled: boolean;\n}\n\nexport interface SkillsResponse {\n  skills: Skill[];\n  total: number;\n}\n\nexport interface SkillFile {\n  name: string;\n  path: string;\n  content?: string;\n}\n\nexport interface SkillDetail extends Skill {\n  content: string;\n  files: SkillFile[];\n}\n\nexport interface UsageSummaryItem {\n  provider: string;\n  model: string;\n  total_requests: number;\n  total_input_tokens: number;\n  total_output_tokens: number;\n  total_tokens: number;\n  total_cost: number | null;\n}\n\nexport interface UsageAgentSummaryItem {\n  agent_id: string;\n  agent_name: string;\n  total_requests: number;\n  total_input_tokens: number;\n  total_output_tokens: number;\n  total_tokens: number;\n  total_cost: number | null;\n}\n\nexport interface UsageToolSummaryItem {\n  tool: string;\n  total_calls: number;\n  total_volume_tk: number;\n}\n\nexport interface UsageSkillSummaryItem {\n  skill: string;\n  total_calls: number;\n  total_volume_tk: number;\n}\n\nexport interface UsageTotals {\n  total_requests: number;\n  total_input_tokens: number;\n  total_output_tokens: number;\n  total_tokens: number;\n  total_cost: number | null;\n}\n\nexport interface DailyUsage {\n  date: string;\n  input_tokens: number;\n  output_tokens: number;\n  total_tokens: number;\n  cost: number | null;\n  requests: number;\n}\n\nexport interface UsageResponse {\n  totals: UsageTotals;\n  by_model: UsageSummaryItem[];\n  by_agent: UsageAgentSummaryItem[];\n  by_tool: UsageToolSummaryItem[];\n  by_skill: UsageSkillSummaryItem[];\n  daily: DailyUsage[];\n}\n\nexport interface ProcessedMessage {\n  id: string;\n  role: 'user' | 'assistant' | 'system' | 'tool';\n  content: string;\n  created_at: string;\n  segments?: any[];\n  tool_calls?: any[];\n  timestamp?: number;\n  attachments?: any[];\n}\n\nexport interface Config {\n  ui?: {\n    theme?: string;\n    show_resources?: boolean;\n    hotkeys?: Record<string, string>;\n  };\n  inference?: {\n    chat?: {\n      provider: string;\n      model: string;\n    };\n  };\n  sub_agent?: {\n    enabled: boolean;\n  };\n  agent?: {\n    auto_compaction_enabled: boolean;\n  };\n  custom_providers?: Record<string, { base_url: string }>;\n  available_models?: Record<string, Record<string, string[]>>;\n  model_pricing?: Record<string, Record<string, Record<string, { prompt: number; completion: number }>>>;\n  [key: string]: any;\n}\n\nexport interface SystemStatus {\n  status: 'ok' | 'degraded' | 'error';\n  components: Record<string, string>;\n  auth?: Record<string, string>;\n  browser?: {\n    available_engines: string[];\n  };\n}\n\nexport interface VaultSecret {\n  name: string;\n  created_at: string;\n}\n\nexport interface Trigger {\n  id: string;\n  type: string;\n  description?: string;\n  enabled?: boolean;\n}\n\nexport interface TriggersResponse {\n  triggers: string[];\n}\n\nexport const api = {\n  // Agents\n  listAgents: (): Promise<Agent[]> => globalWS.send({ type: 'list_agents' }),\n  getAgent: (id: string): Promise<Agent> => globalWS.send({ type: 'get_agent', payload: { agent_id: id } }),\n  createAgent: (config: { provider: string; model: string; temperature?: number; max_tokens?: number }, prompt?: string): Promise<Agent> =>\n    globalWS.send({ type: 'create_agent', payload: { model_config: config, initial_prompt: prompt } }),\n  updateAgentState: (id: string, action: string) =>\n    globalWS.send({ type: 'update_agent_state', payload: { agent_id: id, action } }),\n  openWorkspace: (agentId: string) =>\n    globalWS.send({ type: 'open_workspace', payload: { agent_id: agentId } }),\n  openFolder: (name: string) =>\n    globalWS.send({ type: 'open_folder', payload: { name } }),\n  openPath: (path: string) =>\n    globalWS.send({ type: 'open_path', payload: { path } }),\n  approveScope: (agentId: string, scopeId: string) =>\n    globalWS.send({ type: 'approve_scope', payload: { agent_id: agentId, scope_id: scopeId } }),\n  renameAgent: (id: string, name: string) =>\n    globalWS.send({ type: 'rename_agent', payload: { agent_id: id, name } }),\n  approveTool: (agentId: string, toolCallId: string, decision: 'allow' | 'reject' | 'always_allow', toolName?: string, pattern?: string) =>\n    globalWS.send({ type: 'approve_tool', payload: { agent_id: agentId, tool_call_id: toolCallId, decision, tool_name: toolName, pattern } }),\n\n  // Skills\n  getSkills: (): Promise<SkillsResponse> => globalWS.send({ type: 'list_skills' }),\n  getAllSkills: (): Promise<SkillsResponse> => globalWS.send({ type: 'list_skills', payload: { all: true } }),\n  getSkillDetail: (name: string): Promise<SkillDetail> => globalWS.send({ type: 'get_skill_detail', payload: { name } }),\n  syncSkills: () => globalWS.send({ type: 'sync_skills' }),\n  toggleSkill: (name: string) => globalWS.send({ type: 'toggle_skill', payload: { name } }),\n  deleteSkill: (name: string) => globalWS.send({ type: 'delete_skill', payload: { name } }),\n  renameSkill: (name: string, newName: string) => globalWS.send({ type: 'rename_skill', payload: { name, new_name: newName } }),\n\n  // Triggers\n  listTriggers: (): Promise<TriggersResponse> => globalWS.send({ type: 'list_triggers' }),\n  listAgentSubscriptions: (agentId: string): Promise<{ subscriptions: TriggerSubscription[] }> => globalWS.send({ type: 'list_agent_subscriptions', payload: { agent_id: agentId } }),\n  saveTriggerSubscription: (subscription: Partial<TriggerSubscription>): Promise<{ status: string, id: string }> => globalWS.send({ type: 'save_trigger_subscription', payload: { subscription } }),\n  deleteTriggerSubscription: (id: string): Promise<{ status: string }> => globalWS.send({ type: 'delete_trigger_subscription', payload: { id } }),\n  deleteTrigger: (id: string) => globalWS.send({ type: 'delete_trigger', payload: { id } }),\n  renameTrigger: (id: string, newName: string) => globalWS.send({ type: 'rename_trigger', payload: { id, new_name: newName } }),\n\n  // Status\n  getStatus: (): Promise<SystemStatus> => globalWS.send({ type: 'get_status' }),\n  getVersion: (): Promise<{ version: string }> => globalWS.send({ type: 'get_version' }),\n  health: (): Promise<boolean> => globalWS.send({ type: 'get_status' }).then(() => true).catch(() => false),\n  listWorkspace: (): Promise<{ path: string }> => globalWS.send({ type: 'list_workspace' }),\n  installCLI: (cli: string): Promise<any> => globalWS.send({ type: 'install_cli', payload: { cli } }),\n  loginCLI: (cli: string): Promise<any> => globalWS.send({ type: 'login_cli', payload: { cli } }),\n\n  // Tool Approvals\n  listToolApprovals: (): Promise<{ id: string, tool_name: string, pattern: string, created_at: string }[]> => globalWS.send({ type: 'list_tool_approvals' }),\n  deleteToolApproval: (id: string) => globalWS.send({ type: 'delete_tool_approval', payload: { id } }),\n\n  // Tasks\n  listTasks: (): Promise<AgentTask[]> => globalWS.send({ type: 'list_tasks' }),\n  deleteTask: (id: string) => globalWS.send({ type: 'delete_task', payload: { id } }),\n\n  // Vault\n  listVaultSecrets: (): Promise<VaultSecret[]> => globalWS.send({ type: 'list_vault_secrets' }),\n  setVaultSecret: (name: string, value: string) => globalWS.send({ type: 'set_vault_secret', payload: { name, value } }),\n  removeVaultSecret: (name: string) => globalWS.send({ type: 'remove_vault_secret', payload: { name } }),\n\n  // Config\n  getConfig: (): Promise<Config> => globalWS.send({ type: 'get_config' }),\n  updateConfig: (updates: Record<string, unknown>) => globalWS.send({ type: 'update_config', payload: { updates } }),\n  getApiKeys: (): Promise<{ provider: string, configured: boolean, enabled: boolean }[]> => globalWS.send({ type: 'get_api_keys' }),\n  setApiKey: (provider: string, key: string) => globalWS.send({ type: 'set_api_key', payload: { provider, key } }),\n  removeApiKey: (provider: string) => globalWS.send({ type: 'remove_api_key', payload: { provider } }),\n\n  // Usage\n  getUsage: (days: number = 30): Promise<UsageResponse> => globalWS.send({ type: 'get_usage', payload: { days } }),\n  clearUsage: () => globalWS.send({ type: 'clear_usage' }),\n  getProcessedHistory: (agentId: string): Promise<{ messages: ProcessedMessage[] }> => globalWS.send({ type: 'get_processed_history', payload: { agent_id: agentId } }),\n\n  // Feedback\n  submitFeedbackManual: (agentId: string, message: string) => globalWS.send({ type: 'submit_feedback_manual', payload: { agent_id: agentId, message } }),\n\n  // Onboarding\n  restartOnboarding: () => globalWS.send({ type: 'restart_onboarding' }),\n\n  // Defaults\n  restoreDefaultSkills: () => globalWS.send({ type: 'restore_default_skills' }),\n  restoreDefaultTriggers: () => globalWS.send({ type: 'restore_default_triggers' }),\n\n  // Model Discovery\n  fetchModels: (provider: string): Promise<{ models: string[] }> =>\n    globalWS.send({ type: 'fetch_models', payload: { provider } }),\n};\n","numLines":320,"startLine":1,"totalLines":320}}}
{"parentUuid":"5df11006-6797-4872-8cbc-96775ab36d89","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FU75CN5sMoDKb69smqCmEw","type":"tool_result","content":"     1package inference\n     2\n     3import (\n     4\t\"bytes\"\n     5\t\"context\"\n     6\t\"encoding/json\"\n     7\t\"errors\"\n     8\t\"log/slog\"\n     9\t\"net/http\"\n    10\t\"os\"\n    11\t\"os/exec\"\n    12\t\"strings\"\n    13\t\"time\"\n    14\n    15\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n    16\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n    17\t\"github.com/sashabaranov/go-openai\"\n    18)\n    19\n    20type OpenAIProvider struct {\n    21\tclient         *openai.Client\n    22\tname           string\n    23\tdefaultContext int\n    24\tcontextLimits  map[string]int\n    25}\n    26\n    27func newOpenAICompatibleProvider(name, apiKey, baseURL string, defaultContext int, prefixLimits map[string]int, requireKey bool) (*OpenAIProvider, error) {\n    28\tif apiKey == \"\" && requireKey {\n    29\t\treturn nil, errors.New(\"api key required for \" + name)\n    30\t}\n    31\n    32\tif baseURL == \"\" {\n    33\t\tbaseURL = \"https://api.openai.com/v1\"\n    34\t}\n    35\n    36\tconfig := openai.DefaultConfig(apiKey)\n    37\tconfig.BaseURL = baseURL\n    38\tconfig.HTTPClient = &http.Client{Timeout: 300 * time.Second}\n    39\n    40\tclient := openai.NewClientWithConfig(config)\n    41\n    42\treturn &OpenAIProvider{\n    43\t\tclient:         client,\n    44\t\tname:           name,\n    45\t\tcontextLimits:  prefixLimits,\n    46\t\tdefaultContext: defaultContext,\n    47\t}, nil\n    48}\n    49\n    50func NewOpenAIProvider(apiKey string, baseURL string) (*OpenAIProvider, error) {\n    51\tif apiKey == \"\" {\n    52\t\tapiKey = config.GetKeychainPassword(\"openai-api-key\")\n    53\t}\n    54\tif apiKey == \"\" {\n    55\t\treturn nil, errors.New(\"api key required for openai\")\n    56\t}\n    57\n    58\tprefixLimits := map[string]int{\n    59\t\t\"gpt-4o\":        128000,\n    60\t\t\"gpt-4-turbo\":   128000,\n    61\t\t\"gpt-4\":         8192,\n    62\t\t\"gpt-3.5-turbo\": 16385,\n    63\t\t\"o1-\":           128000,\n    64\t}\n    65\n    66\treturn newOpenAICompatibleProvider(\"openai\", apiKey, baseURL, 128000, prefixLimits, true)\n    67}\n    68\n    69func NewOllamaProvider(apiKey string, baseURL string) (*OpenAIProvider, error) {\n    70\tif apiKey == \"\" {\n    71\t\tapiKey = config.GetKeychainPassword(\"ollama-api-key\")\n    72\t}\n    73\tif baseURL == \"\" {\n    74\t\tbaseURL = os.Getenv(\"OLLAMA_BASE_URL\")\n    75\t}\n    76\tif baseURL == \"\" {\n    77\t\tbaseURL = \"http://localhost:11434/v1\"\n    78\t}\n    79\n    80\treturn newOpenAICompatibleProvider(\"ollama\", apiKey, baseURL, 128000, map[string]int{}, false)\n    81}\n    82\n    83func NewLMStudioProvider(apiKey string, baseURL string) (*OpenAIProvider, error) {\n    84\tif apiKey == \"\" {\n    85\t\tapiKey = config.GetKeychainPassword(\"lm_studio-api-key\")\n    86\t}\n    87\tif baseURL == \"\" {\n    88\t\tbaseURL = os.Getenv(\"LM_STUDIO_BASE_URL\")\n    89\t}\n    90\tif baseURL == \"\" {\n    91\t\tbaseURL = \"http://localhost:1234/v1\"\n    92\t}\n    93\n    94\treturn newOpenAICompatibleProvider(\"lmstudio\", apiKey, baseURL, 128000, map[string]int{}, false)\n    95}\n    96\n    97func NewCustomOpenAIProvider(name string, apiKey string, baseURL string) (*OpenAIProvider, error) {\n    98\tif name == \"\" {\n    99\t\tname = \"custom\"\n   100\t}\n   101\tif baseURL == \"\" {\n   102\t\tbaseURL = os.Getenv(\"CUSTOM_PROVIDER_BASE_URL\")\n   103\t}\n   104\tif baseURL == \"\" {\n   105\t\tif cfg, err := config.LoadConfig(); err == nil && cfg.CustomProviders != nil {\n   106\t\t\tif cp, ok := cfg.CustomProviders[name]; ok && cp.BaseURL != \"\" {\n   107\t\t\t\tbaseURL = cp.BaseURL\n   108\t\t\t}\n   109\t\t}\n   110\t}\n   111\tif baseURL == \"\" {\n   112\t\treturn nil, errors.New(\"baseURL is required for custom provider\")\n   113\t}\n   114\tif apiKey == \"\" {\n   115\t\tapiKey = config.GetKeychainPassword(name + \"-api-key\")\n   116\t}\n   117\n   118\treturn newOpenAICompatibleProvider(name, apiKey, baseURL, 128000, map[string]int{}, false)\n   119}\n   120\n   121func (p *OpenAIProvider) Name() string {\n   122\tif p.name == \"\" {\n   123\t\treturn \"openai\"\n   124\t}\n   125\treturn p.name\n   126}\n   127\n   128func (p *OpenAIProvider) ListModels(ctx context.Context) ([]string, error) {\n   129\tvar err error\n   130\tif p.client != nil {\n   131\t\tvar resp openai.ModelsList\n   132\t\tresp, err = p.client.ListModels(ctx)\n   133\t\tif err == nil {\n   134\t\t\tvar models []string\n   135\t\t\tfor _, m := range resp.Models {\n   136\t\t\t\tmodels = append(models, m.ID)\n   137\t\t\t}\n   138\t\t\tif len(models) > 0 {\n   139\t\t\t\treturn models, nil\n   140\t\t\t}\n   141\t\t}\n   142\t}\n   143\n   144\t// Fallback for Ollama if API fails or returns empty\n   145\tif p.name == \"ollama\" {\n   146\t\tcmd := exec.Command(\"ollama\", \"ls\")\n   147\t\tvar out bytes.Buffer\n   148\t\tcmd.Stdout = &out\n   149\t\tif err := cmd.Run(); err == nil {\n   150\t\t\tlines := strings.Split(out.String(), \"\\n\")\n   151\t\t\tvar models []string\n   152\t\t\tfor i, line := range lines {\n   153\t\t\t\tif i == 0 || strings.TrimSpace(line) == \"\" {\n   154\t\t\t\t\tcontinue\n   155\t\t\t\t}\n   156\t\t\t\tfields := strings.Fields(line)\n   157\t\t\t\tif len(fields) > 0 {\n   158\t\t\t\t\tmodels = append(models, fields[0])\n   159\t\t\t\t}\n   160\t\t\t}\n   161\t\t\treturn models, nil\n   162\t\t}\n   163\t}\n   164\n   165\treturn nil, err\n   166}\n   167\n   168func (p *OpenAIProvider) GetContextLimit(model string) int {\n   169\tfor prefix, limit := range p.contextLimits {\n   170\t\tif strings.HasPrefix(model, prefix) {\n   171\t\t\treturn limit\n   172\t\t}\n   173\t}\n   174\n   175\t// Try fetching from OpenRouter metadata as a dynamic fallback\n   176\tif limit, ok := GetContextLimitFromOpenRouter(model); ok {\n   177\t\treturn limit\n   178\t}\n   179\n   180\tif p.defaultContext > 0 {\n   181\t\treturn p.defaultContext\n   182\t}\n   183\treturn 128000 // Default for newer models\n   184}\n   185\n   186func (p *OpenAIProvider) convertMessages(messages []types.Message) []openai.ChatCompletionMessage {\n   187\tvar openaiMessages []openai.ChatCompletionMessage\n   188\n   189\tfor _, msg := range messages {\n   190\t\tvar openaiMsg openai.ChatCompletionMessage\n   191\t\topenaiMsg.Role = msg.Role\n   192\n   193\t\tvar multiContent []openai.ChatMessagePart\n   194\n   195\t\t// Handle Content field\n   196\t\tif c, ok := msg.Content.(string); ok && c != \"\" {\n   197\t\t\tif len(msg.Attachments) > 0 {\n   198\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n   199\t\t\t\t\tType: openai.ChatMessagePartTypeText,\n   200\t\t\t\t\tText: c,\n   201\t\t\t\t})\n   202\t\t\t} else {\n   203\t\t\t\topenaiMsg.Content = c\n   204\t\t\t}\n   205\t\t} else if parts, ok := msg.Content.([]interface{}); ok {\n   206\t\t\tfor _, part := range parts {\n   207\t\t\t\tif pMap, ok := part.(map[string]interface{}); ok {\n   208\t\t\t\t\tpartType, _ := pMap[\"type\"].(string)\n   209\t\t\t\t\tif partType == \"text\" {\n   210\t\t\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n   211\t\t\t\t\t\t\tType: openai.ChatMessagePartTypeText,\n   212\t\t\t\t\t\t\tText: pMap[\"text\"].(string),\n   213\t\t\t\t\t\t})\n   214\t\t\t\t\t} else if partType == \"image_url\" {\n   215\t\t\t\t\t\tif imgUrl, ok := pMap[\"image_url\"].(map[string]interface{}); ok {\n   216\t\t\t\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n   217\t\t\t\t\t\t\t\tType: openai.ChatMessagePartTypeImageURL,\n   218\t\t\t\t\t\t\t\tImageURL: &openai.ChatMessageImageURL{\n   219\t\t\t\t\t\t\t\t\tURL: imgUrl[\"url\"].(string),\n   220\t\t\t\t\t\t\t\t},\n   221\t\t\t\t\t\t\t})\n   222\t\t\t\t\t\t}\n   223\t\t\t\t\t}\n   224\t\t\t\t}\n   225\t\t\t}\n   226\t\t}\n   227\n   228\t\t// Handle Attachments field\n   229\t\tfor _, att := range msg.Attachments {\n   230\t\t\tif att.Type == \"image\" {\n   231\t\t\t\turl := att.Data\n   232\t\t\t\tif !strings.HasPrefix(url, \"data:\") {\n   233\t\t\t\t\turl = \"data:\" + att.MimeType + \";base64,\" + att.Data\n   234\t\t\t\t}\n   235\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n   236\t\t\t\t\tType: openai.ChatMessagePartTypeImageURL,\n   237\t\t\t\t\tImageURL: &openai.ChatMessageImageURL{\n   238\t\t\t\t\t\tURL: url,\n   239\t\t\t\t\t},\n   240\t\t\t\t})\n   241\t\t\t} else if att.Type == \"file\" {\n   242\t\t\t\tif att.MimeType == \"application/pdf\" {\n   243\t\t\t\t\t// OpenAI Chat Completions don't natively support PDF as a part yet\n   244\t\t\t\t\t// (except via Assistants API or custom integrations).\n   245\t\t\t\t\t// We'll keep it as a placeholder or try to extract text in the future.\n   246\t\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n   247\t\t\t\t\t\tType: openai.ChatMessagePartTypeText,\n   248\t\t\t\t\t\tText: \"[PDF Attachment: \" + att.Name + \"]\",\n   249\t\t\t\t\t})\n   250\t\t\t\t} else {\n   251\t\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n   252\t\t\t\t\t\tType: openai.ChatMessagePartTypeText,\n   253\t\t\t\t\t\tText: \"[File Attachment: \" + att.Name + \" (\" + att.MimeType + \")]\",\n   254\t\t\t\t\t})\n   255\t\t\t\t}\n   256\t\t\t}\n   257\t\t}\n   258\n   259\t\tif len(multiContent) > 0 {\n   260\t\t\topenaiMsg.MultiContent = multiContent\n   261\t\t}\n   262\n   263\t\tif len(msg.ToolCalls) > 0 {\n   264\t\t\tfor _, tc := range msg.ToolCalls {\n   265\t\t\t\topenaiMsg.ToolCalls = append(openaiMsg.ToolCalls, openai.ToolCall{\n   266\t\t\t\t\tID:   tc.ID,\n   267\t\t\t\t\tType: openai.ToolType(tc.Type),\n   268\t\t\t\t\tFunction: openai.FunctionCall{\n   269\t\t\t\t\t\tName:      tc.Function.Name,\n   270\t\t\t\t\t\tArguments: tc.Function.Arguments,\n   271\t\t\t\t\t},\n   272\t\t\t\t})\n   273\t\t\t}\n   274\t\t}\n   275\t\tif msg.ToolCallID != \"\" {\n   276\t\t\topenaiMsg.ToolCallID = msg.ToolCallID\n   277\t\t}\n   278\t\tif msg.Name != \"\" {\n   279\t\t\topenaiMsg.Name = msg.Name\n   280\t\t}\n   281\n   282\t\topenaiMessages = append(openaiMessages, openaiMsg)\n   283\t}\n   284\treturn openaiMessages\n   285}\n   286\n   287func (p *OpenAIProvider) ChatCompletion(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (*types.ChatResponse, error) {\n   288\t// Parse thinking configuration from model string\n   289\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n   290\n   291\topenaiMessages := p.convertMessages(messages)\n   292\n   293\treq := openai.ChatCompletionRequest{\n   294\t\tModel:    baseModel,\n   295\t\tMessages: openaiMessages,\n   296\t}\n   297\n   298\tif tools != nil {\n   299\t\tvar openaiTools []openai.Tool\n   300\t\tfor _, t := range tools {\n   301\t\t\tif tMap, ok := t.(map[string]interface{}); ok {\n   302\t\t\t\tfn, _ := tMap[\"function\"].(map[string]interface{})\n   303\t\t\t\tname, _ := fn[\"name\"].(string)\n   304\t\t\t\tdesc, _ := fn[\"description\"].(string)\n   305\t\t\t\tparams, _ := fn[\"parameters\"].(map[string]interface{})\n   306\n   307\t\t\t\topenaiTools = append(openaiTools, openai.Tool{\n   308\t\t\t\t\tType: openai.ToolTypeFunction,\n   309\t\t\t\t\tFunction: &openai.FunctionDefinition{\n   310\t\t\t\t\t\tName:        name,\n   311\t\t\t\t\t\tDescription: desc,\n   312\t\t\t\t\t\tParameters:  params,\n   313\t\t\t\t\t},\n   314\t\t\t\t})\n   315\t\t\t}\n   316\t\t}\n   317\t\treq.Tools = openaiTools\n   318\t}\n   319\n   320\tif toolChoice, ok := options[\"tool_choice\"]; ok {\n   321\t\tif tcStr, ok := toolChoice.(string); ok {\n   322\t\t\treq.ToolChoice = tcStr\n   323\t\t} else {\n   324\t\t\t// Handle complex tool choice object if needed\n   325\t\t\tb, _ := json.Marshal(toolChoice)\n   326\t\t\tvar tc openai.ToolChoice\n   327\t\t\tif err := json.Unmarshal(b, &tc); err == nil {\n   328\t\t\t\treq.ToolChoice = tc\n   329\t\t\t}\n   330\t\t}\n   331\t}\n   332\n   333\t// Set reasoning_effort if level is set\n   334\tif reasoningLevel != ReasoningNone {\n   335\t\treq.ReasoningEffort = string(reasoningLevel)\n   336\t\tslog.Debug(\"OpenAI: Enabling reasoning\", \"model\", baseModel, \"level\", reasoningLevel)\n   337\t}\n   338\n   339\tresp, err := p.client.CreateChatCompletion(ctx, req)\n   340\tif err != nil {\n   341\t\treturn nil, err\n   342\t}\n   343\n   344\tvar toolCalls []types.ToolCall\n   345\tfor _, tc := range resp.Choices[0].Message.ToolCalls {\n   346\t\ttoolCalls = append(toolCalls, types.ToolCall{\n   347\t\t\tID:   tc.ID,\n   348\t\t\tType: string(tc.Type),\n   349\t\t\tFunction: types.ToolFunction{\n   350\t\t\t\tName:      tc.Function.Name,\n   351\t\t\t\tArguments: tc.Function.Arguments,\n   352\t\t\t},\n   353\t\t})\n   354\t}\n   355\n   356\treturn &types.ChatResponse{\n   357\t\tContent:   resp.Choices[0].Message.Content,\n   358\t\tToolCalls: toolCalls,\n   359\t\tUsage: types.Usage{\n   360\t\t\tInputTokens:  resp.Usage.PromptTokens,\n   361\t\t\tOutputTokens: resp.Usage.CompletionTokens,\n   362\t\t\tTotalTokens:  resp.Usage.TotalTokens,\n   363\t\t},\n   364\t}, nil\n   365}\n   366\n   367\n   368func (p *OpenAIProvider) ChatCompletionStream(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (<-chan types.ChatStreamChunk, <-chan error) {\n   369\tchunkCh := make(chan types.ChatStreamChunk)\n   370\terrCh := make(chan error, 1)\n   371\n   372\tgo func() {\n   373\t\tdefer close(chunkCh)\n   374\t\tdefer close(errCh)\n   375\n   376\t\t// Parse thinking configuration from model string\n   377\t\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n   378\n   379\t\topenaiMessages := p.convertMessages(messages)\n   380\n   381\t\treq := openai.ChatCompletionRequest{\n   382\t\t\tModel:    baseModel,\n   383\t\t\tMessages: openaiMessages,\n   384\t\t\tStream:   true,\n   385\t\t\tStreamOptions: &openai.StreamOptions{\n   386\t\t\t\tIncludeUsage: true,\n   387\t\t\t},\n   388\t\t}\n   389\n   390\t\t// Set reasoning_effort if level is set\n   391\t\tif reasoningLevel != ReasoningNone {\n   392\t\t\treq.ReasoningEffort = string(reasoningLevel)\n   393\t\t\tslog.Debug(\"OpenAI: Enabling reasoning (stream)\", \"model\", baseModel, \"level\", reasoningLevel)\n   394\t\t}\n   395\n   396\t\tif tools != nil {\n   397\t\t\tvar openaiTools []openai.Tool\n   398\t\t\tfor _, t := range tools {\n   399\t\t\t\tif tMap, ok := t.(map[string]interface{}); ok {\n   400\t\t\t\t\tfn, _ := tMap[\"function\"].(map[string]interface{})\n   401\t\t\t\t\tname, _ := fn[\"name\"].(string)\n   402\t\t\t\t\tdesc, _ := fn[\"description\"].(string)\n   403\t\t\t\t\tparams, _ := fn[\"parameters\"].(map[string]interface{})\n   404\n   405\t\t\t\t\topenaiTools = append(openaiTools, openai.Tool{\n   406\t\t\t\t\t\tType: openai.ToolTypeFunction,\n   407\t\t\t\t\t\tFunction: &openai.FunctionDefinition{\n   408\t\t\t\t\t\t\tName:        name,\n   409\t\t\t\t\t\t\tDescription: desc,\n   410\t\t\t\t\t\t\tParameters:  params,\n   411\t\t\t\t\t\t},\n   412\t\t\t\t\t})\n   413\t\t\t\t}\n   414\t\t\t}\n   415\t\t\treq.Tools = openaiTools\n   416\t\t}\n   417\n   418\t\tif toolChoice, ok := options[\"tool_choice\"]; ok {\n   419\t\t\tif tcStr, ok := toolChoice.(string); ok {\n   420\t\t\t\treq.ToolChoice = tcStr\n   421\t\t\t} else {\n   422\t\t\t\tb, _ := json.Marshal(toolChoice)\n   423\t\t\t\tvar tc openai.ToolChoice\n   424\t\t\t\tif err := json.Unmarshal(b, &tc); err == nil {\n   425\t\t\t\t\treq.ToolChoice = tc\n   426\t\t\t\t}\n   427\t\t\t}\n   428\t\t}\n   429\n   430\t\tstream, err := p.client.CreateChatCompletionStream(ctx, req)\n   431\t\tif err != nil {\n   432\t\t\terrCh <- err\n   433\t\t\treturn\n   434\t\t}\n   435\t\tdefer stream.Close()\n   436\n   437\t\tfor {\n   438\t\t\tresp, err := stream.Recv()\n   439\t\t\tif err != nil {\n   440\t\t\t\tif err.Error() == \"EOF\" {\n   441\t\t\t\t\treturn\n   442\t\t\t\t}\n   443\t\t\t\terrCh <- err\n   444\t\t\t\treturn\n   445\t\t\t}\n   446\n   447\t\t\tvar usage *types.Usage\n   448\t\t\tif resp.Usage != nil {\n   449\t\t\t\tusage = &types.Usage{\n   450\t\t\t\t\tInputTokens:  resp.Usage.PromptTokens,\n   451\t\t\t\t\tOutputTokens: resp.Usage.CompletionTokens,\n   452\t\t\t\t\tTotalTokens:  resp.Usage.TotalTokens,\n   453\t\t\t\t}\n   454\t\t\t}\n   455\n   456\t\t\tif len(resp.Choices) > 0 {\n   457\t\t\t\tdelta := resp.Choices[0].Delta\n   458\t\t\t\t// Gemini's OpenAI-compatible streaming endpoint may emit user-visible text in the\n   459\t\t\t\t// \"reasoning\" field (as parsed by go-openai) while leaving \"content\" empty.\n   460\t\t\t\t// Our UI treats \"reasoning\" as hidden/expandable thinking, so normalize it.\n   461\t\t\t\tcontent := delta.Content\n   462\t\t\t\treasoning := delta.ReasoningContent\n   463\t\t\t\tif p.name == \"gemini\" && content == \"\" && reasoning != \"\" {\n   464\t\t\t\t\tcontent = reasoning\n   465\t\t\t\t\treasoning = \"\"\n   466\t\t\t\t}\n   467\t\t\t\tvar toolCallChunks []types.ToolCallChunk\n   468\t\t\t\tfor _, tc := range delta.ToolCalls {\n   469\t\t\t\t\tvar idx *int\n   470\t\t\t\t\tif tc.Index != nil {\n   471\t\t\t\t\t\ti := *tc.Index\n   472\t\t\t\t\t\tidx = &i\n   473\t\t\t\t\t}\n   474\t\t\t\t\ttoolCallChunks = append(toolCallChunks, types.ToolCallChunk{\n   475\t\t\t\t\t\tIndex: idx,\n   476\t\t\t\t\t\tID:    tc.ID,\n   477\t\t\t\t\t\tType:  string(tc.Type),\n   478\t\t\t\t\t\tFunction: types.FunctionChunk{\n   479\t\t\t\t\t\t\tName:      tc.Function.Name,\n   480\t\t\t\t\t\t\tArguments: tc.Function.Arguments,\n   481\t\t\t\t\t\t},\n   482\t\t\t\t\t})\n   483\t\t\t\t}\n   484\n   485\t\t\t\tchunkCh <- types.ChatStreamChunk{\n   486\t\t\t\t\tContent:   content,\n   487\t\t\t\t\tReasoning: reasoning,\n   488\t\t\t\t\tToolCalls: toolCallChunks,\n   489\t\t\t\t\tUsage:     usage,\n   490\t\t\t\t\tRawChunk:  map[string]interface{}{\"choice\": resp.Choices[0]},\n   491\t\t\t\t}\n   492\t\t\t} else if usage != nil {\n   493\t\t\t\tchunkCh <- types.ChatStreamChunk{\n   494\t\t\t\t\tUsage:    usage,\n   495\t\t\t\t\tRawChunk: map[string]interface{}{\"usage\": resp.Usage},\n   496\t\t\t\t}\n   497\t\t\t}\n   498\t\t}\n   499\t}()\n   500\n   501\treturn chunkCh, errCh\n   502}\n   503\n   504func (p *OpenAIProvider) Close() error {\n   505\treturn nil\n   506}\n   507\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"72c72d35-ec3c-4042-a16f-57d118970854","timestamp":"2026-01-03T12:11:01.537Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openai.go","content":"package inference\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"log/slog\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n\t\"github.com/sashabaranov/go-openai\"\n)\n\ntype OpenAIProvider struct {\n\tclient         *openai.Client\n\tname           string\n\tdefaultContext int\n\tcontextLimits  map[string]int\n}\n\nfunc newOpenAICompatibleProvider(name, apiKey, baseURL string, defaultContext int, prefixLimits map[string]int, requireKey bool) (*OpenAIProvider, error) {\n\tif apiKey == \"\" && requireKey {\n\t\treturn nil, errors.New(\"api key required for \" + name)\n\t}\n\n\tif baseURL == \"\" {\n\t\tbaseURL = \"https://api.openai.com/v1\"\n\t}\n\n\tconfig := openai.DefaultConfig(apiKey)\n\tconfig.BaseURL = baseURL\n\tconfig.HTTPClient = &http.Client{Timeout: 300 * time.Second}\n\n\tclient := openai.NewClientWithConfig(config)\n\n\treturn &OpenAIProvider{\n\t\tclient:         client,\n\t\tname:           name,\n\t\tcontextLimits:  prefixLimits,\n\t\tdefaultContext: defaultContext,\n\t}, nil\n}\n\nfunc NewOpenAIProvider(apiKey string, baseURL string) (*OpenAIProvider, error) {\n\tif apiKey == \"\" {\n\t\tapiKey = config.GetKeychainPassword(\"openai-api-key\")\n\t}\n\tif apiKey == \"\" {\n\t\treturn nil, errors.New(\"api key required for openai\")\n\t}\n\n\tprefixLimits := map[string]int{\n\t\t\"gpt-4o\":        128000,\n\t\t\"gpt-4-turbo\":   128000,\n\t\t\"gpt-4\":         8192,\n\t\t\"gpt-3.5-turbo\": 16385,\n\t\t\"o1-\":           128000,\n\t}\n\n\treturn newOpenAICompatibleProvider(\"openai\", apiKey, baseURL, 128000, prefixLimits, true)\n}\n\nfunc NewOllamaProvider(apiKey string, baseURL string) (*OpenAIProvider, error) {\n\tif apiKey == \"\" {\n\t\tapiKey = config.GetKeychainPassword(\"ollama-api-key\")\n\t}\n\tif baseURL == \"\" {\n\t\tbaseURL = os.Getenv(\"OLLAMA_BASE_URL\")\n\t}\n\tif baseURL == \"\" {\n\t\tbaseURL = \"http://localhost:11434/v1\"\n\t}\n\n\treturn newOpenAICompatibleProvider(\"ollama\", apiKey, baseURL, 128000, map[string]int{}, false)\n}\n\nfunc NewLMStudioProvider(apiKey string, baseURL string) (*OpenAIProvider, error) {\n\tif apiKey == \"\" {\n\t\tapiKey = config.GetKeychainPassword(\"lm_studio-api-key\")\n\t}\n\tif baseURL == \"\" {\n\t\tbaseURL = os.Getenv(\"LM_STUDIO_BASE_URL\")\n\t}\n\tif baseURL == \"\" {\n\t\tbaseURL = \"http://localhost:1234/v1\"\n\t}\n\n\treturn newOpenAICompatibleProvider(\"lmstudio\", apiKey, baseURL, 128000, map[string]int{}, false)\n}\n\nfunc NewCustomOpenAIProvider(name string, apiKey string, baseURL string) (*OpenAIProvider, error) {\n\tif name == \"\" {\n\t\tname = \"custom\"\n\t}\n\tif baseURL == \"\" {\n\t\tbaseURL = os.Getenv(\"CUSTOM_PROVIDER_BASE_URL\")\n\t}\n\tif baseURL == \"\" {\n\t\tif cfg, err := config.LoadConfig(); err == nil && cfg.CustomProviders != nil {\n\t\t\tif cp, ok := cfg.CustomProviders[name]; ok && cp.BaseURL != \"\" {\n\t\t\t\tbaseURL = cp.BaseURL\n\t\t\t}\n\t\t}\n\t}\n\tif baseURL == \"\" {\n\t\treturn nil, errors.New(\"baseURL is required for custom provider\")\n\t}\n\tif apiKey == \"\" {\n\t\tapiKey = config.GetKeychainPassword(name + \"-api-key\")\n\t}\n\n\treturn newOpenAICompatibleProvider(name, apiKey, baseURL, 128000, map[string]int{}, false)\n}\n\nfunc (p *OpenAIProvider) Name() string {\n\tif p.name == \"\" {\n\t\treturn \"openai\"\n\t}\n\treturn p.name\n}\n\nfunc (p *OpenAIProvider) ListModels(ctx context.Context) ([]string, error) {\n\tvar err error\n\tif p.client != nil {\n\t\tvar resp openai.ModelsList\n\t\tresp, err = p.client.ListModels(ctx)\n\t\tif err == nil {\n\t\t\tvar models []string\n\t\t\tfor _, m := range resp.Models {\n\t\t\t\tmodels = append(models, m.ID)\n\t\t\t}\n\t\t\tif len(models) > 0 {\n\t\t\t\treturn models, nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback for Ollama if API fails or returns empty\n\tif p.name == \"ollama\" {\n\t\tcmd := exec.Command(\"ollama\", \"ls\")\n\t\tvar out bytes.Buffer\n\t\tcmd.Stdout = &out\n\t\tif err := cmd.Run(); err == nil {\n\t\t\tlines := strings.Split(out.String(), \"\\n\")\n\t\t\tvar models []string\n\t\t\tfor i, line := range lines {\n\t\t\t\tif i == 0 || strings.TrimSpace(line) == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfields := strings.Fields(line)\n\t\t\t\tif len(fields) > 0 {\n\t\t\t\t\tmodels = append(models, fields[0])\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn models, nil\n\t\t}\n\t}\n\n\treturn nil, err\n}\n\nfunc (p *OpenAIProvider) GetContextLimit(model string) int {\n\tfor prefix, limit := range p.contextLimits {\n\t\tif strings.HasPrefix(model, prefix) {\n\t\t\treturn limit\n\t\t}\n\t}\n\n\t// Try fetching from OpenRouter metadata as a dynamic fallback\n\tif limit, ok := GetContextLimitFromOpenRouter(model); ok {\n\t\treturn limit\n\t}\n\n\tif p.defaultContext > 0 {\n\t\treturn p.defaultContext\n\t}\n\treturn 128000 // Default for newer models\n}\n\nfunc (p *OpenAIProvider) convertMessages(messages []types.Message) []openai.ChatCompletionMessage {\n\tvar openaiMessages []openai.ChatCompletionMessage\n\n\tfor _, msg := range messages {\n\t\tvar openaiMsg openai.ChatCompletionMessage\n\t\topenaiMsg.Role = msg.Role\n\n\t\tvar multiContent []openai.ChatMessagePart\n\n\t\t// Handle Content field\n\t\tif c, ok := msg.Content.(string); ok && c != \"\" {\n\t\t\tif len(msg.Attachments) > 0 {\n\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n\t\t\t\t\tType: openai.ChatMessagePartTypeText,\n\t\t\t\t\tText: c,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\topenaiMsg.Content = c\n\t\t\t}\n\t\t} else if parts, ok := msg.Content.([]interface{}); ok {\n\t\t\tfor _, part := range parts {\n\t\t\t\tif pMap, ok := part.(map[string]interface{}); ok {\n\t\t\t\t\tpartType, _ := pMap[\"type\"].(string)\n\t\t\t\t\tif partType == \"text\" {\n\t\t\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n\t\t\t\t\t\t\tType: openai.ChatMessagePartTypeText,\n\t\t\t\t\t\t\tText: pMap[\"text\"].(string),\n\t\t\t\t\t\t})\n\t\t\t\t\t} else if partType == \"image_url\" {\n\t\t\t\t\t\tif imgUrl, ok := pMap[\"image_url\"].(map[string]interface{}); ok {\n\t\t\t\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n\t\t\t\t\t\t\t\tType: openai.ChatMessagePartTypeImageURL,\n\t\t\t\t\t\t\t\tImageURL: &openai.ChatMessageImageURL{\n\t\t\t\t\t\t\t\t\tURL: imgUrl[\"url\"].(string),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle Attachments field\n\t\tfor _, att := range msg.Attachments {\n\t\t\tif att.Type == \"image\" {\n\t\t\t\turl := att.Data\n\t\t\t\tif !strings.HasPrefix(url, \"data:\") {\n\t\t\t\t\turl = \"data:\" + att.MimeType + \";base64,\" + att.Data\n\t\t\t\t}\n\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n\t\t\t\t\tType: openai.ChatMessagePartTypeImageURL,\n\t\t\t\t\tImageURL: &openai.ChatMessageImageURL{\n\t\t\t\t\t\tURL: url,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else if att.Type == \"file\" {\n\t\t\t\tif att.MimeType == \"application/pdf\" {\n\t\t\t\t\t// OpenAI Chat Completions don't natively support PDF as a part yet\n\t\t\t\t\t// (except via Assistants API or custom integrations).\n\t\t\t\t\t// We'll keep it as a placeholder or try to extract text in the future.\n\t\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n\t\t\t\t\t\tType: openai.ChatMessagePartTypeText,\n\t\t\t\t\t\tText: \"[PDF Attachment: \" + att.Name + \"]\",\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tmultiContent = append(multiContent, openai.ChatMessagePart{\n\t\t\t\t\t\tType: openai.ChatMessagePartTypeText,\n\t\t\t\t\t\tText: \"[File Attachment: \" + att.Name + \" (\" + att.MimeType + \")]\",\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif len(multiContent) > 0 {\n\t\t\topenaiMsg.MultiContent = multiContent\n\t\t}\n\n\t\tif len(msg.ToolCalls) > 0 {\n\t\t\tfor _, tc := range msg.ToolCalls {\n\t\t\t\topenaiMsg.ToolCalls = append(openaiMsg.ToolCalls, openai.ToolCall{\n\t\t\t\t\tID:   tc.ID,\n\t\t\t\t\tType: openai.ToolType(tc.Type),\n\t\t\t\t\tFunction: openai.FunctionCall{\n\t\t\t\t\t\tName:      tc.Function.Name,\n\t\t\t\t\t\tArguments: tc.Function.Arguments,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif msg.ToolCallID != \"\" {\n\t\t\topenaiMsg.ToolCallID = msg.ToolCallID\n\t\t}\n\t\tif msg.Name != \"\" {\n\t\t\topenaiMsg.Name = msg.Name\n\t\t}\n\n\t\topenaiMessages = append(openaiMessages, openaiMsg)\n\t}\n\treturn openaiMessages\n}\n\nfunc (p *OpenAIProvider) ChatCompletion(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (*types.ChatResponse, error) {\n\t// Parse thinking configuration from model string\n\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n\n\topenaiMessages := p.convertMessages(messages)\n\n\treq := openai.ChatCompletionRequest{\n\t\tModel:    baseModel,\n\t\tMessages: openaiMessages,\n\t}\n\n\tif tools != nil {\n\t\tvar openaiTools []openai.Tool\n\t\tfor _, t := range tools {\n\t\t\tif tMap, ok := t.(map[string]interface{}); ok {\n\t\t\t\tfn, _ := tMap[\"function\"].(map[string]interface{})\n\t\t\t\tname, _ := fn[\"name\"].(string)\n\t\t\t\tdesc, _ := fn[\"description\"].(string)\n\t\t\t\tparams, _ := fn[\"parameters\"].(map[string]interface{})\n\n\t\t\t\topenaiTools = append(openaiTools, openai.Tool{\n\t\t\t\t\tType: openai.ToolTypeFunction,\n\t\t\t\t\tFunction: &openai.FunctionDefinition{\n\t\t\t\t\t\tName:        name,\n\t\t\t\t\t\tDescription: desc,\n\t\t\t\t\t\tParameters:  params,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\treq.Tools = openaiTools\n\t}\n\n\tif toolChoice, ok := options[\"tool_choice\"]; ok {\n\t\tif tcStr, ok := toolChoice.(string); ok {\n\t\t\treq.ToolChoice = tcStr\n\t\t} else {\n\t\t\t// Handle complex tool choice object if needed\n\t\t\tb, _ := json.Marshal(toolChoice)\n\t\t\tvar tc openai.ToolChoice\n\t\t\tif err := json.Unmarshal(b, &tc); err == nil {\n\t\t\t\treq.ToolChoice = tc\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set reasoning_effort if level is set\n\tif reasoningLevel != ReasoningNone {\n\t\treq.ReasoningEffort = string(reasoningLevel)\n\t\tslog.Debug(\"OpenAI: Enabling reasoning\", \"model\", baseModel, \"level\", reasoningLevel)\n\t}\n\n\tresp, err := p.client.CreateChatCompletion(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar toolCalls []types.ToolCall\n\tfor _, tc := range resp.Choices[0].Message.ToolCalls {\n\t\ttoolCalls = append(toolCalls, types.ToolCall{\n\t\t\tID:   tc.ID,\n\t\t\tType: string(tc.Type),\n\t\t\tFunction: types.ToolFunction{\n\t\t\t\tName:      tc.Function.Name,\n\t\t\t\tArguments: tc.Function.Arguments,\n\t\t\t},\n\t\t})\n\t}\n\n\treturn &types.ChatResponse{\n\t\tContent:   resp.Choices[0].Message.Content,\n\t\tToolCalls: toolCalls,\n\t\tUsage: types.Usage{\n\t\t\tInputTokens:  resp.Usage.PromptTokens,\n\t\t\tOutputTokens: resp.Usage.CompletionTokens,\n\t\t\tTotalTokens:  resp.Usage.TotalTokens,\n\t\t},\n\t}, nil\n}\n\n\nfunc (p *OpenAIProvider) ChatCompletionStream(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (<-chan types.ChatStreamChunk, <-chan error) {\n\tchunkCh := make(chan types.ChatStreamChunk)\n\terrCh := make(chan error, 1)\n\n\tgo func() {\n\t\tdefer close(chunkCh)\n\t\tdefer close(errCh)\n\n\t\t// Parse thinking configuration from model string\n\t\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n\n\t\topenaiMessages := p.convertMessages(messages)\n\n\t\treq := openai.ChatCompletionRequest{\n\t\t\tModel:    baseModel,\n\t\t\tMessages: openaiMessages,\n\t\t\tStream:   true,\n\t\t\tStreamOptions: &openai.StreamOptions{\n\t\t\t\tIncludeUsage: true,\n\t\t\t},\n\t\t}\n\n\t\t// Set reasoning_effort if level is set\n\t\tif reasoningLevel != ReasoningNone {\n\t\t\treq.ReasoningEffort = string(reasoningLevel)\n\t\t\tslog.Debug(\"OpenAI: Enabling reasoning (stream)\", \"model\", baseModel, \"level\", reasoningLevel)\n\t\t}\n\n\t\tif tools != nil {\n\t\t\tvar openaiTools []openai.Tool\n\t\t\tfor _, t := range tools {\n\t\t\t\tif tMap, ok := t.(map[string]interface{}); ok {\n\t\t\t\t\tfn, _ := tMap[\"function\"].(map[string]interface{})\n\t\t\t\t\tname, _ := fn[\"name\"].(string)\n\t\t\t\t\tdesc, _ := fn[\"description\"].(string)\n\t\t\t\t\tparams, _ := fn[\"parameters\"].(map[string]interface{})\n\n\t\t\t\t\topenaiTools = append(openaiTools, openai.Tool{\n\t\t\t\t\t\tType: openai.ToolTypeFunction,\n\t\t\t\t\t\tFunction: &openai.FunctionDefinition{\n\t\t\t\t\t\t\tName:        name,\n\t\t\t\t\t\t\tDescription: desc,\n\t\t\t\t\t\t\tParameters:  params,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\treq.Tools = openaiTools\n\t\t}\n\n\t\tif toolChoice, ok := options[\"tool_choice\"]; ok {\n\t\t\tif tcStr, ok := toolChoice.(string); ok {\n\t\t\t\treq.ToolChoice = tcStr\n\t\t\t} else {\n\t\t\t\tb, _ := json.Marshal(toolChoice)\n\t\t\t\tvar tc openai.ToolChoice\n\t\t\t\tif err := json.Unmarshal(b, &tc); err == nil {\n\t\t\t\t\treq.ToolChoice = tc\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstream, err := p.client.CreateChatCompletionStream(ctx, req)\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tfor {\n\t\t\tresp, err := stream.Recv()\n\t\t\tif err != nil {\n\t\t\t\tif err.Error() == \"EOF\" {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar usage *types.Usage\n\t\t\tif resp.Usage != nil {\n\t\t\t\tusage = &types.Usage{\n\t\t\t\t\tInputTokens:  resp.Usage.PromptTokens,\n\t\t\t\t\tOutputTokens: resp.Usage.CompletionTokens,\n\t\t\t\t\tTotalTokens:  resp.Usage.TotalTokens,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(resp.Choices) > 0 {\n\t\t\t\tdelta := resp.Choices[0].Delta\n\t\t\t\t// Gemini's OpenAI-compatible streaming endpoint may emit user-visible text in the\n\t\t\t\t// \"reasoning\" field (as parsed by go-openai) while leaving \"content\" empty.\n\t\t\t\t// Our UI treats \"reasoning\" as hidden/expandable thinking, so normalize it.\n\t\t\t\tcontent := delta.Content\n\t\t\t\treasoning := delta.ReasoningContent\n\t\t\t\tif p.name == \"gemini\" && content == \"\" && reasoning != \"\" {\n\t\t\t\t\tcontent = reasoning\n\t\t\t\t\treasoning = \"\"\n\t\t\t\t}\n\t\t\t\tvar toolCallChunks []types.ToolCallChunk\n\t\t\t\tfor _, tc := range delta.ToolCalls {\n\t\t\t\t\tvar idx *int\n\t\t\t\t\tif tc.Index != nil {\n\t\t\t\t\t\ti := *tc.Index\n\t\t\t\t\t\tidx = &i\n\t\t\t\t\t}\n\t\t\t\t\ttoolCallChunks = append(toolCallChunks, types.ToolCallChunk{\n\t\t\t\t\t\tIndex: idx,\n\t\t\t\t\t\tID:    tc.ID,\n\t\t\t\t\t\tType:  string(tc.Type),\n\t\t\t\t\t\tFunction: types.FunctionChunk{\n\t\t\t\t\t\t\tName:      tc.Function.Name,\n\t\t\t\t\t\t\tArguments: tc.Function.Arguments,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tchunkCh <- types.ChatStreamChunk{\n\t\t\t\t\tContent:   content,\n\t\t\t\t\tReasoning: reasoning,\n\t\t\t\t\tToolCalls: toolCallChunks,\n\t\t\t\t\tUsage:     usage,\n\t\t\t\t\tRawChunk:  map[string]interface{}{\"choice\": resp.Choices[0]},\n\t\t\t\t}\n\t\t\t} else if usage != nil {\n\t\t\t\tchunkCh <- types.ChatStreamChunk{\n\t\t\t\t\tUsage:    usage,\n\t\t\t\t\tRawChunk: map[string]interface{}{\"usage\": resp.Usage},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn chunkCh, errCh\n}\n\nfunc (p *OpenAIProvider) Close() error {\n\treturn nil\n}\n","numLines":507,"startLine":1,"totalLines":507}}}
{"parentUuid":"72c72d35-ec3c-4042-a16f-57d118970854","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SBou1GifFkPbcR9KWSpLMe","type":"tool_result","content":"File not found or empty","is_error":false}]},"uuid":"af573fb1-9d81-430c-806d-540f36d00729","timestamp":"2026-01-03T12:11:04.068Z","toolUseResult":{"stdout":"File not found or empty","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"af573fb1-9d81-430c-806d-540f36d00729","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J3JubhQs1miiz9BYaMFKFv","type":"message","role":"assistant","content":[{"type":"text","text":"Let me also look at how agents.go works and explore the browser manager for potential OAuth callback handling patterns:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":46350,"cache_read_input_tokens":57882,"cache_creation":{"ephemeral_5m_input_tokens":46350,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWkRRPvuTP3wvZX78v65Q","type":"assistant","uuid":"360d64f5-2210-4085-adba-fd51c38b4262","timestamp":"2026-01-03T12:11:09.151Z"}
{"parentUuid":"360d64f5-2210-4085-adba-fd51c38b4262","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J3JubhQs1miiz9BYaMFKFv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XuKg7n7fZe6W8C5qsuRoK7","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/agents.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":46350,"cache_read_input_tokens":57882,"cache_creation":{"ephemeral_5m_input_tokens":46350,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWkRRPvuTP3wvZX78v65Q","type":"assistant","uuid":"fd56b896-a39b-49e2-a172-31cdcbdab23e","timestamp":"2026-01-03T12:11:10.257Z"}
{"parentUuid":"fd56b896-a39b-49e2-a172-31cdcbdab23e","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J3JubhQs1miiz9BYaMFKFv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01No2q9r2L1Hajm83yZ92z2L","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/browser_manager.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":46350,"cache_read_input_tokens":57882,"cache_creation":{"ephemeral_5m_input_tokens":46350,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWkRRPvuTP3wvZX78v65Q","type":"assistant","uuid":"ce24490f-fa5b-4371-ab1e-d63600658dff","timestamp":"2026-01-03T12:11:11.302Z"}
{"parentUuid":"ce24490f-fa5b-4371-ab1e-d63600658dff","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J3JubhQs1miiz9BYaMFKFv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XiAHR4Cudy27xcnSg68QgM","name":"Grep","input":{"pattern":"oauth|OAuth|PKCE|pkce|authorization|Authorization","path":"/Users/patrick/workingdir/familiar","-i":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":46350,"cache_read_input_tokens":57882,"cache_creation":{"ephemeral_5m_input_tokens":46350,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWkRRPvuTP3wvZX78v65Q","type":"assistant","uuid":"65a76e1f-fb1b-4460-9e05-fe0c79bf4722","timestamp":"2026-01-03T12:11:12.827Z"}
{"parentUuid":"65a76e1f-fb1b-4460-9e05-fe0c79bf4722","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01No2q9r2L1Hajm83yZ92z2L","type":"tool_result","content":"     1package utils\n     2\n     3import (\n     4\t\"fmt\"\n     5\t\"log/slog\"\n     6\t\"os\"\n     7\t\"os/exec\"\n     8\t\"runtime\"\n     9\t\"strings\"\n    10\t\"sync\"\n    11\t\"time\"\n    12)\n    13\n    14type BrowserPage interface {\n    15\tGoto(url string) error\n    16\tClick(selector string) error\n    17\tFill(selector, value string) error\n    18\tEvaluate(expression string) (interface{}, error)\n    19\tInnerText(selector string) (string, error)\n    20\tURL() string\n    21\tTitle() (string, error)\n    22\tClose() error\n    23}\n    24\n    25type BrowserInstance struct {\n    26\tPage BrowserPage\n    27}\n    28\n    29type SafariPage struct {\n    30\tlastURL string\n    31}\n    32\n    33func (s *SafariPage) Goto(url string) error {\n    34\ts.lastURL = url\n    35\tcmd := exec.Command(\"osascript\", \"-e\", fmt.Sprintf(`tell application \"Safari\" to open location \"%s\"`, url))\n    36\tif err := cmd.Run(); err != nil {\n    37\t\treturn err\n    38\t}\n    39\t// Give it a moment to start loading\n    40\ttime.Sleep(1 * time.Second)\n    41\treturn nil\n    42}\n    43\n    44func (s *SafariPage) Click(selector string) error {\n    45\t// Very limited support via GUI scripting or JS injection if allowed\n    46\tscript := fmt.Sprintf(`tell application \"Safari\" to do JavaScript \"document.querySelector('%s').click()\" in document 1`, selector)\n    47\treturn exec.Command(\"osascript\", \"-e\", script).Run()\n    48}\n    49\n    50func (s *SafariPage) Fill(selector, value string) error {\n    51\tscript := fmt.Sprintf(`tell application \"Safari\" to do JavaScript \"document.querySelector('%s').value = '%s'\" in document 1`, selector, value)\n    52\treturn exec.Command(\"osascript\", \"-e\", script).Run()\n    53}\n    54\n    55func (s *SafariPage) Evaluate(expression string) (interface{}, error) {\n    56\tscript := fmt.Sprintf(`tell application \"Safari\" to do JavaScript \"%s\" in document 1`, expression)\n    57\tout, err := exec.Command(\"osascript\", \"-e\", script).Output()\n    58\treturn string(out), err\n    59}\n    60\n    61func (s *SafariPage) InnerText(selector string) (string, error) {\n    62\tscript := fmt.Sprintf(`tell application \"Safari\" to do JavaScript \"document.querySelector('%s').innerText\" in document 1`, selector)\n    63\tout, err := exec.Command(\"osascript\", \"-e\", script).Output()\n    64\treturn strings.TrimSpace(string(out)), err\n    65}\n    66\n    67func (s *SafariPage) URL() string {\n    68\tout, _ := exec.Command(\"osascript\", \"-e\", `tell application \"Safari\" to return URL of current tab of window 1`).Output()\n    69\treturn strings.TrimSpace(string(out))\n    70}\n    71\n    72func (s *SafariPage) Title() (string, error) {\n    73\tout, err := exec.Command(\"osascript\", \"-e\", `tell application \"Safari\" to return name of current tab of window 1`).Output()\n    74\treturn strings.TrimSpace(string(out)), err\n    75}\n    76\n    77func (s *SafariPage) Close() error {\n    78\treturn nil // Don't close the user's Safari\n    79}\n    80\n    81type BrowserManager struct {\n    82\tinstances        map[string]*BrowserInstance // agentID -> BrowserInstance\n    83\tmu               sync.RWMutex\n    84\tcachedEngines    []string\n    85\tlastEnginesCheck time.Time\n    86}\n    87\n    88var (\n    89\tbrowserManager *BrowserManager\n    90\tbmOnce         sync.Once\n    91)\n    92\n    93func GetBrowserManager() *BrowserManager {\n    94\tbmOnce.Do(func() {\n    95\t\tbrowserManager = &BrowserManager{\n    96\t\t\tinstances: make(map[string]*BrowserInstance),\n    97\t\t}\n    98\t})\n    99\treturn browserManager\n   100}\n   101\n   102func (bm *BrowserManager) GetPage(agentID string) (BrowserPage, error) {\n   103\tbm.mu.RLock()\n   104\tinstance, ok := bm.instances[agentID]\n   105\tbm.mu.RUnlock()\n   106\n   107\tif ok {\n   108\t\tif instance.Page != nil {\n   109\t\t\treturn instance.Page, nil\n   110\t\t}\n   111\t}\n   112\n   113\treturn bm.CreateInstance(agentID)\n   114}\n   115\n   116func (bm *BrowserManager) CreateInstance(agentID string) (BrowserPage, error) {\n   117\tbm.mu.Lock()\n   118\tdefer bm.mu.Unlock()\n   119\n   120\tif instance, ok := bm.instances[agentID]; ok {\n   121\t\treturn instance.Page, nil\n   122\t}\n   123\n   124\tif runtime.GOOS != \"darwin\" {\n   125\t\treturn nil, fmt.Errorf(\"safari control is only supported on macOS\")\n   126\t}\n   127\n   128\tslog.Info(\"Using system Safari via AppleScript\")\n   129\tpage := &SafariPage{}\n   130\tinstance := &BrowserInstance{\n   131\t\tPage: page,\n   132\t}\n   133\tbm.instances[agentID] = instance\n   134\treturn page, nil\n   135}\n   136\n   137func (bm *BrowserManager) CloseInstance(agentID string) {\n   138\tbm.mu.Lock()\n   139\tdefer bm.mu.Unlock()\n   140\n   141\tif instance, ok := bm.instances[agentID]; ok {\n   142\t\tslog.Info(\"Closing browser instance record for agent\", \"agent_id\", agentID)\n   143\t\tif instance.Page != nil {\n   144\t\t\tinstance.Page.Close()\n   145\t\t}\n   146\t\tdelete(bm.instances, agentID)\n   147\t}\n   148}\n   149\n   150func (bm *BrowserManager) GetAvailableEngines() []string {\n   151\tif runtime.GOOS == \"darwin\" {\n   152\t\tif _, err := os.Stat(\"/Applications/Safari.app\"); err == nil {\n   153\t\t\treturn []string{\"webkit\"}\n   154\t\t}\n   155\t}\n   156\treturn []string{}\n   157}\n   158\n   159func (bm *BrowserManager) Shutdown() {\n   160\tbm.mu.Lock()\n   161\tdefer bm.mu.Unlock()\n   162\n   163\tfor agentID, instance := range bm.instances {\n   164\t\tslog.Info(\"Shutting down browser instance record for agent\", \"agent_id\", agentID)\n   165\t\tif instance.Page != nil {\n   166\t\t\tinstance.Page.Close()\n   167\t\t}\n   168\t}\n   169\tbm.instances = make(map[string]*BrowserInstance)\n   170}\n   171\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"dc4502b4-4dc3-4b48-895d-08f88eb766db","timestamp":"2026-01-03T12:11:12.893Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/utils/browser_manager.go","content":"package utils\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype BrowserPage interface {\n\tGoto(url string) error\n\tClick(selector string) error\n\tFill(selector, value string) error\n\tEvaluate(expression string) (interface{}, error)\n\tInnerText(selector string) (string, error)\n\tURL() string\n\tTitle() (string, error)\n\tClose() error\n}\n\ntype BrowserInstance struct {\n\tPage BrowserPage\n}\n\ntype SafariPage struct {\n\tlastURL string\n}\n\nfunc (s *SafariPage) Goto(url string) error {\n\ts.lastURL = url\n\tcmd := exec.Command(\"osascript\", \"-e\", fmt.Sprintf(`tell application \"Safari\" to open location \"%s\"`, url))\n\tif err := cmd.Run(); err != nil {\n\t\treturn err\n\t}\n\t// Give it a moment to start loading\n\ttime.Sleep(1 * time.Second)\n\treturn nil\n}\n\nfunc (s *SafariPage) Click(selector string) error {\n\t// Very limited support via GUI scripting or JS injection if allowed\n\tscript := fmt.Sprintf(`tell application \"Safari\" to do JavaScript \"document.querySelector('%s').click()\" in document 1`, selector)\n\treturn exec.Command(\"osascript\", \"-e\", script).Run()\n}\n\nfunc (s *SafariPage) Fill(selector, value string) error {\n\tscript := fmt.Sprintf(`tell application \"Safari\" to do JavaScript \"document.querySelector('%s').value = '%s'\" in document 1`, selector, value)\n\treturn exec.Command(\"osascript\", \"-e\", script).Run()\n}\n\nfunc (s *SafariPage) Evaluate(expression string) (interface{}, error) {\n\tscript := fmt.Sprintf(`tell application \"Safari\" to do JavaScript \"%s\" in document 1`, expression)\n\tout, err := exec.Command(\"osascript\", \"-e\", script).Output()\n\treturn string(out), err\n}\n\nfunc (s *SafariPage) InnerText(selector string) (string, error) {\n\tscript := fmt.Sprintf(`tell application \"Safari\" to do JavaScript \"document.querySelector('%s').innerText\" in document 1`, selector)\n\tout, err := exec.Command(\"osascript\", \"-e\", script).Output()\n\treturn strings.TrimSpace(string(out)), err\n}\n\nfunc (s *SafariPage) URL() string {\n\tout, _ := exec.Command(\"osascript\", \"-e\", `tell application \"Safari\" to return URL of current tab of window 1`).Output()\n\treturn strings.TrimSpace(string(out))\n}\n\nfunc (s *SafariPage) Title() (string, error) {\n\tout, err := exec.Command(\"osascript\", \"-e\", `tell application \"Safari\" to return name of current tab of window 1`).Output()\n\treturn strings.TrimSpace(string(out)), err\n}\n\nfunc (s *SafariPage) Close() error {\n\treturn nil // Don't close the user's Safari\n}\n\ntype BrowserManager struct {\n\tinstances        map[string]*BrowserInstance // agentID -> BrowserInstance\n\tmu               sync.RWMutex\n\tcachedEngines    []string\n\tlastEnginesCheck time.Time\n}\n\nvar (\n\tbrowserManager *BrowserManager\n\tbmOnce         sync.Once\n)\n\nfunc GetBrowserManager() *BrowserManager {\n\tbmOnce.Do(func() {\n\t\tbrowserManager = &BrowserManager{\n\t\t\tinstances: make(map[string]*BrowserInstance),\n\t\t}\n\t})\n\treturn browserManager\n}\n\nfunc (bm *BrowserManager) GetPage(agentID string) (BrowserPage, error) {\n\tbm.mu.RLock()\n\tinstance, ok := bm.instances[agentID]\n\tbm.mu.RUnlock()\n\n\tif ok {\n\t\tif instance.Page != nil {\n\t\t\treturn instance.Page, nil\n\t\t}\n\t}\n\n\treturn bm.CreateInstance(agentID)\n}\n\nfunc (bm *BrowserManager) CreateInstance(agentID string) (BrowserPage, error) {\n\tbm.mu.Lock()\n\tdefer bm.mu.Unlock()\n\n\tif instance, ok := bm.instances[agentID]; ok {\n\t\treturn instance.Page, nil\n\t}\n\n\tif runtime.GOOS != \"darwin\" {\n\t\treturn nil, fmt.Errorf(\"safari control is only supported on macOS\")\n\t}\n\n\tslog.Info(\"Using system Safari via AppleScript\")\n\tpage := &SafariPage{}\n\tinstance := &BrowserInstance{\n\t\tPage: page,\n\t}\n\tbm.instances[agentID] = instance\n\treturn page, nil\n}\n\nfunc (bm *BrowserManager) CloseInstance(agentID string) {\n\tbm.mu.Lock()\n\tdefer bm.mu.Unlock()\n\n\tif instance, ok := bm.instances[agentID]; ok {\n\t\tslog.Info(\"Closing browser instance record for agent\", \"agent_id\", agentID)\n\t\tif instance.Page != nil {\n\t\t\tinstance.Page.Close()\n\t\t}\n\t\tdelete(bm.instances, agentID)\n\t}\n}\n\nfunc (bm *BrowserManager) GetAvailableEngines() []string {\n\tif runtime.GOOS == \"darwin\" {\n\t\tif _, err := os.Stat(\"/Applications/Safari.app\"); err == nil {\n\t\t\treturn []string{\"webkit\"}\n\t\t}\n\t}\n\treturn []string{}\n}\n\nfunc (bm *BrowserManager) Shutdown() {\n\tbm.mu.Lock()\n\tdefer bm.mu.Unlock()\n\n\tfor agentID, instance := range bm.instances {\n\t\tslog.Info(\"Shutting down browser instance record for agent\", \"agent_id\", agentID)\n\t\tif instance.Page != nil {\n\t\t\tinstance.Page.Close()\n\t\t}\n\t}\n\tbm.instances = make(map[string]*BrowserInstance)\n}\n","numLines":171,"startLine":1,"totalLines":171}}}
{"parentUuid":"dc4502b4-4dc3-4b48-895d-08f88eb766db","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XuKg7n7fZe6W8C5qsuRoK7","type":"tool_result","content":"     1package main\n     2\n     3import (\n     4\t\"context\"\n     5\t\"database/sql\"\n     6\t\"errors\"\n     7\t\"fmt\"\n     8\t\"log/slog\"\n     9\t\"path/filepath\"\n    10\t\"strings\"\n    11\t\"time\"\n    12\n    13\t\"github.com/google/uuid\"\n    14\t\"github.com/patrick/familiar/packages/go-backend/internal/agent\"\n    15\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n    16\t\"github.com/patrick/familiar/packages/go-backend/internal/utils\"\n    17\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n    18)\n    19\n    20func (s *Server) cleanupAgentRecursive(id string) {\n    21\t// Stop/Cancel the agent if it's in memory\n    22\ts.mu.Lock()\n    23\tsa, ok := s.statefulAgents[id]\n    24\tif ok {\n    25\t\tdelete(s.statefulAgents, id)\n    26\t}\n    27\ts.mu.Unlock()\n    28\n    29\tif ok {\n    30\t\tsa.Cancel()\n    31\t}\n    32\n    33\t// Remove tasks from scheduler\n    34\tif s.scheduler != nil {\n    35\t\ts.scheduler.RemoveTasksForAgent(id)\n    36\t}\n    37}\n    38\n    39func (s *Server) pauseAgentRecursive(agentID string) {\n    40\t// Pause the agent itself\n    41\tsa, err := s.getOrCreateStatefulAgent(agentID)\n    42\tif err != nil {\n    43\t\tslog.Error(\"Failed to get or create agent for pause\", \"agent_id\", agentID, \"error\", err)\n    44\t\treturn\n    45\t}\n    46\n    47\tsa.Pause()\n    48\n    49\t// Broadcast state change immediately so UI updates even if agent is stuck\n    50\tupdatedAgent, _ := s.db.GetAgent(agentID)\n    51\tif updatedAgent != nil {\n    52\t\ts.globalBroadcast(map[string]interface{}{\n    53\t\t\t\"type\":      \"agent_state_changed\",\n    54\t\t\t\"agent\":     updatedAgent,\n    55\t\t\t\"agent_id\":  agentID,\n    56\t\t\t\"new_state\": types.AgentStatePaused,\n    57\t\t})\n    58\t}\n    59\n    60\t// Get all child agents and pause them recursively\n    61\tchildren, err := s.db.ListAgents(&agentID, nil)\n    62\tif err != nil {\n    63\t\tslog.Error(\"Failed to list child agents for pause\", \"agent_id\", agentID, \"error\", err)\n    64\t\treturn\n    65\t}\n    66\n    67\tfor _, child := range children {\n    68\t\ts.pauseAgentRecursive(child.ID)\n    69\t}\n    70}\n    71\n    72func (s *Server) resumeAgentRecursive(agentID string) {\n    73\t// Resume the agent itself\n    74\tif err := s.resumeAgent(agentID, \"\"); err != nil {\n    75\t\tslog.Error(\"Failed to resume agent\", \"agent_id\", agentID, \"error\", err)\n    76\t\treturn\n    77\t}\n    78\n    79\t// Get all child agents and resume them recursively\n    80\tchildren, err := s.db.ListAgents(&agentID, nil)\n    81\tif err != nil {\n    82\t\tslog.Error(\"Failed to list child agents for resume\", \"agent_id\", agentID, \"error\", err)\n    83\t\treturn\n    84\t}\n    85\n    86\tfor _, child := range children {\n    87\t\ts.resumeAgentRecursive(child.ID)\n    88\t}\n    89}\n    90\n    91func (s *Server) resumeAgent(agentID string, prompt string) error {\n    92\tsa, err := s.getOrCreateStatefulAgent(agentID)\n    93\tif err != nil {\n    94\t\tslog.Error(\"Failed to get or create agent for resume\", \"agent_id\", agentID, \"error\", err)\n    95\t\terrDetail := &types.ErrorDetail{\n    96\t\t\tCategory:    types.ErrorInitialization,\n    97\t\t\tMessage:     err.Error(),\n    98\t\t\tRecoverable: true,\n    99\t\t}\n   100\t\ts.db.UpdateAgentState(agentID, types.AgentStateError, errDetail)\n   101\t\ts.globalBroadcast(map[string]interface{}{\n   102\t\t\t\"type\":         \"agent_state_changed\",\n   103\t\t\t\"agent_id\":     agentID,\n   104\t\t\t\"new_state\":    types.AgentStateError,\n   105\t\t\t\"error_detail\": errDetail,\n   106\t\t})\n   107\t\treturn err\n   108\t}\n   109\n   110\tif prompt != \"\" {\n   111\t\tsa.EnqueueMessage(types.Message{\n   112\t\t\tID:        uuid.New().String(),\n   113\t\t\tRole:      \"user\",\n   114\t\t\tContent:   prompt,\n   115\t\t\tTimestamp: time.Now().UnixNano() / int64(time.Millisecond),\n   116\t\t})\n   117\t}\n   118\n   119\tif sa.IsRunning() {\n   120\t\tsa.Resume()\n   121\t\treturn nil\n   122\t}\n   123\n   124\t// Start the loop\n   125\tgo func() {\n   126\t\ta, err := s.db.GetAgent(agentID)\n   127\t\tif err != nil {\n   128\t\t\tslog.Error(\"Failed to get agent for run\", \"agent_id\", agentID, \"error\", err)\n   129\t\t\treturn\n   130\t\t}\n   131\t\t// Fetch logs for context\n   132\t\thistory, _ := s.db.ListAgentLogs(agentID)\n   133\n   134\t\t// Fetch parent scope if applicable\n   135\t\tvar parentScope *types.ScopeDocument\n   136\t\tif a.ParentID != nil {\n   137\t\t\tparentScope, _ = s.db.GetCurrentScope(*a.ParentID)\n   138\t\t}\n   139\n   140\t\t// Update state in DB first\n   141\t\ts.db.UpdateAgentState(agentID, types.AgentStateRunning, nil)\n   142\t\ts.globalBroadcast(map[string]interface{}{\n   143\t\t\t\"type\":         \"agent_state_changed\",\n   144\t\t\t\"agent_id\":     agentID,\n   145\t\t\t\"new_state\":    types.AgentStateRunning,\n   146\t\t\t\"error_detail\": nil,\n   147\t\t})\n   148\n   149\t\tif err := sa.Run(context.Background(), a.InitialPrompt, history, parentScope); err != nil {\n   150\t\t\tslog.Error(\"Agent run failed\", \"agent_id\", agentID, \"error\", err)\n   151\t\t\terrDetail := &types.ErrorDetail{\n   152\t\t\t\tCategory:    types.ErrorToolFailure,\n   153\t\t\t\tMessage:     err.Error(),\n   154\t\t\t\tRecoverable: true,\n   155\t\t\t}\n   156\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateError, errDetail)\n   157\t\t\ts.globalBroadcast(map[string]interface{}{\n   158\t\t\t\t\"type\":         \"agent_state_changed\",\n   159\t\t\t\t\"agent_id\":     agentID,\n   160\t\t\t\t\"new_state\":    types.AgentStateError,\n   161\t\t\t\t\"error_detail\": errDetail,\n   162\t\t\t})\n   163\n   164\t\t\t// If it's a sub-agent, notify the parent agent of the error\n   165\t\t\tif a.ParentID != nil {\n   166\t\t\t\t// Wait for parent to finish its current turn if it's running\n   167\t\t\t\t// to avoid jarring UI interleaving where error appears before spawn confirmation\n   168\t\t\t\ts.mu.RLock()\n   169\t\t\t\tparentSA, hasParent := s.statefulAgents[*a.ParentID]\n   170\t\t\t\ts.mu.RUnlock()\n   171\t\t\t\tif hasParent {\n   172\t\t\t\t\tfor i := 0; i < 20; i++ { // Max 4 seconds wait\n   173\t\t\t\t\t\tif !parentSA.IsRunning() || parentSA.GetState() != types.AgentStateRunning {\n   174\t\t\t\t\t\t\tbreak\n   175\t\t\t\t\t\t}\n   176\t\t\t\t\t\ttime.Sleep(200 * time.Millisecond)\n   177\t\t\t\t\t}\n   178\t\t\t\t}\n   179\n   180\t\t\t\tpayload := map[string]interface{}{\n   181\t\t\t\t\t\"sub_agent_id\": agentID,\n   182\t\t\t\t\t\"message\":      fmt.Sprintf(\"The sub-agent encountered an error: %v\", err),\n   183\t\t\t\t}\n   184\n   185\t\t\t\tlogID, _ := s.db.AppendAgentLog(*a.ParentID, \"sub_agent_error\", payload)\n   186\t\t\t\tpayload[\"id\"] = logID\n   187\n   188\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   189\t\t\t\t\t\"type\":       \"execution_log\",\n   190\t\t\t\t\t\"agent_id\":   *a.ParentID,\n   191\t\t\t\t\t\"event_type\": \"sub_agent_error\",\n   192\t\t\t\t\t\"payload\":    payload,\n   193\t\t\t\t})\n   194\n   195\t\t\t\t// Notify parent of the error\n   196\t\t\t\tif parent, err := s.getOrCreateStatefulAgent(*a.ParentID); err == nil {\n   197\t\t\t\t\tparent.EnqueueAgentMessage(agentID, fmt.Sprintf(\"Sub-agent '%s' encountered an error: %v\", a.Name, err))\n   198\t\t\t\t}\n   199\n   200\t\t\t\t// Auto-resume parent so it can handle the error\n   201\t\t\t\ts.resumeAgent(*a.ParentID, \"\")\n   202\t\t\t}\n   203\t\t} else {\n   204\t\t\tfinalState := sa.GetState()\n   205\t\t\tif finalState == types.AgentStateIdle {\n   206\t\t\t\t// Check if there are pending tasks or sub-agents\n   207\t\t\t\ttasks, _ := s.db.ListTasks()\n   208\t\t\t\thasWork := false\n   209\t\t\t\tfor _, t := range tasks {\n   210\t\t\t\t\tif t.ParentAgentID == agentID && (t.Status == \"pending\" || t.Status == \"running\") {\n   211\t\t\t\t\t\thasWork = true\n   212\t\t\t\t\t\tbreak\n   213\t\t\t\t\t}\n   214\t\t\t\t}\n   215\t\t\t\tif !hasWork {\n   216\t\t\t\t\tsubAgents, _ := s.db.ListAgents(&agentID, nil)\n   217\t\t\t\t\tfor _, sub := range subAgents {\n   218\t\t\t\t\t\tif sub.State != types.AgentStateIdle && sub.State != types.AgentStateError {\n   219\t\t\t\t\t\t\thasWork = true\n   220\t\t\t\t\t\t\tbreak\n   221\t\t\t\t\t\t}\n   222\t\t\t\t\t}\n   223\t\t\t\t}\n   224\t\t\t\tif hasWork {\n   225\t\t\t\t\tfinalState = types.AgentStateWaiting\n   226\t\t\t\t\tsa.SetState(finalState)\n   227\t\t\t\t}\n   228\t\t\t}\n   229\n   230\t\t\ts.db.UpdateAgentState(agentID, finalState, nil)\n   231\t\t\ts.globalBroadcast(map[string]interface{}{\n   232\t\t\t\t\"type\":      \"agent_state_changed\",\n   233\t\t\t\t\"agent_id\":  agentID,\n   234\t\t\t\t\"new_state\": finalState,\n   235\t\t\t})\n   236\t\t\tif finalState == types.AgentStateIdle && a.ParentID != nil {\n   237\t\t\t\t// Wait for parent to finish its current turn if it's running\n   238\t\t\t\ts.mu.RLock()\n   239\t\t\t\tparentSA, hasParent := s.statefulAgents[*a.ParentID]\n   240\t\t\t\ts.mu.RUnlock()\n   241\t\t\t\tif hasParent {\n   242\t\t\t\t\tfor i := 0; i < 20; i++ { // Max 4 seconds wait\n   243\t\t\t\t\t\tif !parentSA.IsRunning() || parentSA.GetState() != types.AgentStateRunning {\n   244\t\t\t\t\t\t\tbreak\n   245\t\t\t\t\t\t}\n   246\t\t\t\t\t\ttime.Sleep(200 * time.Millisecond)\n   247\t\t\t\t\t}\n   248\t\t\t\t}\n   249\n   250\t\t\t\t// Always notify the parent when a sub-agent completes.\n   251\t\t\t\t// This ensures the parent's orchestration loop wakes up and notices the change.\n   252\t\t\t\tmsgContent := fmt.Sprintf(\"Sub-agent '%s' has completed its assigned task.\", a.Name)\n   253\n   254\t\t\t\tpayload := map[string]interface{}{\n   255\t\t\t\t\t\"sender_id\": agentID,\n   256\t\t\t\t\t\"content\":   msgContent,\n   257\t\t\t\t}\n   258\t\t\t\tlogID, _ := s.db.AppendAgentLog(*a.ParentID, \"agent_message\", payload)\n   259\t\t\t\tpayload[\"id\"] = logID\n   260\n   261\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   262\t\t\t\t\t\"type\":       \"execution_log\",\n   263\t\t\t\t\t\"agent_id\":   *a.ParentID,\n   264\t\t\t\t\t\"event_type\": \"agent_message\",\n   265\t\t\t\t\t\"payload\":    payload,\n   266\t\t\t\t})\n   267\n   268\t\t\t\t// Route message to parent agent's queue\n   269\t\t\t\tif parent, err := s.getOrCreateStatefulAgent(*a.ParentID); err == nil {\n   270\t\t\t\t\tparent.EnqueueAgentMessage(agentID, msgContent)\n   271\t\t\t\t}\n   272\n   273\t\t\t\ts.globalBroadcast(map[string]interface{}{\n   274\t\t\t\t\t\"type\":      \"sub_agent_completed\",\n   275\t\t\t\t\t\"parent_id\": *a.ParentID,\n   276\t\t\t\t\t\"child_id\":  agentID,\n   277\t\t\t\t\t\"result\": types.SubAgentResult{\n   278\t\t\t\t\t\tSubAgentID: agentID,\n   279\t\t\t\t\t\tFindings:   msgContent,\n   280\t\t\t\t\t},\n   281\t\t\t\t})\n   282\n   283\t\t\t\t// Auto-resume parent so it can process the completion\n   284\t\t\t\ts.resumeAgent(*a.ParentID, \"\")\n   285\t\t\t}\n   286\t\t}\n   287\t}()\n   288\treturn nil\n   289}\n   290\n   291func (s *Server) getOrCreateStatefulAgent(agentID string) (*agent.StatefulAgent, error) {\n   292\ts.mu.RLock()\n   293\tsa, ok := s.statefulAgents[agentID]\n   294\ts.mu.RUnlock()\n   295\n   296\ta, err := s.db.GetAgent(agentID)\n   297\tif err != nil {\n   298\t\tif errors.Is(err, sql.ErrNoRows) {\n   299\t\t\treturn nil, fmt.Errorf(\"agent not found: agent with ID %s does not exist in the database\", agentID)\n   300\t\t}\n   301\t\treturn nil, err\n   302\t}\n   303\n   304\tscope, _ := s.db.GetCurrentScope(agentID)\n   305\tcfg, _ := config.LoadConfig()\n   306\n   307\t// Always validate provider is enabled and reachable\n   308\tprovider, err := s.createProvider(a.ModelConfig.Provider)\n   309\tif err != nil {\n   310\t\tif ok {\n   311\t\t\t// Stop and remove from cache if it was there but is now invalid\n   312\t\t\ts.mu.Lock()\n   313\t\t\tdelete(s.statefulAgents, agentID)\n   314\t\t\ts.mu.Unlock()\n   315\t\t\tsa.Cancel()\n   316\t\t}\n   317\t\treturn nil, err\n   318\t}\n   319\n   320\tif ok {\n   321\t\t// Update cached agent with latest provider and config in case they changed\n   322\t\tsa.UpdateModelConfig(a.ModelConfig, provider)\n   323\n   324\t\t// Refresh skills\n   325\t\tloader := utils.NewSkillLoader(getProgramDataPath())\n   326\t\tif skills, err := loader.LoadSkills(); err == nil {\n   327\t\t\tsa.Skills = skills\n   328\t\t}\n   329\n   330\t\t// Update max_context_tokens in database when model changes\n   331\t\tmaxContextTokens := sa.MaxContextTokens\n   332\t\ts.db.UpdateAgentContextUsage(agentID, a.ContextTokens, maxContextTokens)\n   333\t\tsa.AlwaysAllowAll = config.GetAlwaysAllowAll()\n   334\n   335\t\t// Always refresh system prompt for internal agents to ensure they use the latest logic\n   336\t\tif a.IsInternal {\n   337\t\t\tsystemPrompt, _ := s.db.GetActiveSystemPrompt()\n   338\t\t\tif strings.Contains(strings.ToLower(a.Name), \"skill architect\") {\n   339\t\t\t\tsystemPrompt = `You are the Skill Architect. Help the user create, implement, and test new \"Familiar Skills\".\n   340\n   341Be terse. No narrative filler.\n   342\n   343CRITICAL - TOOL USAGE:\n   344- You MUST call tools to perform actions. DO NOT just describe what you will do - actually call the tool.\n   345- When asked to save a secret, IMMEDIATELY call 'vault_save' with the key name(s).\n   346- When asked to create a skill, IMMEDIATELY call 'workspace_write' with the file contents.\n   347- NEVER say \"I'll do X\" and then stop. Always follow through by calling the appropriate tool.\n   348\n   349WORKSPACE:\n   350Your workspace root is the \"skills\" directory. All files you create MUST be inside a sub-directory named after the skill (e.g. 'my-skill/skill.md').\n   351\n   352SKILL STRUCTURE:\n   353To create a new skill, you must create a directory within your workspace root named with the skill's slug. A skill consists of:\n   3541. <skill-slug>/skill.md: YAML frontmatter with 'name' and 'description'.\n   3552. <skill-slug>/...: Optional helper scripts (Python, Bash, etc.) or other assets.\n   356\n   357SECRETS:\n   358- **CRITICAL**: Never ask the user to provide secrets (API keys, tokens, etc.) directly in chat.\n   359- You MUST warn the user: \"Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them.\"\n   360- If a skill needs one or more secrets, you MUST call the 'vault_save' tool with descriptive key names.\n   361- The 'vault_save' tool will trigger a secure, private input dialog for the user for each key.\n   362- Once saved, use the placeholder '{{vault:KEY_NAME}}' in your scripts or skill commands. The system will automatically substitute the actual value at execution time and mask it in logs.\n   363- You can check if a secret already exists using 'vault_list'. If it exists, don't ask to save it again unless the user wants to update it.\n   364\n   365WORKFLOW:\n   366- Use 'vault_list' to check if necessary secrets are already configured.\n   367- Call 'vault_save' to request missing secrets from the user securely.\n   368- Call 'workspace_write' to create the skill's directory and files by providing a path like 'skill-name/skill.md'.\n   369- Suggest content for 'skill.md' and any accompanying scripts.\n   370- Use 'workspace_list' and 'workspace_read' for examples of existing skills.`\n   371\t\t\t} else if strings.Contains(strings.ToLower(a.Name), \"trigger architect\") {\n   372\t\t\t\tsystemPrompt = `You are the Trigger Architect. Help the user create, implement, and test new \"Familiar Triggers\" and manage their subscriptions.\n   373\n   374Be terse. No narrative filler.\n   375\n   376CRITICAL - TOOL USAGE:\n   377- You MUST call tools to perform actions. DO NOT just describe what you will do - actually call the tool.\n   378- When asked to save a secret, IMMEDIATELY call 'vault_save' with the key name(s).\n   379- When asked to create a trigger, IMMEDIATELY call 'workspace_write' with the file contents.\n   380- NEVER say \"I'll do X\" and then stop. Always follow through by calling the appropriate tool.\n   381\n   382WORKSPACE:\n   383Your workspace root is the \"triggers\" directory. All files you create MUST be inside a sub-directory named after the trigger's slug (e.g. 'my-trigger/trigger.yaml'). Use 'workspace_write' to create files within these sub-directories.\n   384\n   385TRIGGER STRUCTURE (Script Triggers):\n   386To create a new script-based trigger, you must create a directory within your workspace root named with the trigger's slug. A trigger consists of:\n   3871. <trigger-slug>/trigger.yaml: YAML configuration with:\n   388   - name: Unique identifier for the trigger.\n   389   - description: Human-readable description.\n   390   - script: Path to the executable script (e.g., 'monitor.sh').\n   391   - mode: \"daemon\" (runs continuously, emits lines from stdout) or \"poll\" (runs periodically).\n   392   - interval: (For poll mode) e.g., \"10s\", \"1m\".\n   393   - enabled: true\n   394   - env: (Optional) Map of environment variables for the script.\n   3952. <trigger-slug>/<script-file>: The actual script that monitors for events. \n   396\n   397BACKGROUND EXECUTION:\n   398- **CRITICAL**: Do NOT ask the user to manually install system-level daemons (like LaunchDaemons on macOS or systemd on Linux). \n   399- Instead, use 'mode: daemon' in 'trigger.yaml'. The Familiar system will automatically manage the lifecycle of your script.\n   400- Your script should run in a loop (if daemon) or perform a check (if poll) and print any events to STDOUT. Each line printed to STDOUT will be treated as a trigger event.\n   401\n   402SECRETS:\n   403- **CRITICAL**: Never ask the user to provide secrets (API keys, tokens, etc.) directly in chat.\n   404- You MUST warn the user: \"Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them.\"\n   405- If a trigger needs secrets (e.g. for API polling), you MUST call the 'vault_save' tool with descriptive key names.\n   406- The 'vault_save' tool will trigger a secure, private input dialog for the user for each key.\n   407- Once saved, use the placeholder '{{vault:KEY_NAME}}' in the 'env' map within 'trigger.yaml'. The system will automatically substitute the actual value at execution time and mask it in logs.\n   408- You can check if a secret already exists using 'vault_list'.\n   409\n   410SUBSCRIPTIONS:\n   411Users can subscribe agents to triggers. When a trigger fires, the subscribed agent is woken up with a message based on a prompt template.\n   412- Use 'trigger_subscribe' to create or update a subscription.\n   413- The 'prompt_template' can use '{{output}}' which will be replaced by the trigger's output (the line from STDOUT).\n   414\n   415WORKFLOW:\n   4161. **Explore**: Use 'list_triggers' to see available triggers.\n   4172. **Secrets**: If needed, use 'vault_list' and 'vault_save' to manage credentials.\n   4183. **Create**: To create a new script trigger:\n   419   - **MUST**: Create a sub-directory first by writing a file into it.\n   420   - Use 'workspace_write' to create the configuration: 'my-trigger/trigger.yaml' (including 'env' for secrets).\n   421   - Use 'workspace_write' to create the script: 'my-trigger/monitor.sh'.\n   4224. **Subscribe**: Use 'trigger_subscribe' to connect an agent to a trigger.\n   423\n   424CRITICAL:\n   425- NEVER create files directly in the base \"triggers\" directory. ALWAYS use a sub-directory.\n   426- ALWAYS use tools to perform actions. Never just describe what you will do.`\n   427\t\t\t} else if a.Name == \"Feedback Collector\" {\n   428\t\t\t\tsystemPrompt = `You are the Feedback Collector for Familiar. Your goal is to help users report bugs, suggest features, or provide general feedback.\n   429\n   430BE TERSE. NO NARRATIVE FILLER.\n   431\n   432ALLOWED TOOLS:\n   433- 'screenshot_take': Take a screenshot of the user's current screen. (REQUIRES confirmation)\n   434- 'submit_feedback': Send the collected feedback and optional screenshot to the development team.\n   435\n   436WORKFLOW:\n   4371. Ask the user for details about their feedback.\n   4382. If appropriate (e.g. reporting a UI bug), offer to take a screenshot using 'screenshot_take'.\n   4393. Once you have the feedback (and optional screenshot), use 'submit_feedback' to send it to the development team.\n   4404. Confirm success and thank the user.\n   441\n   442CRITICAL:\n   443- 'screenshot_take' REQUIRES explicit user approval. You MUST inform the user you are about to take a screenshot and wait for their confirmation if they haven't already given it in chat.\n   444- After taking a screenshot, immediately use the returned path in 'submit_feedback'.`\n   445\t\t\t}\n   446\t\t\tsa.SystemPrompt = systemPrompt\n   447\t\t}\n   448\t} else {\n   449\t\truntime := agent.NewRuntimeAgent(provider, a.ModelConfig.Model)\n   450\t\tsystemPrompt, _ := s.db.GetActiveSystemPrompt()\n   451\n   452\t\t// Use agent-specific system prompt if set\n   453\t\tif a.SystemPrompt != \"\" {\n   454\t\t\tsystemPrompt = a.SystemPrompt\n   455\t\t}\n   456\n   457\t\t// Load skills for the agent\n   458\t\tloader := utils.NewSkillLoader(getProgramDataPath())\n   459\t\tif skills, err := loader.LoadSkills(); err == nil {\n   460\t\t\truntime.Skills = skills\n   461\t\t}\n   462\n   463\t\tif a.IsInternal && strings.Contains(strings.ToLower(a.Name), \"skill architect\") {\n   464\t\t\tsystemPrompt = `You are the Skill Architect. Help the user create, implement, and test new \"Familiar Skills\".\n   465\n   466Be terse. No narrative filler.\n   467\n   468CRITICAL - TOOL USAGE:\n   469- You MUST call tools to perform actions. DO NOT just describe what you will do - actually call the tool.\n   470- When asked to save a secret, IMMEDIATELY call 'vault_save' with the key name(s).\n   471- When asked to create a skill, IMMEDIATELY call 'workspace_write' with the file contents.\n   472- NEVER say \"I'll do X\" and then stop. Always follow through by calling the appropriate tool.\n   473\n   474WORKSPACE:\n   475Your workspace root is the \"skills\" directory. All files you create MUST be inside a sub-directory named after the skill (e.g. 'my-skill/skill.md').\n   476\n   477SKILL STRUCTURE:\n   478To create a new skill, you must create a directory within your workspace root named with the skill's slug. A skill consists of:\n   4791. <skill-slug>/skill.md: YAML frontmatter with 'name' and 'description'.\n   4802. <skill-slug>/...: Optional helper scripts (Python, Bash, etc.) or other assets.\n   481\n   482SECRETS:\n   483- **CRITICAL**: Never ask the user to provide secrets (API keys, tokens, etc.) directly in chat.\n   484- You MUST warn the user: \"Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them.\"\n   485- If a skill needs one or more secrets, you MUST call the 'vault_save' tool with descriptive key names.\n   486- The 'vault_save' tool will trigger a secure, private input dialog for the user for each key.\n   487- Once saved, use the placeholder '{{vault:KEY_NAME}}' in your scripts or skill commands. The system will automatically substitute the actual value at execution time and mask it in logs.\n   488- You can check if a secret already exists using 'vault_list'. If it exists, don't ask to save it again unless the user wants to update it.\n   489\n   490WORKFLOW:\n   491- Use 'vault_list' to check if necessary secrets are already configured.\n   492- Call 'vault_save' to request missing secrets from the user securely.\n   493- Call 'workspace_write' to create the skill's directory and files by providing a path like 'skill-name/skill.md'.\n   494- Suggest content for 'skill.md' and any accompanying scripts.\n   495- Use 'workspace_list' and 'workspace_read' for examples of existing skills.`\n   496\t\t} else if a.IsInternal && strings.Contains(strings.ToLower(a.Name), \"trigger architect\") {\n   497\t\t\tsystemPrompt = `You are the Trigger Architect. Help the user create, implement, and test new \"Familiar Triggers\" and manage their subscriptions.\n   498\n   499Be terse. No narrative filler.\n   500\n   501CRITICAL - TOOL USAGE:\n   502- You MUST call tools to perform actions. DO NOT just describe what you will do - actually call the tool.\n   503- When asked to save a secret, IMMEDIATELY call 'vault_save' with the key name(s).\n   504- When asked to create a trigger, IMMEDIATELY call 'workspace_write' with the file contents.\n   505- NEVER say \"I'll do X\" and then stop. Always follow through by calling the appropriate tool.\n   506\n   507WORKSPACE:\n   508Your workspace root is the \"triggers\" directory. All files you create MUST be inside a sub-directory named after the trigger's slug (e.g. 'my-trigger/trigger.yaml'). Use 'workspace_write' to create files within these sub-directories.\n   509\n   510TRIGGER STRUCTURE (Script Triggers):\n   511To create a new script-based trigger, you must create a directory within your workspace root named with the trigger's slug. A trigger consists of:\n   5121. <trigger-slug>/trigger.yaml: YAML configuration with:\n   513   - name: Unique identifier for the trigger.\n   514   - description: Human-readable description.\n   515   - script: Path to the executable script (e.g., 'monitor.sh').\n   516   - mode: \"daemon\" (runs continuously, emits lines from stdout) or \"poll\" (runs periodically).\n   517   - interval: (For poll mode) e.g., \"10s\", \"1m\".\n   518   - enabled: true\n   519   - env: (Optional) Map of environment variables for the script.\n   5202. <trigger-slug>/<script-file>: The actual script that monitors for events. \n   521\n   522BACKGROUND EXECUTION:\n   523- **CRITICAL**: Do NOT ask the user to manually install system-level daemons (like LaunchDaemons on macOS or systemd on Linux). \n   524- Instead, use 'mode: daemon' in 'trigger.yaml'. The Familiar system will automatically manage the lifecycle of your script.\n   525- Your script should run in a loop (if daemon) or perform a check (if poll) and print any events to STDOUT. Each line printed to STDOUT will be treated as a trigger event.\n   526\n   527SECRETS:\n   528- **CRITICAL**: Never ask the user to provide secrets (API keys, tokens, etc.) directly in chat.\n   529- You MUST warn the user: \"Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them.\"\n   530- If a trigger needs secrets (e.g. for API polling), you MUST call the 'vault_save' tool with descriptive key names.\n   531- The 'vault_save' tool will trigger a secure, private input dialog for the user for each key.\n   532- Once saved, use the placeholder '{{vault:KEY_NAME}}' in the 'env' map within 'trigger.yaml'. The system will automatically substitute the actual value at execution time and mask it in logs.\n   533- You can check if a secret already exists using 'vault_list'.\n   534\n   535SUBSCRIPTIONS:\n   536Users can subscribe agents to triggers. When a trigger fires, the subscribed agent is woken up with a message based on a prompt template.\n   537- Use 'trigger_subscribe' to create or update a subscription.\n   538- The 'prompt_template' can use '{{output}}' which will be replaced by the trigger's output (the line from STDOUT).\n   539\n   540WORKFLOW:\n   5411. **Explore**: Use 'list_triggers' to see available triggers.\n   5422. **Secrets**: If needed, use 'vault_list' and 'vault_save' to manage credentials.\n   5433. **Create**: To create a new script trigger:\n   544   - **MUST**: Create a sub-directory first by writing a file into it.\n   545   - Use 'workspace_write' to create the configuration: 'my-trigger/trigger.yaml' (including 'env' for secrets).\n   546   - Use 'workspace_write' to create the script: 'my-trigger/monitor.sh'.\n   5474. **Subscribe**: Use 'trigger_subscribe' to connect an agent to a trigger.\n   548\n   549CRITICAL:\n   550- NEVER create files directly in the base \"triggers\" directory. ALWAYS use a sub-directory.\n   551- ALWAYS use tools to perform actions. Never just describe what you will do.`\n   552\t\t} else if a.IsInternal && a.Name == \"Feedback Collector\" {\n   553\t\t\tsystemPrompt = `You are the Feedback Collector for Familiar. Your goal is to help users report bugs, suggest features, or provide general feedback.\n   554\n   555BE TERSE. NO NARRATIVE FILLER.\n   556\n   557ALLOWED TOOLS:\n   558- 'screenshot_take': Take a screenshot of the user's current screen. (REQUIRES confirmation)\n   559- 'submit_feedback': Send the collected feedback and optional screenshot to the development team.\n   560\n   561WORKFLOW:\n   5621. Ask the user for details about their feedback.\n   5632. If appropriate (e.g. reporting a UI bug), offer to take a screenshot using 'screenshot_take'.\n   5643. Once you have the feedback (and optional screenshot), use 'submit_feedback' to send it to the development team.\n   5654. Confirm success and thank the user.\n   566\n   567CRITICAL:\n   568- 'screenshot_take' REQUIRES explicit user approval. You MUST inform the user you are about to take a screenshot and wait for their confirmation if they haven't already given it in chat.\n   569- After taking a screenshot, immediately use the returned path in 'submit_feedback'.`\n   570\t\t}\n   571\t\truntime.SystemPrompt = systemPrompt\n   572\t\ts.registerTools(runtime, provider, cfg, a)\n   573\n   574\t\tworkspacePath := s.getAgentWorkspacePath(agentID)\n   575\t\tsa = agent.NewStatefulAgent(runtime, *a, scope, workspacePath, s.db)\n   576\n   577\t\t// If agent state is Running but it's a new instance (not actually running), reset to Idle\n   578\t\t// This handles stale states from crashes/restarts\n   579\t\tif a.State == types.AgentStateRunning && !sa.IsRunning() {\n   580\t\t\tslog.Info(\"Detected stale running state, resetting to idle\", \"agent_id\", agentID, \"agent_name\", a.Name)\n   581\t\t\tsa.SetState(types.AgentStateIdle)\n   582\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateIdle, nil)\n   583\t\t\ts.globalBroadcast(map[string]interface{}{\n   584\t\t\t\t\"type\":      \"agent_state_changed\",\n   585\t\t\t\t\"agent_id\":  agentID,\n   586\t\t\t\t\"new_state\": types.AgentStateIdle,\n   587\t\t\t})\n   588\t\t}\n   589\t}\n   590\n   591\t// Fetch and persist context limit from provider (use fetched value, not stored value)\n   592\t// This ensures we always have the latest context limit from the provider\n   593\tmaxContextTokens := sa.MaxContextTokens\n   594\tif maxContextTokens == 0 {\n   595\t\t// Fallback to stored value if provider didn't return a limit\n   596\t\tmaxContextTokens = a.MaxContextTokens\n   597\t\tif maxContextTokens == 0 {\n   598\t\t\tmaxContextTokens = 128000 // Final fallback\n   599\t\t}\n   600\t}\n   601\ts.db.UpdateAgentContextUsage(agentID, a.ContextTokens, maxContextTokens)\n   602\n   603\tsa.OnLog = func(agentID, eventType string, payload interface{}) {\n   604\t\tid, _ := s.db.AppendAgentLog(agentID, eventType, payload)\n   605\t\t// If the payload is a map, inject the ID if not already present\n   606\t\tif m, ok := payload.(map[string]interface{}); ok {\n   607\t\t\tif _, exists := m[\"id\"]; !exists {\n   608\t\t\t\tm[\"id\"] = id\n   609\t\t\t}\n   610\t\t}\n   611\t\ts.globalBroadcast(map[string]interface{}{\n   612\t\t\t\"type\":       \"execution_log\",\n   613\t\t\t\"agent_id\":   agentID,\n   614\t\t\t\"event_type\": eventType,\n   615\t\t\t\"payload\":    payload,\n   616\t\t})\n   617\t}\n   618\tsa.OnUsage = func(usage types.UsageRecord) {\n   619\t\tif err := s.db.SaveUsage(&usage); err != nil {\n   620\t\t\tslog.Error(\"Failed to save usage record\", \"agent_id\", usage.AgentID, \"error\", err, \"usage\", usage)\n   621\t\t}\n   622\t}\n   623\tsa.OnStateChange = func(agentID string, newState types.AgentState) {\n   624\t\ts.db.UpdateAgentState(agentID, newState, nil)\n   625\t\ts.globalBroadcast(map[string]interface{}{\n   626\t\t\t\"type\":      \"agent_state_changed\",\n   627\t\t\t\"agent_id\":  agentID,\n   628\t\t\t\"new_state\": newState,\n   629\t\t})\n   630\t}\n   631\tsa.OnContextUpdate = func(agentID string, contextTokens, maxContextTokens int) {\n   632\t\ts.db.UpdateAgentContextUsage(agentID, contextTokens, maxContextTokens)\n   633\t\ts.globalBroadcast(map[string]interface{}{\n   634\t\t\t\"type\":               \"agent_context_updated\",\n   635\t\t\t\"agent_id\":           agentID,\n   636\t\t\t\"context_tokens\":     contextTokens,\n   637\t\t\t\"max_context_tokens\": maxContextTokens,\n   638\t\t})\n   639\t}\n   640\tsa.OnCompactingUpdate = func(agentID string, isCompacting bool) {\n   641\t\ts.db.UpdateAgentCompacting(agentID, isCompacting)\n   642\t\ts.globalBroadcast(map[string]interface{}{\n   643\t\t\t\"type\":          \"agent_compacting_updated\",\n   644\t\t\t\"agent_id\":      agentID,\n   645\t\t\t\"is_compacting\": isCompacting,\n   646\t\t})\n   647\t}\n   648\tsa.OnCheckApproval = func(toolName, command string) (bool, error) {\n   649\t\treturn s.db.IsToolCallApproved(toolName, command)\n   650\t}\n   651\tsa.OnGetVaultSecrets = func() []string {\n   652\t\tsecrets, err := s.db.ListVaultSecrets()\n   653\t\tif err != nil {\n   654\t\t\treturn []string{}\n   655\t\t}\n   656\t\tnames := make([]string, len(secrets))\n   657\t\tfor i, s := range secrets {\n   658\t\t\tnames[i] = s.Name\n   659\t\t}\n   660\t\treturn config.GetVaultSecretValues(names)\n   661\t}\n   662\tsa.OnListVaultNames = func() []string {\n   663\t\tsecrets, err := s.db.ListVaultSecrets()\n   664\t\tif err != nil {\n   665\t\t\treturn []string{}\n   666\t\t}\n   667\t\tnames := make([]string, len(secrets))\n   668\t\tfor i, s := range secrets {\n   669\t\t\tnames[i] = s.Name\n   670\t\t}\n   671\t\treturn names\n   672\t}\n   673\tsa.OnSubAgentOutput = func(subAgentID string, content string) {\n   674\t\t// Get the subagent to find its parent\n   675\t\tsubAgent, err := s.db.GetAgent(subAgentID)\n   676\t\tif err != nil {\n   677\t\t\tslog.Error(\"Failed to get subagent for output piping\", \"sub_agent_id\", subAgentID, \"error\", err)\n   678\t\t\treturn\n   679\t\t}\n   680\t\tif subAgent.ParentID == nil {\n   681\t\t\t// Not a subagent, nothing to do\n   682\t\t\treturn\n   683\t\t}\n   684\n   685\t\tparentID := *subAgent.ParentID\n   686\n   687\t\t// Get or create the parent stateful agent\n   688\t\tparent, err := s.getOrCreateStatefulAgent(parentID)\n   689\t\tif err != nil {\n   690\t\t\tslog.Error(\"Failed to get parent agent for subagent output\", \"parent_id\", parentID, \"sub_agent_id\", subAgentID, \"error\", err)\n   691\t\t\treturn\n   692\t\t}\n   693\n   694\t\t// Log the message in the parent's history\n   695\t\tpayload := map[string]interface{}{\n   696\t\t\t\"sender_id\":    subAgentID,\n   697\t\t\t\"content\":      content,\n   698\t\t\t\"sub_agent_id\": subAgentID,\n   699\t\t}\n   700\t\tlogID, _ := s.db.AppendAgentLog(parentID, \"sub_agent_report\", payload)\n   701\t\tpayload[\"id\"] = logID\n   702\n   703\t\ts.globalBroadcast(map[string]interface{}{\n   704\t\t\t\"type\":       \"execution_log\",\n   705\t\t\t\"agent_id\":   parentID,\n   706\t\t\t\"event_type\": \"sub_agent_report\",\n   707\t\t\t\"payload\":    payload,\n   708\t\t})\n   709\n   710\t\t// Route message to the parent agent's input queue\n   711\t\tparent.EnqueueAgentMessage(subAgentID, content)\n   712\n   713\t\t// Ensure the parent is running or resumed\n   714\t\tif !parent.IsRunning() {\n   715\t\t\tif err := s.resumeAgent(parentID, \"\"); err != nil {\n   716\t\t\t\tslog.Error(\"Failed to resume parent agent after subagent output\", \"parent_id\", parentID, \"error\", err)\n   717\t\t\t}\n   718\t\t} else {\n   719\t\t\t// Parent is running but might be waiting - wake it up to process the message\n   720\t\t\tparent.Resume()\n   721\t\t}\n   722\t}\n   723\tsa.AlwaysAllowAll = cfg.Security.AlwaysAllowAll\n   724\tif a.IsInternal && a.Name == \"Feedback Collector\" {\n   725\t\tsa.AlwaysAllowAll = true\n   726\t}\n   727\n   728\tif !ok {\n   729\t\t// Trigger initial context usage calculation only for new agents\n   730\t\thistory, _ := s.db.ListAgentLogs(agentID)\n   731\t\tsa.RecalculateContextUsage(history)\n   732\n   733\t\ts.mu.Lock()\n   734\t\ts.statefulAgents[agentID] = sa\n   735\t\ts.mu.Unlock()\n   736\t}\n   737\n   738\treturn sa, nil\n   739}\n   740\n   741func (s *Server) getAgentWorkspacePath(agentID string) string {\n   742\ta, err := s.db.GetAgent(agentID)\n   743\tif err != nil {\n   744\t\t// Fallback to root workspaces dir if agent not found\n   745\t\treturn filepath.Join(config.GetWorkspacesDir(), agentID)\n   746\t}\n   747\n   748\tif a.WorkingDirectory != \"\" && filepath.IsAbs(a.WorkingDirectory) {\n   749\t\treturn a.WorkingDirectory\n   750\t}\n   751\n   752\tif a.ParentID == nil || *a.ParentID == \"\" {\n   753\t\t// Root agent\n   754\t\treturn filepath.Join(config.GetWorkspacesDir(), agentID)\n   755\t}\n   756\n   757\t// Recursive call to get parent's workspace path\n   758\tparentPath := s.getAgentWorkspacePath(*a.ParentID)\n   759\treturn filepath.Join(parentPath, \"sub_agents\", agentID)\n   760}\n   761\n   762func (s *Server) spawnSubAgent(parentID string, name string, prompt string, objective string, workingDir string) (string, error) {\n   763\tcfg, _ := config.LoadConfig()\n   764\n   765\tif cfg.SubAgent.Enabled == nil || !*cfg.SubAgent.Enabled {\n   766\t\treturn \"\", fmt.Errorf(\"sub-agents are globally disabled\")\n   767\t}\n   768\n   769\tagentID := uuid.New().String()\n   770\n   771\tif name == \"\" {\n   772\t\tname = utils.GetRandomName()\n   773\t}\n   774\n   775\tvar pID *string\n   776\tif parentID != \"\" {\n   777\t\tpID = &parentID\n   778\t}\n   779\n   780\tfullPrompt := prompt\n   781\tif objective != \"\" {\n   782\t\tfullPrompt = fmt.Sprintf(\"OBJECTIVE: %s\\n\\nINSTRUCTIONS: %s\", objective, prompt)\n   783\t}\n   784\n   785\t// Default config\n   786\tprovider := cfg.Inference.Chat.Provider\n   787\tmodel := s.getChatModel(cfg)\n   788\n   789\t// Inherit from parent if available\n   790\tsubAgentsEnabled := true\n   791\tisInternal := false\n   792\tif cfg.SubAgent.Enabled != nil {\n   793\t\tsubAgentsEnabled = *cfg.SubAgent.Enabled\n   794\t}\n   795\n   796\tif parentID != \"\" {\n   797\t\tif parent, err := s.db.GetAgent(parentID); err == nil {\n   798\t\t\tprovider = parent.ModelConfig.Provider\n   799\t\t\tmodel = parent.ModelConfig.Model\n   800\t\t\tsubAgentsEnabled = parent.SubAgentsEnabled\n   801\t\t\tisInternal = parent.IsInternal\n   802\t\t}\n   803\t}\n   804\n   805\t// Determine max context tokens based on provider/model\n   806\tcontextLimit := 128000\n   807\tprov, err := s.createProvider(provider)\n   808\tif err != nil {\n   809\t\treturn \"\", fmt.Errorf(\"failed to initialize sub-agent provider: %w\", err)\n   810\t}\n   811\tcontextLimit = prov.GetContextLimit(model)\n   812\n   813\tnewAgent := types.Agent{\n   814\t\tID:               agentID,\n   815\t\tParentID:         pID,\n   816\t\tType:             types.AgentTypeStandard,\n   817\t\tName:             name,\n   818\t\tState:            types.AgentStateIdle,\n   819\t\tInitialPrompt:    fullPrompt,\n   820\t\tPlanEnabled:      false, // Sub-agents start in direct execution mode by default\n   821\t\tSubAgentsEnabled: subAgentsEnabled,\n   822\t\tIsInternal:       isInternal,\n   823\t\tWorkingDirectory: workingDir,\n   824\t\tModelConfig: types.ModelConfig{\n   825\t\t\tProvider: provider,\n   826\t\t\tModel:    model,\n   827\t\t},\n   828\t\tMaxContextTokens: contextLimit,\n   829\t\tCreatedAt:        time.Now().UTC(),\n   830\t\tUpdatedAt:        time.Now().UTC(),\n   831\t}\n   832\n   833\tif err := s.db.CreateAgent(newAgent); err != nil {\n   834\t\treturn \"\", err\n   835\t}\n   836\n   837\t// Log the initial prompt so it shows up in history\n   838\tinitialPayload := map[string]interface{}{\n   839\t\t\"content\": fullPrompt,\n   840\t}\n   841\tif parentID != \"\" {\n   842\t\tinitialPayload[\"parent_id\"] = parentID\n   843\t}\n   844\n   845\tlogID, _ := s.db.AppendAgentLog(agentID, \"user_interaction\", initialPayload)\n   846\tinitialPayload[\"id\"] = logID\n   847\n   848\ts.globalBroadcast(map[string]interface{}{\n   849\t\t\"type\":  \"agent_created\",\n   850\t\t\"agent\": newAgent,\n   851\t})\n   852\n   853\t// Broadcast the initial prompt log\n   854\ts.globalBroadcast(map[string]interface{}{\n   855\t\t\"type\":       \"execution_log\",\n   856\t\t\"agent_id\":   agentID,\n   857\t\t\"event_type\": \"user_interaction\",\n   858\t\t\"payload\":    initialPayload,\n   859\t})\n   860\n   861\t// Broadcast agent_spawned\n   862\ts.globalBroadcast(map[string]interface{}{\n   863\t\t\"type\":      \"agent_spawned\",\n   864\t\t\"parent_id\": parentID,\n   865\t\t\"child\":     newAgent,\n   866\t})\n   867\n   868\tgo s.handleAgentScopeSetup(agentID)\n   869\n   870\treturn agentID, nil\n   871}\n   872\n   873func (s *Server) handleAgentScopeSetup(agentID string) {\n   874\t_, cancel := context.WithCancel(context.Background())\n   875\tif _, loaded := s.proposing.LoadOrStore(agentID, cancel); loaded {\n   876\t\tslog.Debug(\"Scope setup already in progress\", \"agent_id\", agentID)\n   877\t\tcancel()\n   878\t\treturn\n   879\t}\n   880\tdefer func() {\n   881\t\ts.proposing.Delete(agentID)\n   882\t\tcancel()\n   883\t}()\n   884\n   885\tsa, err := s.getOrCreateStatefulAgent(agentID)\n   886\tif err != nil {\n   887\t\tslog.Error(\"Failed to get agent for scope setup\", \"agent_id\", agentID, \"error\", err)\n   888\t\terrDetail := &types.ErrorDetail{\n   889\t\t\tCategory:    types.ErrorInitialization,\n   890\t\t\tMessage:     err.Error(),\n   891\t\t\tRecoverable: true,\n   892\t\t}\n   893\t\tpayload := map[string]interface{}{\n   894\t\t\t\"message\": err.Error(),\n   895\t\t}\n   896\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"agent_error\", payload)\n   897\t\tpayload[\"id\"] = logID\n   898\n   899\t\ts.db.UpdateAgentState(agentID, types.AgentStateError, errDetail)\n   900\t\ts.globalBroadcast(map[string]interface{}{\n   901\t\t\t\"type\":         \"agent_state_changed\",\n   902\t\t\t\"agent_id\":     agentID,\n   903\t\t\t\"new_state\":    types.AgentStateError,\n   904\t\t\t\"error_detail\": errDetail,\n   905\t\t})\n   906\t\ts.globalBroadcast(map[string]interface{}{\n   907\t\t\t\"type\":       \"execution_log\",\n   908\t\t\t\"agent_id\":   agentID,\n   909\t\t\t\"event_type\": \"agent_error\",\n   910\t\t\t\"payload\":    payload,\n   911\t\t})\n   912\t\treturn\n   913\t}\n   914\n   915\t// Update state to RUNNING while setting up scope\n   916\ts.db.UpdateAgentState(agentID, types.AgentStateRunning, nil)\n   917\tsa.SetState(types.AgentStateRunning)\n   918\ts.globalBroadcast(map[string]interface{}{\n   919\t\t\"type\":         \"agent_state_changed\",\n   920\t\t\"agent_id\":     agentID,\n   921\t\t\"new_state\":    types.AgentStateRunning,\n   922\t\t\"error_detail\": nil,\n   923\t})\n   924\n   925\t// Fetch parent scope if applicable\n   926\ta, err := s.db.GetAgent(agentID)\n   927\tif err != nil {\n   928\t\tslog.Error(\"Failed to get agent for scope setup\", \"agent_id\", agentID, \"error\", err)\n   929\t\treturn\n   930\t}\n   931\tvar parentScope *types.ScopeDocument\n   932\tif a.ParentID != nil {\n   933\t\tparentScope, _ = s.db.GetCurrentScope(*a.ParentID)\n   934\t}\n   935\n   936\t// Create a default scope that inherits from parent\n   937\tallowedTools := []string{\"*\"}\n   938\tallowedSkills := []string{\"*\"}\n   939\tif parentScope != nil {\n   940\t\tallowedTools = parentScope.Frontmatter.Permissions.Tools\n   941\t\tallowedSkills = parentScope.Frontmatter.Permissions.Skills\n   942\n   943\t\t// Ensure agent family is always allowed for sub-agents to enable recursive orchestration\n   944\t\thasAgentTools := false\n   945\t\tfor _, t := range allowedTools {\n   946\t\t\tif t == \"*\" || t == \"agent_*\" {\n   947\t\t\t\thasAgentTools = true\n   948\t\t\t\tbreak\n   949\t\t\t}\n   950\t\t}\n   951\t\tif !hasAgentTools {\n   952\t\t\tallowedTools = append(allowedTools, \"agent_*\")\n   953\t\t}\n   954\t}\n   955\n   956\tnow := time.Now().UTC()\n   957\tdefaultScope := &types.ScopeDocument{\n   958\t\tID:      uuid.New().String(),\n   959\t\tAgentID: agentID,\n   960\t\tVersion: 1,\n   961\t\tFrontmatter: types.ScopeFrontmatter{\n   962\t\t\tAgentID: agentID,\n   963\t\t\tVersion: 1,\n   964\t\t\tPermissions: types.ScopePermissions{\n   965\t\t\t\tTools:  allowedTools,\n   966\t\t\t\tSkills: allowedSkills,\n   967\t\t\t},\n   968\t\t\tResourceLimits: types.ResourceLimits{\n   969\t\t\t\tMaxLoops: 50,\n   970\t\t\t},\n   971\t\t},\n   972\t\tContent:    \"# Objective\\nExecute the user request directly.\\n\\n# Plan\\n1. Receive user instruction.\\n2. Execute relevant tools/skills to satisfy the request.\\n3. Report results back to the user.\",\n   973\t\tCreatedAt:  now,\n   974\t\tApprovedAt: &now,\n   975\t}\n   976\n   977\tif err := s.db.CreateScopeDocument(*defaultScope); err != nil {\n   978\t\tslog.Error(\"Failed to save default scope\", \"agent_id\", agentID, \"error\", err)\n   979\t\treturn\n   980\t}\n   981\n   982\t// Check if the scope was already saved by agent_plan tool during ProposeScopeStream.\n   983\t// If so, we don't need to save it again (which would create a duplicate version).\n   984\tsavedScope, _ := s.db.GetCurrentScope(agentID)\n   985\tscopeAlreadySaved := savedScope != nil && savedScope.Version == defaultScope.Version && savedScope.ApprovedAt != nil\n   986\n   987\tif !scopeAlreadySaved {\n   988\t\t// Scope wasn't saved yet, save it now\n   989\t\tnow := time.Now().UTC()\n   990\t\tdefaultScope.ApprovedAt = &now\n   991\n   992\t\tif err := s.upsertScopeDocument(agentID, defaultScope); err != nil {\n   993\t\t\tslog.Error(\"Failed to save scope update\", \"agent_id\", agentID, \"error\", err)\n   994\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateError, &types.ErrorDetail{\n   995\t\t\t\tCategory: types.ErrorToolFailure,\n   996\t\t\t\tMessage:  \"Failed to save scope update: \" + err.Error(),\n   997\t\t\t})\n   998\t\t\treturn\n   999\t\t}\n  1000\n  1001\t\t// Reload scope from database to get the correct ID and version\n  1002\t\tsavedScope, err = s.db.GetCurrentScope(agentID)\n  1003\t\tif err != nil || savedScope == nil {\n  1004\t\t\tslog.Error(\"Failed to reload scope after save\", \"agent_id\", agentID, \"error\", err)\n  1005\t\t\tsavedScope = defaultScope // Fallback to original scope\n  1006\t\t}\n  1007\n  1008\t\tif err := s.db.ApproveScope(agentID, savedScope.ID); err != nil {\n  1009\t\t\tslog.Error(\"Failed to mark scope as approved\", \"agent_id\", agentID, \"error\", err)\n  1010\t\t}\n  1011\t}\n  1012\n  1013\tsa.SetScope(savedScope)\n  1014\n  1015\ts.globalBroadcast(map[string]interface{}{\n  1016\t\t\"type\":     \"scope_updated\",\n  1017\t\t\"agent_id\": agentID,\n  1018\t\t\"scope\":    defaultScope,\n  1019\t})\n  1020\n  1021\tif updatedAgent, err := s.db.GetAgent(agentID); err == nil {\n  1022\t\ts.globalBroadcast(map[string]interface{}{\n  1023\t\t\t\"type\":  \"agent_updated\",\n  1024\t\t\t\"agent\": updatedAgent,\n  1025\t\t})\n  1026\t}\n  1027\n  1028\t// If it's a sub-agent, notify the parent agent with the scope update\n  1029\ta, err = s.db.GetAgent(agentID)\n  1030\tif err == nil && a.ParentID != nil {\n  1031\t\tpayload := map[string]interface{}{\n  1032\t\t\t\"sub_agent_id\": agentID,\n  1033\t\t\t\"scope\":        savedScope,\n  1034\t\t}\n  1035\t\tlogID, _ := s.db.AppendAgentLog(*a.ParentID, \"sub_agent_proposal\", payload)\n  1036\t\tpayload[\"id\"] = logID\n  1037\n  1038\t\ts.globalBroadcast(map[string]interface{}{\n  1039\t\t\t\"type\":       \"execution_log\",\n  1040\t\t\t\"agent_id\":   *a.ParentID,\n  1041\t\t\t\"event_type\": \"sub_agent_proposal\",\n  1042\t\t\t\"payload\":    payload,\n  1043\t\t})\n  1044\n  1045\t\t// Notify parent so it can see the update\n  1046\t\tif parent, err := s.getOrCreateStatefulAgent(*a.ParentID); err == nil {\n  1047\t\t\tparent.EnqueueAgentMessage(agentID, fmt.Sprintf(\"Sub-agent '%s' updated its scope and plan.\", a.Name))\n  1048\t\t}\n  1049\n  1050\t\t// Auto-resume parent agent to handle the update\n  1051\t\ts.resumeAgent(*a.ParentID, \"\")\n  1052\t}\n  1053\n  1054\t// Only add scope update log if we saved the scope here (not via agent_plan tool).\n  1055\t// The agent_plan tool already logs scope_updated when it saves the scope.\n  1056\tif !scopeAlreadySaved {\n  1057\t\tpayload := map[string]interface{}{\"scope\": savedScope}\n  1058\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"scope_updated\", payload)\n  1059\t\tpayload[\"id\"] = logID\n  1060\n  1061\t\ts.globalBroadcast(map[string]interface{}{\n  1062\t\t\t\"type\":       \"execution_log\",\n  1063\t\t\t\"agent_id\":   agentID,\n  1064\t\t\t\"event_type\": \"scope_updated\",\n  1065\t\t\t\"payload\":    payload,\n  1066\t\t})\n  1067\t}\n  1068\n  1069\t// Automatically start running the task now that the scope is ready\n  1070\ts.resumeAgent(agentID, \"\")\n  1071}\n  1072\n  1073func (s *Server) upsertScopeDocument(agentID string, doc *types.ScopeDocument) error {\n  1074\tif err := s.db.CreateScopeDocument(*doc); err != nil {\n  1075\t\tif strings.Contains(err.Error(), \"UNIQUE constraint failed\") {\n  1076\t\t\treturn s.db.UpdateScopeDocument(*doc)\n  1077\t\t}\n  1078\t\treturn err\n  1079\t}\n  1080\treturn nil\n  1081}\n  1082\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"bf099a87-3225-4829-a2d0-dab3377f821d","timestamp":"2026-01-03T12:11:13.037Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/agents.go","content":"package main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/agent\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n\t\"github.com/patrick/familiar/packages/go-backend/internal/utils\"\n\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n)\n\nfunc (s *Server) cleanupAgentRecursive(id string) {\n\t// Stop/Cancel the agent if it's in memory\n\ts.mu.Lock()\n\tsa, ok := s.statefulAgents[id]\n\tif ok {\n\t\tdelete(s.statefulAgents, id)\n\t}\n\ts.mu.Unlock()\n\n\tif ok {\n\t\tsa.Cancel()\n\t}\n\n\t// Remove tasks from scheduler\n\tif s.scheduler != nil {\n\t\ts.scheduler.RemoveTasksForAgent(id)\n\t}\n}\n\nfunc (s *Server) pauseAgentRecursive(agentID string) {\n\t// Pause the agent itself\n\tsa, err := s.getOrCreateStatefulAgent(agentID)\n\tif err != nil {\n\t\tslog.Error(\"Failed to get or create agent for pause\", \"agent_id\", agentID, \"error\", err)\n\t\treturn\n\t}\n\n\tsa.Pause()\n\n\t// Broadcast state change immediately so UI updates even if agent is stuck\n\tupdatedAgent, _ := s.db.GetAgent(agentID)\n\tif updatedAgent != nil {\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":      \"agent_state_changed\",\n\t\t\t\"agent\":     updatedAgent,\n\t\t\t\"agent_id\":  agentID,\n\t\t\t\"new_state\": types.AgentStatePaused,\n\t\t})\n\t}\n\n\t// Get all child agents and pause them recursively\n\tchildren, err := s.db.ListAgents(&agentID, nil)\n\tif err != nil {\n\t\tslog.Error(\"Failed to list child agents for pause\", \"agent_id\", agentID, \"error\", err)\n\t\treturn\n\t}\n\n\tfor _, child := range children {\n\t\ts.pauseAgentRecursive(child.ID)\n\t}\n}\n\nfunc (s *Server) resumeAgentRecursive(agentID string) {\n\t// Resume the agent itself\n\tif err := s.resumeAgent(agentID, \"\"); err != nil {\n\t\tslog.Error(\"Failed to resume agent\", \"agent_id\", agentID, \"error\", err)\n\t\treturn\n\t}\n\n\t// Get all child agents and resume them recursively\n\tchildren, err := s.db.ListAgents(&agentID, nil)\n\tif err != nil {\n\t\tslog.Error(\"Failed to list child agents for resume\", \"agent_id\", agentID, \"error\", err)\n\t\treturn\n\t}\n\n\tfor _, child := range children {\n\t\ts.resumeAgentRecursive(child.ID)\n\t}\n}\n\nfunc (s *Server) resumeAgent(agentID string, prompt string) error {\n\tsa, err := s.getOrCreateStatefulAgent(agentID)\n\tif err != nil {\n\t\tslog.Error(\"Failed to get or create agent for resume\", \"agent_id\", agentID, \"error\", err)\n\t\terrDetail := &types.ErrorDetail{\n\t\t\tCategory:    types.ErrorInitialization,\n\t\t\tMessage:     err.Error(),\n\t\t\tRecoverable: true,\n\t\t}\n\t\ts.db.UpdateAgentState(agentID, types.AgentStateError, errDetail)\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":         \"agent_state_changed\",\n\t\t\t\"agent_id\":     agentID,\n\t\t\t\"new_state\":    types.AgentStateError,\n\t\t\t\"error_detail\": errDetail,\n\t\t})\n\t\treturn err\n\t}\n\n\tif prompt != \"\" {\n\t\tsa.EnqueueMessage(types.Message{\n\t\t\tID:        uuid.New().String(),\n\t\t\tRole:      \"user\",\n\t\t\tContent:   prompt,\n\t\t\tTimestamp: time.Now().UnixNano() / int64(time.Millisecond),\n\t\t})\n\t}\n\n\tif sa.IsRunning() {\n\t\tsa.Resume()\n\t\treturn nil\n\t}\n\n\t// Start the loop\n\tgo func() {\n\t\ta, err := s.db.GetAgent(agentID)\n\t\tif err != nil {\n\t\t\tslog.Error(\"Failed to get agent for run\", \"agent_id\", agentID, \"error\", err)\n\t\t\treturn\n\t\t}\n\t\t// Fetch logs for context\n\t\thistory, _ := s.db.ListAgentLogs(agentID)\n\n\t\t// Fetch parent scope if applicable\n\t\tvar parentScope *types.ScopeDocument\n\t\tif a.ParentID != nil {\n\t\t\tparentScope, _ = s.db.GetCurrentScope(*a.ParentID)\n\t\t}\n\n\t\t// Update state in DB first\n\t\ts.db.UpdateAgentState(agentID, types.AgentStateRunning, nil)\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":         \"agent_state_changed\",\n\t\t\t\"agent_id\":     agentID,\n\t\t\t\"new_state\":    types.AgentStateRunning,\n\t\t\t\"error_detail\": nil,\n\t\t})\n\n\t\tif err := sa.Run(context.Background(), a.InitialPrompt, history, parentScope); err != nil {\n\t\t\tslog.Error(\"Agent run failed\", \"agent_id\", agentID, \"error\", err)\n\t\t\terrDetail := &types.ErrorDetail{\n\t\t\t\tCategory:    types.ErrorToolFailure,\n\t\t\t\tMessage:     err.Error(),\n\t\t\t\tRecoverable: true,\n\t\t\t}\n\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateError, errDetail)\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":         \"agent_state_changed\",\n\t\t\t\t\"agent_id\":     agentID,\n\t\t\t\t\"new_state\":    types.AgentStateError,\n\t\t\t\t\"error_detail\": errDetail,\n\t\t\t})\n\n\t\t\t// If it's a sub-agent, notify the parent agent of the error\n\t\t\tif a.ParentID != nil {\n\t\t\t\t// Wait for parent to finish its current turn if it's running\n\t\t\t\t// to avoid jarring UI interleaving where error appears before spawn confirmation\n\t\t\t\ts.mu.RLock()\n\t\t\t\tparentSA, hasParent := s.statefulAgents[*a.ParentID]\n\t\t\t\ts.mu.RUnlock()\n\t\t\t\tif hasParent {\n\t\t\t\t\tfor i := 0; i < 20; i++ { // Max 4 seconds wait\n\t\t\t\t\t\tif !parentSA.IsRunning() || parentSA.GetState() != types.AgentStateRunning {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(200 * time.Millisecond)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpayload := map[string]interface{}{\n\t\t\t\t\t\"sub_agent_id\": agentID,\n\t\t\t\t\t\"message\":      fmt.Sprintf(\"The sub-agent encountered an error: %v\", err),\n\t\t\t\t}\n\n\t\t\t\tlogID, _ := s.db.AppendAgentLog(*a.ParentID, \"sub_agent_error\", payload)\n\t\t\t\tpayload[\"id\"] = logID\n\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":       \"execution_log\",\n\t\t\t\t\t\"agent_id\":   *a.ParentID,\n\t\t\t\t\t\"event_type\": \"sub_agent_error\",\n\t\t\t\t\t\"payload\":    payload,\n\t\t\t\t})\n\n\t\t\t\t// Notify parent of the error\n\t\t\t\tif parent, err := s.getOrCreateStatefulAgent(*a.ParentID); err == nil {\n\t\t\t\t\tparent.EnqueueAgentMessage(agentID, fmt.Sprintf(\"Sub-agent '%s' encountered an error: %v\", a.Name, err))\n\t\t\t\t}\n\n\t\t\t\t// Auto-resume parent so it can handle the error\n\t\t\t\ts.resumeAgent(*a.ParentID, \"\")\n\t\t\t}\n\t\t} else {\n\t\t\tfinalState := sa.GetState()\n\t\t\tif finalState == types.AgentStateIdle {\n\t\t\t\t// Check if there are pending tasks or sub-agents\n\t\t\t\ttasks, _ := s.db.ListTasks()\n\t\t\t\thasWork := false\n\t\t\t\tfor _, t := range tasks {\n\t\t\t\t\tif t.ParentAgentID == agentID && (t.Status == \"pending\" || t.Status == \"running\") {\n\t\t\t\t\t\thasWork = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !hasWork {\n\t\t\t\t\tsubAgents, _ := s.db.ListAgents(&agentID, nil)\n\t\t\t\t\tfor _, sub := range subAgents {\n\t\t\t\t\t\tif sub.State != types.AgentStateIdle && sub.State != types.AgentStateError {\n\t\t\t\t\t\t\thasWork = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif hasWork {\n\t\t\t\t\tfinalState = types.AgentStateWaiting\n\t\t\t\t\tsa.SetState(finalState)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.db.UpdateAgentState(agentID, finalState, nil)\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":      \"agent_state_changed\",\n\t\t\t\t\"agent_id\":  agentID,\n\t\t\t\t\"new_state\": finalState,\n\t\t\t})\n\t\t\tif finalState == types.AgentStateIdle && a.ParentID != nil {\n\t\t\t\t// Wait for parent to finish its current turn if it's running\n\t\t\t\ts.mu.RLock()\n\t\t\t\tparentSA, hasParent := s.statefulAgents[*a.ParentID]\n\t\t\t\ts.mu.RUnlock()\n\t\t\t\tif hasParent {\n\t\t\t\t\tfor i := 0; i < 20; i++ { // Max 4 seconds wait\n\t\t\t\t\t\tif !parentSA.IsRunning() || parentSA.GetState() != types.AgentStateRunning {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(200 * time.Millisecond)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Always notify the parent when a sub-agent completes.\n\t\t\t\t// This ensures the parent's orchestration loop wakes up and notices the change.\n\t\t\t\tmsgContent := fmt.Sprintf(\"Sub-agent '%s' has completed its assigned task.\", a.Name)\n\n\t\t\t\tpayload := map[string]interface{}{\n\t\t\t\t\t\"sender_id\": agentID,\n\t\t\t\t\t\"content\":   msgContent,\n\t\t\t\t}\n\t\t\t\tlogID, _ := s.db.AppendAgentLog(*a.ParentID, \"agent_message\", payload)\n\t\t\t\tpayload[\"id\"] = logID\n\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":       \"execution_log\",\n\t\t\t\t\t\"agent_id\":   *a.ParentID,\n\t\t\t\t\t\"event_type\": \"agent_message\",\n\t\t\t\t\t\"payload\":    payload,\n\t\t\t\t})\n\n\t\t\t\t// Route message to parent agent's queue\n\t\t\t\tif parent, err := s.getOrCreateStatefulAgent(*a.ParentID); err == nil {\n\t\t\t\t\tparent.EnqueueAgentMessage(agentID, msgContent)\n\t\t\t\t}\n\n\t\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\t\"type\":      \"sub_agent_completed\",\n\t\t\t\t\t\"parent_id\": *a.ParentID,\n\t\t\t\t\t\"child_id\":  agentID,\n\t\t\t\t\t\"result\": types.SubAgentResult{\n\t\t\t\t\t\tSubAgentID: agentID,\n\t\t\t\t\t\tFindings:   msgContent,\n\t\t\t\t\t},\n\t\t\t\t})\n\n\t\t\t\t// Auto-resume parent so it can process the completion\n\t\t\t\ts.resumeAgent(*a.ParentID, \"\")\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc (s *Server) getOrCreateStatefulAgent(agentID string) (*agent.StatefulAgent, error) {\n\ts.mu.RLock()\n\tsa, ok := s.statefulAgents[agentID]\n\ts.mu.RUnlock()\n\n\ta, err := s.db.GetAgent(agentID)\n\tif err != nil {\n\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\treturn nil, fmt.Errorf(\"agent not found: agent with ID %s does not exist in the database\", agentID)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tscope, _ := s.db.GetCurrentScope(agentID)\n\tcfg, _ := config.LoadConfig()\n\n\t// Always validate provider is enabled and reachable\n\tprovider, err := s.createProvider(a.ModelConfig.Provider)\n\tif err != nil {\n\t\tif ok {\n\t\t\t// Stop and remove from cache if it was there but is now invalid\n\t\t\ts.mu.Lock()\n\t\t\tdelete(s.statefulAgents, agentID)\n\t\t\ts.mu.Unlock()\n\t\t\tsa.Cancel()\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tif ok {\n\t\t// Update cached agent with latest provider and config in case they changed\n\t\tsa.UpdateModelConfig(a.ModelConfig, provider)\n\n\t\t// Refresh skills\n\t\tloader := utils.NewSkillLoader(getProgramDataPath())\n\t\tif skills, err := loader.LoadSkills(); err == nil {\n\t\t\tsa.Skills = skills\n\t\t}\n\n\t\t// Update max_context_tokens in database when model changes\n\t\tmaxContextTokens := sa.MaxContextTokens\n\t\ts.db.UpdateAgentContextUsage(agentID, a.ContextTokens, maxContextTokens)\n\t\tsa.AlwaysAllowAll = config.GetAlwaysAllowAll()\n\n\t\t// Always refresh system prompt for internal agents to ensure they use the latest logic\n\t\tif a.IsInternal {\n\t\t\tsystemPrompt, _ := s.db.GetActiveSystemPrompt()\n\t\t\tif strings.Contains(strings.ToLower(a.Name), \"skill architect\") {\n\t\t\t\tsystemPrompt = `You are the Skill Architect. Help the user create, implement, and test new \"Familiar Skills\".\n\nBe terse. No narrative filler.\n\nCRITICAL - TOOL USAGE:\n- You MUST call tools to perform actions. DO NOT just describe what you will do - actually call the tool.\n- When asked to save a secret, IMMEDIATELY call 'vault_save' with the key name(s).\n- When asked to create a skill, IMMEDIATELY call 'workspace_write' with the file contents.\n- NEVER say \"I'll do X\" and then stop. Always follow through by calling the appropriate tool.\n\nWORKSPACE:\nYour workspace root is the \"skills\" directory. All files you create MUST be inside a sub-directory named after the skill (e.g. 'my-skill/skill.md').\n\nSKILL STRUCTURE:\nTo create a new skill, you must create a directory within your workspace root named with the skill's slug. A skill consists of:\n1. <skill-slug>/skill.md: YAML frontmatter with 'name' and 'description'.\n2. <skill-slug>/...: Optional helper scripts (Python, Bash, etc.) or other assets.\n\nSECRETS:\n- **CRITICAL**: Never ask the user to provide secrets (API keys, tokens, etc.) directly in chat.\n- You MUST warn the user: \"Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them.\"\n- If a skill needs one or more secrets, you MUST call the 'vault_save' tool with descriptive key names.\n- The 'vault_save' tool will trigger a secure, private input dialog for the user for each key.\n- Once saved, use the placeholder '{{vault:KEY_NAME}}' in your scripts or skill commands. The system will automatically substitute the actual value at execution time and mask it in logs.\n- You can check if a secret already exists using 'vault_list'. If it exists, don't ask to save it again unless the user wants to update it.\n\nWORKFLOW:\n- Use 'vault_list' to check if necessary secrets are already configured.\n- Call 'vault_save' to request missing secrets from the user securely.\n- Call 'workspace_write' to create the skill's directory and files by providing a path like 'skill-name/skill.md'.\n- Suggest content for 'skill.md' and any accompanying scripts.\n- Use 'workspace_list' and 'workspace_read' for examples of existing skills.`\n\t\t\t} else if strings.Contains(strings.ToLower(a.Name), \"trigger architect\") {\n\t\t\t\tsystemPrompt = `You are the Trigger Architect. Help the user create, implement, and test new \"Familiar Triggers\" and manage their subscriptions.\n\nBe terse. No narrative filler.\n\nCRITICAL - TOOL USAGE:\n- You MUST call tools to perform actions. DO NOT just describe what you will do - actually call the tool.\n- When asked to save a secret, IMMEDIATELY call 'vault_save' with the key name(s).\n- When asked to create a trigger, IMMEDIATELY call 'workspace_write' with the file contents.\n- NEVER say \"I'll do X\" and then stop. Always follow through by calling the appropriate tool.\n\nWORKSPACE:\nYour workspace root is the \"triggers\" directory. All files you create MUST be inside a sub-directory named after the trigger's slug (e.g. 'my-trigger/trigger.yaml'). Use 'workspace_write' to create files within these sub-directories.\n\nTRIGGER STRUCTURE (Script Triggers):\nTo create a new script-based trigger, you must create a directory within your workspace root named with the trigger's slug. A trigger consists of:\n1. <trigger-slug>/trigger.yaml: YAML configuration with:\n   - name: Unique identifier for the trigger.\n   - description: Human-readable description.\n   - script: Path to the executable script (e.g., 'monitor.sh').\n   - mode: \"daemon\" (runs continuously, emits lines from stdout) or \"poll\" (runs periodically).\n   - interval: (For poll mode) e.g., \"10s\", \"1m\".\n   - enabled: true\n   - env: (Optional) Map of environment variables for the script.\n2. <trigger-slug>/<script-file>: The actual script that monitors for events. \n\nBACKGROUND EXECUTION:\n- **CRITICAL**: Do NOT ask the user to manually install system-level daemons (like LaunchDaemons on macOS or systemd on Linux). \n- Instead, use 'mode: daemon' in 'trigger.yaml'. The Familiar system will automatically manage the lifecycle of your script.\n- Your script should run in a loop (if daemon) or perform a check (if poll) and print any events to STDOUT. Each line printed to STDOUT will be treated as a trigger event.\n\nSECRETS:\n- **CRITICAL**: Never ask the user to provide secrets (API keys, tokens, etc.) directly in chat.\n- You MUST warn the user: \"Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them.\"\n- If a trigger needs secrets (e.g. for API polling), you MUST call the 'vault_save' tool with descriptive key names.\n- The 'vault_save' tool will trigger a secure, private input dialog for the user for each key.\n- Once saved, use the placeholder '{{vault:KEY_NAME}}' in the 'env' map within 'trigger.yaml'. The system will automatically substitute the actual value at execution time and mask it in logs.\n- You can check if a secret already exists using 'vault_list'.\n\nSUBSCRIPTIONS:\nUsers can subscribe agents to triggers. When a trigger fires, the subscribed agent is woken up with a message based on a prompt template.\n- Use 'trigger_subscribe' to create or update a subscription.\n- The 'prompt_template' can use '{{output}}' which will be replaced by the trigger's output (the line from STDOUT).\n\nWORKFLOW:\n1. **Explore**: Use 'list_triggers' to see available triggers.\n2. **Secrets**: If needed, use 'vault_list' and 'vault_save' to manage credentials.\n3. **Create**: To create a new script trigger:\n   - **MUST**: Create a sub-directory first by writing a file into it.\n   - Use 'workspace_write' to create the configuration: 'my-trigger/trigger.yaml' (including 'env' for secrets).\n   - Use 'workspace_write' to create the script: 'my-trigger/monitor.sh'.\n4. **Subscribe**: Use 'trigger_subscribe' to connect an agent to a trigger.\n\nCRITICAL:\n- NEVER create files directly in the base \"triggers\" directory. ALWAYS use a sub-directory.\n- ALWAYS use tools to perform actions. Never just describe what you will do.`\n\t\t\t} else if a.Name == \"Feedback Collector\" {\n\t\t\t\tsystemPrompt = `You are the Feedback Collector for Familiar. Your goal is to help users report bugs, suggest features, or provide general feedback.\n\nBE TERSE. NO NARRATIVE FILLER.\n\nALLOWED TOOLS:\n- 'screenshot_take': Take a screenshot of the user's current screen. (REQUIRES confirmation)\n- 'submit_feedback': Send the collected feedback and optional screenshot to the development team.\n\nWORKFLOW:\n1. Ask the user for details about their feedback.\n2. If appropriate (e.g. reporting a UI bug), offer to take a screenshot using 'screenshot_take'.\n3. Once you have the feedback (and optional screenshot), use 'submit_feedback' to send it to the development team.\n4. Confirm success and thank the user.\n\nCRITICAL:\n- 'screenshot_take' REQUIRES explicit user approval. You MUST inform the user you are about to take a screenshot and wait for their confirmation if they haven't already given it in chat.\n- After taking a screenshot, immediately use the returned path in 'submit_feedback'.`\n\t\t\t}\n\t\t\tsa.SystemPrompt = systemPrompt\n\t\t}\n\t} else {\n\t\truntime := agent.NewRuntimeAgent(provider, a.ModelConfig.Model)\n\t\tsystemPrompt, _ := s.db.GetActiveSystemPrompt()\n\n\t\t// Use agent-specific system prompt if set\n\t\tif a.SystemPrompt != \"\" {\n\t\t\tsystemPrompt = a.SystemPrompt\n\t\t}\n\n\t\t// Load skills for the agent\n\t\tloader := utils.NewSkillLoader(getProgramDataPath())\n\t\tif skills, err := loader.LoadSkills(); err == nil {\n\t\t\truntime.Skills = skills\n\t\t}\n\n\t\tif a.IsInternal && strings.Contains(strings.ToLower(a.Name), \"skill architect\") {\n\t\t\tsystemPrompt = `You are the Skill Architect. Help the user create, implement, and test new \"Familiar Skills\".\n\nBe terse. No narrative filler.\n\nCRITICAL - TOOL USAGE:\n- You MUST call tools to perform actions. DO NOT just describe what you will do - actually call the tool.\n- When asked to save a secret, IMMEDIATELY call 'vault_save' with the key name(s).\n- When asked to create a skill, IMMEDIATELY call 'workspace_write' with the file contents.\n- NEVER say \"I'll do X\" and then stop. Always follow through by calling the appropriate tool.\n\nWORKSPACE:\nYour workspace root is the \"skills\" directory. All files you create MUST be inside a sub-directory named after the skill (e.g. 'my-skill/skill.md').\n\nSKILL STRUCTURE:\nTo create a new skill, you must create a directory within your workspace root named with the skill's slug. A skill consists of:\n1. <skill-slug>/skill.md: YAML frontmatter with 'name' and 'description'.\n2. <skill-slug>/...: Optional helper scripts (Python, Bash, etc.) or other assets.\n\nSECRETS:\n- **CRITICAL**: Never ask the user to provide secrets (API keys, tokens, etc.) directly in chat.\n- You MUST warn the user: \"Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them.\"\n- If a skill needs one or more secrets, you MUST call the 'vault_save' tool with descriptive key names.\n- The 'vault_save' tool will trigger a secure, private input dialog for the user for each key.\n- Once saved, use the placeholder '{{vault:KEY_NAME}}' in your scripts or skill commands. The system will automatically substitute the actual value at execution time and mask it in logs.\n- You can check if a secret already exists using 'vault_list'. If it exists, don't ask to save it again unless the user wants to update it.\n\nWORKFLOW:\n- Use 'vault_list' to check if necessary secrets are already configured.\n- Call 'vault_save' to request missing secrets from the user securely.\n- Call 'workspace_write' to create the skill's directory and files by providing a path like 'skill-name/skill.md'.\n- Suggest content for 'skill.md' and any accompanying scripts.\n- Use 'workspace_list' and 'workspace_read' for examples of existing skills.`\n\t\t} else if a.IsInternal && strings.Contains(strings.ToLower(a.Name), \"trigger architect\") {\n\t\t\tsystemPrompt = `You are the Trigger Architect. Help the user create, implement, and test new \"Familiar Triggers\" and manage their subscriptions.\n\nBe terse. No narrative filler.\n\nCRITICAL - TOOL USAGE:\n- You MUST call tools to perform actions. DO NOT just describe what you will do - actually call the tool.\n- When asked to save a secret, IMMEDIATELY call 'vault_save' with the key name(s).\n- When asked to create a trigger, IMMEDIATELY call 'workspace_write' with the file contents.\n- NEVER say \"I'll do X\" and then stop. Always follow through by calling the appropriate tool.\n\nWORKSPACE:\nYour workspace root is the \"triggers\" directory. All files you create MUST be inside a sub-directory named after the trigger's slug (e.g. 'my-trigger/trigger.yaml'). Use 'workspace_write' to create files within these sub-directories.\n\nTRIGGER STRUCTURE (Script Triggers):\nTo create a new script-based trigger, you must create a directory within your workspace root named with the trigger's slug. A trigger consists of:\n1. <trigger-slug>/trigger.yaml: YAML configuration with:\n   - name: Unique identifier for the trigger.\n   - description: Human-readable description.\n   - script: Path to the executable script (e.g., 'monitor.sh').\n   - mode: \"daemon\" (runs continuously, emits lines from stdout) or \"poll\" (runs periodically).\n   - interval: (For poll mode) e.g., \"10s\", \"1m\".\n   - enabled: true\n   - env: (Optional) Map of environment variables for the script.\n2. <trigger-slug>/<script-file>: The actual script that monitors for events. \n\nBACKGROUND EXECUTION:\n- **CRITICAL**: Do NOT ask the user to manually install system-level daemons (like LaunchDaemons on macOS or systemd on Linux). \n- Instead, use 'mode: daemon' in 'trigger.yaml'. The Familiar system will automatically manage the lifecycle of your script.\n- Your script should run in a loop (if daemon) or perform a check (if poll) and print any events to STDOUT. Each line printed to STDOUT will be treated as a trigger event.\n\nSECRETS:\n- **CRITICAL**: Never ask the user to provide secrets (API keys, tokens, etc.) directly in chat.\n- You MUST warn the user: \"Please do NOT paste secrets or API keys into this chat. I will provide a secure input field for them.\"\n- If a trigger needs secrets (e.g. for API polling), you MUST call the 'vault_save' tool with descriptive key names.\n- The 'vault_save' tool will trigger a secure, private input dialog for the user for each key.\n- Once saved, use the placeholder '{{vault:KEY_NAME}}' in the 'env' map within 'trigger.yaml'. The system will automatically substitute the actual value at execution time and mask it in logs.\n- You can check if a secret already exists using 'vault_list'.\n\nSUBSCRIPTIONS:\nUsers can subscribe agents to triggers. When a trigger fires, the subscribed agent is woken up with a message based on a prompt template.\n- Use 'trigger_subscribe' to create or update a subscription.\n- The 'prompt_template' can use '{{output}}' which will be replaced by the trigger's output (the line from STDOUT).\n\nWORKFLOW:\n1. **Explore**: Use 'list_triggers' to see available triggers.\n2. **Secrets**: If needed, use 'vault_list' and 'vault_save' to manage credentials.\n3. **Create**: To create a new script trigger:\n   - **MUST**: Create a sub-directory first by writing a file into it.\n   - Use 'workspace_write' to create the configuration: 'my-trigger/trigger.yaml' (including 'env' for secrets).\n   - Use 'workspace_write' to create the script: 'my-trigger/monitor.sh'.\n4. **Subscribe**: Use 'trigger_subscribe' to connect an agent to a trigger.\n\nCRITICAL:\n- NEVER create files directly in the base \"triggers\" directory. ALWAYS use a sub-directory.\n- ALWAYS use tools to perform actions. Never just describe what you will do.`\n\t\t} else if a.IsInternal && a.Name == \"Feedback Collector\" {\n\t\t\tsystemPrompt = `You are the Feedback Collector for Familiar. Your goal is to help users report bugs, suggest features, or provide general feedback.\n\nBE TERSE. NO NARRATIVE FILLER.\n\nALLOWED TOOLS:\n- 'screenshot_take': Take a screenshot of the user's current screen. (REQUIRES confirmation)\n- 'submit_feedback': Send the collected feedback and optional screenshot to the development team.\n\nWORKFLOW:\n1. Ask the user for details about their feedback.\n2. If appropriate (e.g. reporting a UI bug), offer to take a screenshot using 'screenshot_take'.\n3. Once you have the feedback (and optional screenshot), use 'submit_feedback' to send it to the development team.\n4. Confirm success and thank the user.\n\nCRITICAL:\n- 'screenshot_take' REQUIRES explicit user approval. You MUST inform the user you are about to take a screenshot and wait for their confirmation if they haven't already given it in chat.\n- After taking a screenshot, immediately use the returned path in 'submit_feedback'.`\n\t\t}\n\t\truntime.SystemPrompt = systemPrompt\n\t\ts.registerTools(runtime, provider, cfg, a)\n\n\t\tworkspacePath := s.getAgentWorkspacePath(agentID)\n\t\tsa = agent.NewStatefulAgent(runtime, *a, scope, workspacePath, s.db)\n\n\t\t// If agent state is Running but it's a new instance (not actually running), reset to Idle\n\t\t// This handles stale states from crashes/restarts\n\t\tif a.State == types.AgentStateRunning && !sa.IsRunning() {\n\t\t\tslog.Info(\"Detected stale running state, resetting to idle\", \"agent_id\", agentID, \"agent_name\", a.Name)\n\t\t\tsa.SetState(types.AgentStateIdle)\n\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateIdle, nil)\n\t\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\t\"type\":      \"agent_state_changed\",\n\t\t\t\t\"agent_id\":  agentID,\n\t\t\t\t\"new_state\": types.AgentStateIdle,\n\t\t\t})\n\t\t}\n\t}\n\n\t// Fetch and persist context limit from provider (use fetched value, not stored value)\n\t// This ensures we always have the latest context limit from the provider\n\tmaxContextTokens := sa.MaxContextTokens\n\tif maxContextTokens == 0 {\n\t\t// Fallback to stored value if provider didn't return a limit\n\t\tmaxContextTokens = a.MaxContextTokens\n\t\tif maxContextTokens == 0 {\n\t\t\tmaxContextTokens = 128000 // Final fallback\n\t\t}\n\t}\n\ts.db.UpdateAgentContextUsage(agentID, a.ContextTokens, maxContextTokens)\n\n\tsa.OnLog = func(agentID, eventType string, payload interface{}) {\n\t\tid, _ := s.db.AppendAgentLog(agentID, eventType, payload)\n\t\t// If the payload is a map, inject the ID if not already present\n\t\tif m, ok := payload.(map[string]interface{}); ok {\n\t\t\tif _, exists := m[\"id\"]; !exists {\n\t\t\t\tm[\"id\"] = id\n\t\t\t}\n\t\t}\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":       \"execution_log\",\n\t\t\t\"agent_id\":   agentID,\n\t\t\t\"event_type\": eventType,\n\t\t\t\"payload\":    payload,\n\t\t})\n\t}\n\tsa.OnUsage = func(usage types.UsageRecord) {\n\t\tif err := s.db.SaveUsage(&usage); err != nil {\n\t\t\tslog.Error(\"Failed to save usage record\", \"agent_id\", usage.AgentID, \"error\", err, \"usage\", usage)\n\t\t}\n\t}\n\tsa.OnStateChange = func(agentID string, newState types.AgentState) {\n\t\ts.db.UpdateAgentState(agentID, newState, nil)\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":      \"agent_state_changed\",\n\t\t\t\"agent_id\":  agentID,\n\t\t\t\"new_state\": newState,\n\t\t})\n\t}\n\tsa.OnContextUpdate = func(agentID string, contextTokens, maxContextTokens int) {\n\t\ts.db.UpdateAgentContextUsage(agentID, contextTokens, maxContextTokens)\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":               \"agent_context_updated\",\n\t\t\t\"agent_id\":           agentID,\n\t\t\t\"context_tokens\":     contextTokens,\n\t\t\t\"max_context_tokens\": maxContextTokens,\n\t\t})\n\t}\n\tsa.OnCompactingUpdate = func(agentID string, isCompacting bool) {\n\t\ts.db.UpdateAgentCompacting(agentID, isCompacting)\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":          \"agent_compacting_updated\",\n\t\t\t\"agent_id\":      agentID,\n\t\t\t\"is_compacting\": isCompacting,\n\t\t})\n\t}\n\tsa.OnCheckApproval = func(toolName, command string) (bool, error) {\n\t\treturn s.db.IsToolCallApproved(toolName, command)\n\t}\n\tsa.OnGetVaultSecrets = func() []string {\n\t\tsecrets, err := s.db.ListVaultSecrets()\n\t\tif err != nil {\n\t\t\treturn []string{}\n\t\t}\n\t\tnames := make([]string, len(secrets))\n\t\tfor i, s := range secrets {\n\t\t\tnames[i] = s.Name\n\t\t}\n\t\treturn config.GetVaultSecretValues(names)\n\t}\n\tsa.OnListVaultNames = func() []string {\n\t\tsecrets, err := s.db.ListVaultSecrets()\n\t\tif err != nil {\n\t\t\treturn []string{}\n\t\t}\n\t\tnames := make([]string, len(secrets))\n\t\tfor i, s := range secrets {\n\t\t\tnames[i] = s.Name\n\t\t}\n\t\treturn names\n\t}\n\tsa.OnSubAgentOutput = func(subAgentID string, content string) {\n\t\t// Get the subagent to find its parent\n\t\tsubAgent, err := s.db.GetAgent(subAgentID)\n\t\tif err != nil {\n\t\t\tslog.Error(\"Failed to get subagent for output piping\", \"sub_agent_id\", subAgentID, \"error\", err)\n\t\t\treturn\n\t\t}\n\t\tif subAgent.ParentID == nil {\n\t\t\t// Not a subagent, nothing to do\n\t\t\treturn\n\t\t}\n\n\t\tparentID := *subAgent.ParentID\n\n\t\t// Get or create the parent stateful agent\n\t\tparent, err := s.getOrCreateStatefulAgent(parentID)\n\t\tif err != nil {\n\t\t\tslog.Error(\"Failed to get parent agent for subagent output\", \"parent_id\", parentID, \"sub_agent_id\", subAgentID, \"error\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Log the message in the parent's history\n\t\tpayload := map[string]interface{}{\n\t\t\t\"sender_id\":    subAgentID,\n\t\t\t\"content\":      content,\n\t\t\t\"sub_agent_id\": subAgentID,\n\t\t}\n\t\tlogID, _ := s.db.AppendAgentLog(parentID, \"sub_agent_report\", payload)\n\t\tpayload[\"id\"] = logID\n\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":       \"execution_log\",\n\t\t\t\"agent_id\":   parentID,\n\t\t\t\"event_type\": \"sub_agent_report\",\n\t\t\t\"payload\":    payload,\n\t\t})\n\n\t\t// Route message to the parent agent's input queue\n\t\tparent.EnqueueAgentMessage(subAgentID, content)\n\n\t\t// Ensure the parent is running or resumed\n\t\tif !parent.IsRunning() {\n\t\t\tif err := s.resumeAgent(parentID, \"\"); err != nil {\n\t\t\t\tslog.Error(\"Failed to resume parent agent after subagent output\", \"parent_id\", parentID, \"error\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t// Parent is running but might be waiting - wake it up to process the message\n\t\t\tparent.Resume()\n\t\t}\n\t}\n\tsa.AlwaysAllowAll = cfg.Security.AlwaysAllowAll\n\tif a.IsInternal && a.Name == \"Feedback Collector\" {\n\t\tsa.AlwaysAllowAll = true\n\t}\n\n\tif !ok {\n\t\t// Trigger initial context usage calculation only for new agents\n\t\thistory, _ := s.db.ListAgentLogs(agentID)\n\t\tsa.RecalculateContextUsage(history)\n\n\t\ts.mu.Lock()\n\t\ts.statefulAgents[agentID] = sa\n\t\ts.mu.Unlock()\n\t}\n\n\treturn sa, nil\n}\n\nfunc (s *Server) getAgentWorkspacePath(agentID string) string {\n\ta, err := s.db.GetAgent(agentID)\n\tif err != nil {\n\t\t// Fallback to root workspaces dir if agent not found\n\t\treturn filepath.Join(config.GetWorkspacesDir(), agentID)\n\t}\n\n\tif a.WorkingDirectory != \"\" && filepath.IsAbs(a.WorkingDirectory) {\n\t\treturn a.WorkingDirectory\n\t}\n\n\tif a.ParentID == nil || *a.ParentID == \"\" {\n\t\t// Root agent\n\t\treturn filepath.Join(config.GetWorkspacesDir(), agentID)\n\t}\n\n\t// Recursive call to get parent's workspace path\n\tparentPath := s.getAgentWorkspacePath(*a.ParentID)\n\treturn filepath.Join(parentPath, \"sub_agents\", agentID)\n}\n\nfunc (s *Server) spawnSubAgent(parentID string, name string, prompt string, objective string, workingDir string) (string, error) {\n\tcfg, _ := config.LoadConfig()\n\n\tif cfg.SubAgent.Enabled == nil || !*cfg.SubAgent.Enabled {\n\t\treturn \"\", fmt.Errorf(\"sub-agents are globally disabled\")\n\t}\n\n\tagentID := uuid.New().String()\n\n\tif name == \"\" {\n\t\tname = utils.GetRandomName()\n\t}\n\n\tvar pID *string\n\tif parentID != \"\" {\n\t\tpID = &parentID\n\t}\n\n\tfullPrompt := prompt\n\tif objective != \"\" {\n\t\tfullPrompt = fmt.Sprintf(\"OBJECTIVE: %s\\n\\nINSTRUCTIONS: %s\", objective, prompt)\n\t}\n\n\t// Default config\n\tprovider := cfg.Inference.Chat.Provider\n\tmodel := s.getChatModel(cfg)\n\n\t// Inherit from parent if available\n\tsubAgentsEnabled := true\n\tisInternal := false\n\tif cfg.SubAgent.Enabled != nil {\n\t\tsubAgentsEnabled = *cfg.SubAgent.Enabled\n\t}\n\n\tif parentID != \"\" {\n\t\tif parent, err := s.db.GetAgent(parentID); err == nil {\n\t\t\tprovider = parent.ModelConfig.Provider\n\t\t\tmodel = parent.ModelConfig.Model\n\t\t\tsubAgentsEnabled = parent.SubAgentsEnabled\n\t\t\tisInternal = parent.IsInternal\n\t\t}\n\t}\n\n\t// Determine max context tokens based on provider/model\n\tcontextLimit := 128000\n\tprov, err := s.createProvider(provider)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to initialize sub-agent provider: %w\", err)\n\t}\n\tcontextLimit = prov.GetContextLimit(model)\n\n\tnewAgent := types.Agent{\n\t\tID:               agentID,\n\t\tParentID:         pID,\n\t\tType:             types.AgentTypeStandard,\n\t\tName:             name,\n\t\tState:            types.AgentStateIdle,\n\t\tInitialPrompt:    fullPrompt,\n\t\tPlanEnabled:      false, // Sub-agents start in direct execution mode by default\n\t\tSubAgentsEnabled: subAgentsEnabled,\n\t\tIsInternal:       isInternal,\n\t\tWorkingDirectory: workingDir,\n\t\tModelConfig: types.ModelConfig{\n\t\t\tProvider: provider,\n\t\t\tModel:    model,\n\t\t},\n\t\tMaxContextTokens: contextLimit,\n\t\tCreatedAt:        time.Now().UTC(),\n\t\tUpdatedAt:        time.Now().UTC(),\n\t}\n\n\tif err := s.db.CreateAgent(newAgent); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Log the initial prompt so it shows up in history\n\tinitialPayload := map[string]interface{}{\n\t\t\"content\": fullPrompt,\n\t}\n\tif parentID != \"\" {\n\t\tinitialPayload[\"parent_id\"] = parentID\n\t}\n\n\tlogID, _ := s.db.AppendAgentLog(agentID, \"user_interaction\", initialPayload)\n\tinitialPayload[\"id\"] = logID\n\n\ts.globalBroadcast(map[string]interface{}{\n\t\t\"type\":  \"agent_created\",\n\t\t\"agent\": newAgent,\n\t})\n\n\t// Broadcast the initial prompt log\n\ts.globalBroadcast(map[string]interface{}{\n\t\t\"type\":       \"execution_log\",\n\t\t\"agent_id\":   agentID,\n\t\t\"event_type\": \"user_interaction\",\n\t\t\"payload\":    initialPayload,\n\t})\n\n\t// Broadcast agent_spawned\n\ts.globalBroadcast(map[string]interface{}{\n\t\t\"type\":      \"agent_spawned\",\n\t\t\"parent_id\": parentID,\n\t\t\"child\":     newAgent,\n\t})\n\n\tgo s.handleAgentScopeSetup(agentID)\n\n\treturn agentID, nil\n}\n\nfunc (s *Server) handleAgentScopeSetup(agentID string) {\n\t_, cancel := context.WithCancel(context.Background())\n\tif _, loaded := s.proposing.LoadOrStore(agentID, cancel); loaded {\n\t\tslog.Debug(\"Scope setup already in progress\", \"agent_id\", agentID)\n\t\tcancel()\n\t\treturn\n\t}\n\tdefer func() {\n\t\ts.proposing.Delete(agentID)\n\t\tcancel()\n\t}()\n\n\tsa, err := s.getOrCreateStatefulAgent(agentID)\n\tif err != nil {\n\t\tslog.Error(\"Failed to get agent for scope setup\", \"agent_id\", agentID, \"error\", err)\n\t\terrDetail := &types.ErrorDetail{\n\t\t\tCategory:    types.ErrorInitialization,\n\t\t\tMessage:     err.Error(),\n\t\t\tRecoverable: true,\n\t\t}\n\t\tpayload := map[string]interface{}{\n\t\t\t\"message\": err.Error(),\n\t\t}\n\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"agent_error\", payload)\n\t\tpayload[\"id\"] = logID\n\n\t\ts.db.UpdateAgentState(agentID, types.AgentStateError, errDetail)\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":         \"agent_state_changed\",\n\t\t\t\"agent_id\":     agentID,\n\t\t\t\"new_state\":    types.AgentStateError,\n\t\t\t\"error_detail\": errDetail,\n\t\t})\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":       \"execution_log\",\n\t\t\t\"agent_id\":   agentID,\n\t\t\t\"event_type\": \"agent_error\",\n\t\t\t\"payload\":    payload,\n\t\t})\n\t\treturn\n\t}\n\n\t// Update state to RUNNING while setting up scope\n\ts.db.UpdateAgentState(agentID, types.AgentStateRunning, nil)\n\tsa.SetState(types.AgentStateRunning)\n\ts.globalBroadcast(map[string]interface{}{\n\t\t\"type\":         \"agent_state_changed\",\n\t\t\"agent_id\":     agentID,\n\t\t\"new_state\":    types.AgentStateRunning,\n\t\t\"error_detail\": nil,\n\t})\n\n\t// Fetch parent scope if applicable\n\ta, err := s.db.GetAgent(agentID)\n\tif err != nil {\n\t\tslog.Error(\"Failed to get agent for scope setup\", \"agent_id\", agentID, \"error\", err)\n\t\treturn\n\t}\n\tvar parentScope *types.ScopeDocument\n\tif a.ParentID != nil {\n\t\tparentScope, _ = s.db.GetCurrentScope(*a.ParentID)\n\t}\n\n\t// Create a default scope that inherits from parent\n\tallowedTools := []string{\"*\"}\n\tallowedSkills := []string{\"*\"}\n\tif parentScope != nil {\n\t\tallowedTools = parentScope.Frontmatter.Permissions.Tools\n\t\tallowedSkills = parentScope.Frontmatter.Permissions.Skills\n\n\t\t// Ensure agent family is always allowed for sub-agents to enable recursive orchestration\n\t\thasAgentTools := false\n\t\tfor _, t := range allowedTools {\n\t\t\tif t == \"*\" || t == \"agent_*\" {\n\t\t\t\thasAgentTools = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !hasAgentTools {\n\t\t\tallowedTools = append(allowedTools, \"agent_*\")\n\t\t}\n\t}\n\n\tnow := time.Now().UTC()\n\tdefaultScope := &types.ScopeDocument{\n\t\tID:      uuid.New().String(),\n\t\tAgentID: agentID,\n\t\tVersion: 1,\n\t\tFrontmatter: types.ScopeFrontmatter{\n\t\t\tAgentID: agentID,\n\t\t\tVersion: 1,\n\t\t\tPermissions: types.ScopePermissions{\n\t\t\t\tTools:  allowedTools,\n\t\t\t\tSkills: allowedSkills,\n\t\t\t},\n\t\t\tResourceLimits: types.ResourceLimits{\n\t\t\t\tMaxLoops: 50,\n\t\t\t},\n\t\t},\n\t\tContent:    \"# Objective\\nExecute the user request directly.\\n\\n# Plan\\n1. Receive user instruction.\\n2. Execute relevant tools/skills to satisfy the request.\\n3. Report results back to the user.\",\n\t\tCreatedAt:  now,\n\t\tApprovedAt: &now,\n\t}\n\n\tif err := s.db.CreateScopeDocument(*defaultScope); err != nil {\n\t\tslog.Error(\"Failed to save default scope\", \"agent_id\", agentID, \"error\", err)\n\t\treturn\n\t}\n\n\t// Check if the scope was already saved by agent_plan tool during ProposeScopeStream.\n\t// If so, we don't need to save it again (which would create a duplicate version).\n\tsavedScope, _ := s.db.GetCurrentScope(agentID)\n\tscopeAlreadySaved := savedScope != nil && savedScope.Version == defaultScope.Version && savedScope.ApprovedAt != nil\n\n\tif !scopeAlreadySaved {\n\t\t// Scope wasn't saved yet, save it now\n\t\tnow := time.Now().UTC()\n\t\tdefaultScope.ApprovedAt = &now\n\n\t\tif err := s.upsertScopeDocument(agentID, defaultScope); err != nil {\n\t\t\tslog.Error(\"Failed to save scope update\", \"agent_id\", agentID, \"error\", err)\n\t\t\ts.db.UpdateAgentState(agentID, types.AgentStateError, &types.ErrorDetail{\n\t\t\t\tCategory: types.ErrorToolFailure,\n\t\t\t\tMessage:  \"Failed to save scope update: \" + err.Error(),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Reload scope from database to get the correct ID and version\n\t\tsavedScope, err = s.db.GetCurrentScope(agentID)\n\t\tif err != nil || savedScope == nil {\n\t\t\tslog.Error(\"Failed to reload scope after save\", \"agent_id\", agentID, \"error\", err)\n\t\t\tsavedScope = defaultScope // Fallback to original scope\n\t\t}\n\n\t\tif err := s.db.ApproveScope(agentID, savedScope.ID); err != nil {\n\t\t\tslog.Error(\"Failed to mark scope as approved\", \"agent_id\", agentID, \"error\", err)\n\t\t}\n\t}\n\n\tsa.SetScope(savedScope)\n\n\ts.globalBroadcast(map[string]interface{}{\n\t\t\"type\":     \"scope_updated\",\n\t\t\"agent_id\": agentID,\n\t\t\"scope\":    defaultScope,\n\t})\n\n\tif updatedAgent, err := s.db.GetAgent(agentID); err == nil {\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":  \"agent_updated\",\n\t\t\t\"agent\": updatedAgent,\n\t\t})\n\t}\n\n\t// If it's a sub-agent, notify the parent agent with the scope update\n\ta, err = s.db.GetAgent(agentID)\n\tif err == nil && a.ParentID != nil {\n\t\tpayload := map[string]interface{}{\n\t\t\t\"sub_agent_id\": agentID,\n\t\t\t\"scope\":        savedScope,\n\t\t}\n\t\tlogID, _ := s.db.AppendAgentLog(*a.ParentID, \"sub_agent_proposal\", payload)\n\t\tpayload[\"id\"] = logID\n\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":       \"execution_log\",\n\t\t\t\"agent_id\":   *a.ParentID,\n\t\t\t\"event_type\": \"sub_agent_proposal\",\n\t\t\t\"payload\":    payload,\n\t\t})\n\n\t\t// Notify parent so it can see the update\n\t\tif parent, err := s.getOrCreateStatefulAgent(*a.ParentID); err == nil {\n\t\t\tparent.EnqueueAgentMessage(agentID, fmt.Sprintf(\"Sub-agent '%s' updated its scope and plan.\", a.Name))\n\t\t}\n\n\t\t// Auto-resume parent agent to handle the update\n\t\ts.resumeAgent(*a.ParentID, \"\")\n\t}\n\n\t// Only add scope update log if we saved the scope here (not via agent_plan tool).\n\t// The agent_plan tool already logs scope_updated when it saves the scope.\n\tif !scopeAlreadySaved {\n\t\tpayload := map[string]interface{}{\"scope\": savedScope}\n\t\tlogID, _ := s.db.AppendAgentLog(agentID, \"scope_updated\", payload)\n\t\tpayload[\"id\"] = logID\n\n\t\ts.globalBroadcast(map[string]interface{}{\n\t\t\t\"type\":       \"execution_log\",\n\t\t\t\"agent_id\":   agentID,\n\t\t\t\"event_type\": \"scope_updated\",\n\t\t\t\"payload\":    payload,\n\t\t})\n\t}\n\n\t// Automatically start running the task now that the scope is ready\n\ts.resumeAgent(agentID, \"\")\n}\n\nfunc (s *Server) upsertScopeDocument(agentID string, doc *types.ScopeDocument) error {\n\tif err := s.db.CreateScopeDocument(*doc); err != nil {\n\t\tif strings.Contains(err.Error(), \"UNIQUE constraint failed\") {\n\t\t\treturn s.db.UpdateScopeDocument(*doc)\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n","numLines":1082,"startLine":1,"totalLines":1082}}}
{"parentUuid":"bf099a87-3225-4829-a2d0-dab3377f821d","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XiAHR4Cudy27xcnSg68QgM","type":"tool_result","content":"Found 2 files\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go\nworkingdir/familiar/packages/go-backend/go.sum"}]},"uuid":"6fb42ab9-2c01-4eb7-9aa8-a8bd3d88621f","timestamp":"2026-01-03T12:11:13.292Z","toolUseResult":{"mode":"files_with_matches","filenames":["workingdir/familiar/packages/go-backend/internal/inference/openrouter.go","workingdir/familiar/packages/go-backend/go.sum"],"numFiles":2}}
{"parentUuid":"6fb42ab9-2c01-4eb7-9aa8-a8bd3d88621f","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013WoiY7hAh71azX3PCFtQc2","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the OpenRouter provider to see how authorization headers are set and check if there's any existing OAuth patterns in the codebase:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":18949,"cache_read_input_tokens":104232,"cache_creation":{"ephemeral_5m_input_tokens":18949,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRS5MUoDZuMSdqLY6uQ","type":"assistant","uuid":"93e0c330-1afc-4a9c-9891-b4e57dcc52d9","timestamp":"2026-01-03T12:11:18.056Z"}
{"parentUuid":"93e0c330-1afc-4a9c-9891-b4e57dcc52d9","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013WoiY7hAh71azX3PCFtQc2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016Lwu5xBxvyxu65ELhmrYqa","name":"Read","input":{"file_path":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openrouter.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":18949,"cache_read_input_tokens":104232,"cache_creation":{"ephemeral_5m_input_tokens":18949,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRS5MUoDZuMSdqLY6uQ","type":"assistant","uuid":"4364393b-30dd-4122-ad93-210eebfb0d43","timestamp":"2026-01-03T12:11:19.257Z"}
{"parentUuid":"4364393b-30dd-4122-ad93-210eebfb0d43","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_013WoiY7hAh71azX3PCFtQc2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01443rdBY4Zh5tU7zxTGzBgb","name":"Grep","input":{"pattern":"Authorization|Bearer|token","path":"/Users/patrick/workingdir/familiar/packages/go-backend","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":18949,"cache_read_input_tokens":104232,"cache_creation":{"ephemeral_5m_input_tokens":18949,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRS5MUoDZuMSdqLY6uQ","type":"assistant","uuid":"7bc3dc5f-8152-41be-a106-06e5056eeec6","timestamp":"2026-01-03T12:11:20.647Z"}
{"parentUuid":"7bc3dc5f-8152-41be-a106-06e5056eeec6","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016Lwu5xBxvyxu65ELhmrYqa","type":"tool_result","content":"     1package inference\n     2\n     3import (\n     4\t\"bufio\"\n     5\t\"bytes\"\n     6\t\"context\"\n     7\t\"encoding/json\"\n     8\t\"errors\"\n     9\t\"fmt\"\n    10\t\"io\"\n    11\t\"log/slog\"\n    12\t\"net/http\"\n    13\t\"strings\"\n    14\t\"time\"\n    15\n    16\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n    17\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n    18)\n    19\n    20type OpenRouterProvider struct {\n    21\tapiKey  string\n    22\tsiteURL string\n    23\tappName string\n    24\ttimeout time.Duration\n    25\tbaseURL string\n    26\tclient  *http.Client\n    27}\n    28\n    29func NewOpenRouterProvider(apiKey, siteURL, appName string) (*OpenRouterProvider, error) {\n    30\tif apiKey == \"\" {\n    31\t\tapiKey = config.GetKeychainPassword(\"openrouter-api-key\")\n    32\t}\n    33\tif apiKey == \"\" {\n    34\t\treturn nil, errors.New(\"api key required for openrouter\")\n    35\t}\n    36\n    37\treturn &OpenRouterProvider{\n    38\t\tapiKey:  apiKey,\n    39\t\tsiteURL: siteURL,\n    40\t\tappName: appName,\n    41\t\ttimeout: 60 * time.Second,\n    42\t\tbaseURL: \"https://openrouter.ai/api/v1/chat/completions\",\n    43\t\tclient:  &http.Client{Timeout: 300 * time.Second},\n    44\t}, nil\n    45}\n    46\n    47func (p *OpenRouterProvider) Name() string {\n    48\treturn \"openrouter\"\n    49}\n    50\n    51func (p *OpenRouterProvider) ListModels(ctx context.Context) ([]string, error) {\n    52\treturn nil, nil\n    53}\n    54\n    55func (p *OpenRouterProvider) GetContextLimit(model string) int {\n    56\t// Try fetching from shared OpenRouter metadata cache\n    57\tif limit, ok := GetContextLimitFromOpenRouter(model); ok {\n    58\t\treturn limit\n    59\t}\n    60\n    61\treturn 128000 // Final fallback\n    62}\n    63\n    64func (p *OpenRouterProvider) convertMessages(messages []types.Message) []map[string]interface{} {\n    65\tapiMessages := make([]map[string]interface{}, len(messages))\n    66\tfor i, m := range messages {\n    67\t\tvar content interface{} = m.Content\n    68\t\tvar multiContent []map[string]interface{}\n    69\n    70\t\t// Handle Content field\n    71\t\tif c, ok := m.Content.(string); ok && c != \"\" {\n    72\t\t\tif len(m.Attachments) > 0 {\n    73\t\t\t\tmultiContent = append(multiContent, map[string]interface{}{\n    74\t\t\t\t\t\"type\": \"text\",\n    75\t\t\t\t\t\"text\": c,\n    76\t\t\t\t})\n    77\t\t\t}\n    78\t\t} else if parts, ok := m.Content.([]interface{}); ok {\n    79\t\t\tslog.Debug(\"OpenRouter: content is array\", \"num_parts\", len(parts))\n    80\t\t\tfor _, part := range parts {\n    81\t\t\t\tif pMap, ok := part.(map[string]interface{}); ok {\n    82\t\t\t\t\tslog.Debug(\"OpenRouter: adding part\", \"type\", pMap[\"type\"])\n    83\t\t\t\t\tmultiContent = append(multiContent, pMap)\n    84\t\t\t\t}\n    85\t\t\t}\n    86\t\t}\n    87\n    88\t\t// Handle Attachments field\n    89\t\tfor _, att := range m.Attachments {\n    90\t\t\tif att.Type == \"image\" {\n    91\t\t\t\turl := att.Data\n    92\t\t\t\tif !strings.HasPrefix(url, \"data:\") {\n    93\t\t\t\t\turl = \"data:\" + att.MimeType + \";base64,\" + att.Data\n    94\t\t\t\t}\n    95\t\t\t\tmultiContent = append(multiContent, map[string]interface{}{\n    96\t\t\t\t\t\"type\": \"image_url\",\n    97\t\t\t\t\t\"image_url\": map[string]interface{}{\n    98\t\t\t\t\t\t\"url\": url,\n    99\t\t\t\t\t},\n   100\t\t\t\t})\n   101\t\t\t} else {\n   102\t\t\t\t// For non-image files, some models on OpenRouter might support them,\n   103\t\t\t\t// but generally we fall back to a text description if not images.\n   104\t\t\t\t// However, we should still pass them if they are common formats like PDF.\n   105\t\t\t\tif att.MimeType == \"application/pdf\" {\n   106\t\t\t\t\t// OpenRouter might support the OpenAI document format for some models,\n   107\t\t\t\t\t// or we can try passing it as a file block if the underlying model is Claude.\n   108\t\t\t\t\t// For now, let's stick to text placeholder + name to avoid breaking things,\n   109\t\t\t\t\t// but the ideal is native support.\n   110\t\t\t\t\tmultiContent = append(multiContent, map[string]interface{}{\n   111\t\t\t\t\t\t\"type\": \"text\",\n   112\t\t\t\t\t\t\"text\": \"[File Attachment: \" + att.Name + \" (\" + att.MimeType + \")]\",\n   113\t\t\t\t\t})\n   114\t\t\t\t} else {\n   115\t\t\t\t\tmultiContent = append(multiContent, map[string]interface{}{\n   116\t\t\t\t\t\t\"type\": \"text\",\n   117\t\t\t\t\t\t\"text\": \"[File Attachment: \" + att.Name + \" (\" + att.MimeType + \")]\",\n   118\t\t\t\t\t})\n   119\t\t\t\t}\n   120\t\t\t}\n   121\t\t}\n   122\n   123\t\tif len(multiContent) > 0 {\n   124\t\t\tcontent = multiContent\n   125\t\t}\n   126\n   127\t\tmsg := map[string]interface{}{\n   128\t\t\t\"role\":    m.Role,\n   129\t\t\t\"content\": content,\n   130\t\t}\n   131\t\tif msg[\"content\"] == nil {\n   132\t\t\tmsg[\"content\"] = \"\"\n   133\t\t}\n   134\t\tif m.Name != \"\" {\n   135\t\t\tmsg[\"name\"] = m.Name\n   136\t\t}\n   137\t\tif m.ToolCallID != \"\" {\n   138\t\t\tmsg[\"tool_call_id\"] = m.ToolCallID\n   139\t\t}\n   140\t\tif len(m.ToolCalls) > 0 {\n   141\t\t\tmsg[\"tool_calls\"] = m.ToolCalls\n   142\t\t}\n   143\t\tapiMessages[i] = msg\n   144\t}\n   145\treturn apiMessages\n   146}\n   147\n   148func (p *OpenRouterProvider) ChatCompletion(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (*types.ChatResponse, error) {\n   149\t// Parse thinking configuration from model string\n   150\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n   151\n   152\tapiMessages := p.convertMessages(messages)\n   153\tpayload := map[string]interface{}{\n   154\t\t\"model\":    baseModel,\n   155\t\t\"messages\": apiMessages,\n   156\t}\n   157\n   158\t// Inject reasoning parameter if level is set\n   159\tif reasoningLevel != ReasoningNone {\n   160\t\tpayload[\"reasoning\"] = map[string]interface{}{\n   161\t\t\t\"effort\": string(reasoningLevel),\n   162\t\t}\n   163\t\tslog.Debug(\"OpenRouter: Enabling extended thinking\", \"model\", baseModel, \"level\", reasoningLevel)\n   164\t}\n   165\n   166\tfor k, v := range options {\n   167\t\tif k == \"tool_choice\" {\n   168\t\t\tcontinue // Handled below\n   169\t\t}\n   170\t\tpayload[k] = v\n   171\t}\n   172\n   173\tif tools != nil {\n   174\t\twrappedTools := make([]interface{}, len(tools))\n   175\t\tfor i, t := range tools {\n   176\t\t\tif tm, ok := t.(map[string]interface{}); ok {\n   177\t\t\t\tif _, hasType := tm[\"type\"]; hasType {\n   178\t\t\t\t\tif _, hasFn := tm[\"function\"]; hasFn {\n   179\t\t\t\t\t\twrappedTools[i] = t\n   180\t\t\t\t\t\tcontinue\n   181\t\t\t\t\t}\n   182\t\t\t\t}\n   183\t\t\t\tslog.Warn(\"OpenRouter: Wrapping malformed tool definition in non-streaming call\", \"index\", i)\n   184\t\t\t\twrappedTools[i] = map[string]interface{}{\n   185\t\t\t\t\t\"type\": \"function\",\n   186\t\t\t\t\t\"function\": map[string]interface{}{\n   187\t\t\t\t\t\t\"name\":        tm[\"name\"],\n   188\t\t\t\t\t\t\"description\": tm[\"description\"],\n   189\t\t\t\t\t\t\"parameters\":  tm[\"parameters\"],\n   190\t\t\t\t\t},\n   191\t\t\t\t}\n   192\t\t\t} else {\n   193\t\t\t\twrappedTools[i] = t\n   194\t\t\t}\n   195\t\t}\n   196\t\tpayload[\"tools\"] = wrappedTools\n   197\n   198\t\tif toolChoice, ok := options[\"tool_choice\"]; ok {\n   199\t\t\tpayload[\"tool_choice\"] = toolChoice\n   200\t\t}\n   201\t}\n   202\n   203\tbody, err := json.Marshal(payload)\n   204\tif err != nil {\n   205\t\treturn nil, err\n   206\t}\n   207\n   208\treq, err := http.NewRequestWithContext(ctx, \"POST\", p.baseURL, bytes.NewBuffer(body))\n   209\tif err != nil {\n   210\t\treturn nil, err\n   211\t}\n   212\n   213\treq.Header.Set(\"Authorization\", \"Bearer \"+p.apiKey)\n   214\treq.Header.Set(\"Content-Type\", \"application/json\")\n   215\tif p.siteURL != \"\" {\n   216\t\treq.Header.Set(\"HTTP-Referer\", p.siteURL)\n   217\t}\n   218\tif p.appName != \"\" {\n   219\t\treq.Header.Set(\"X-Title\", p.appName)\n   220\t}\n   221\n   222\tstart := time.Now()\n   223\tresp, err := p.client.Do(req)\n   224\tif err != nil {\n   225\t\treturn nil, err\n   226\t}\n   227\tdefer resp.Body.Close()\n   228\n   229\tif resp.StatusCode != http.StatusOK {\n   230\t\trespBody, _ := io.ReadAll(resp.Body)\n   231\t\treturn nil, fmt.Errorf(\"openrouter request failed with status %d: %s\", resp.StatusCode, string(respBody))\n   232\t}\n   233\n   234\tvar data map[string]interface{}\n   235\tif err := json.NewDecoder(resp.Body).Decode(&data); err != nil {\n   236\t\treturn nil, err\n   237\t}\n   238\n   239\telapsed := time.Since(start).Seconds()\n   240\n   241\tchoices, _ := data[\"choices\"].([]interface{})\n   242\tif len(choices) == 0 {\n   243\t\treturn nil, errors.New(\"no choices returned from openrouter\")\n   244\t}\n   245\n   246\tfirstChoice, ok := choices[0].(map[string]interface{})\n   247\tif !ok {\n   248\t\treturn nil, errors.New(\"invalid choice format from openrouter\")\n   249\t}\n   250\tmessage, ok := firstChoice[\"message\"].(map[string]interface{})\n   251\tif !ok {\n   252\t\treturn nil, errors.New(\"invalid message format from openrouter\")\n   253\t}\n   254\tcontent, _ := message[\"content\"].(string)\n   255\n   256\tvar toolCalls []types.ToolCall\n   257\tif tcData, ok := message[\"tool_calls\"].([]interface{}); ok {\n   258\t\tfor _, tcItem := range tcData {\n   259\t\t\ttc, ok := tcItem.(map[string]interface{})\n   260\t\t\tif !ok {\n   261\t\t\t\tcontinue\n   262\t\t\t}\n   263\t\t\tfn, ok := tc[\"function\"].(map[string]interface{})\n   264\t\t\tif !ok {\n   265\t\t\t\tcontinue\n   266\t\t\t}\n   267\t\t\tid, _ := tc[\"id\"].(string)\n   268\t\t\ttp, _ := tc[\"type\"].(string)\n   269\t\t\tname, _ := fn[\"name\"].(string)\n   270\t\t\targs, _ := fn[\"arguments\"].(string)\n   271\t\t\ttoolCalls = append(toolCalls, types.ToolCall{\n   272\t\t\t\tID:   id,\n   273\t\t\t\tType: tp,\n   274\t\t\t\tFunction: types.ToolFunction{\n   275\t\t\t\t\tName:      name,\n   276\t\t\t\t\tArguments: args,\n   277\t\t\t\t},\n   278\t\t\t})\n   279\t\t}\n   280\t}\n   281\n   282\tusageData, _ := data[\"usage\"].(map[string]interface{})\n   283\tusage := types.Usage{}\n   284\tif usageData != nil {\n   285\t\tif v, ok := usageData[\"prompt_tokens\"].(float64); ok {\n   286\t\t\tusage.InputTokens = int(v)\n   287\t\t}\n   288\t\tif v, ok := usageData[\"completion_tokens\"].(float64); ok {\n   289\t\t\tusage.OutputTokens = int(v)\n   290\t\t}\n   291\t\tif v, ok := usageData[\"total_tokens\"].(float64); ok {\n   292\t\t\tusage.TotalTokens = int(v)\n   293\t\t}\n   294\t\tif v, ok := usageData[\"cost\"].(float64); ok {\n   295\t\t\tusage.Cost = v\n   296\t\t}\n   297\t}\n   298\n   299\treturn &types.ChatResponse{\n   300\t\tContent:    content,\n   301\t\tToolCalls:  toolCalls,\n   302\t\tRawMessage: message,\n   303\t\tUsage:      usage,\n   304\t\tMetadata:   map[string]interface{}{\"elapsed\": elapsed},\n   305\t}, nil\n   306}\n   307\n   308func (p *OpenRouterProvider) ChatCompletionStream(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (<-chan types.ChatStreamChunk, <-chan error) {\n   309\tchunkCh := make(chan types.ChatStreamChunk)\n   310\terrCh := make(chan error, 1)\n   311\n   312\tgo func() {\n   313\t\tdefer close(chunkCh)\n   314\t\tdefer close(errCh)\n   315\n   316\t\t// Parse thinking configuration from model string\n   317\t\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n   318\n   319\t\tapiMessages := p.convertMessages(messages)\n   320\n   321\t\tpayload := map[string]interface{}{\n   322\t\t\t\"model\":    baseModel,\n   323\t\t\t\"messages\": apiMessages,\n   324\t\t\t\"stream\":   true,\n   325\t\t}\n   326\n   327\t\t// Inject reasoning parameter if level is set\n   328\t\tif reasoningLevel != ReasoningNone {\n   329\t\t\tpayload[\"reasoning\"] = map[string]interface{}{\n   330\t\t\t\t\"effort\": string(reasoningLevel),\n   331\t\t\t}\n   332\t\t\tslog.Debug(\"OpenRouter: Enabling extended thinking (stream)\", \"model\", baseModel, \"level\", reasoningLevel)\n   333\t\t}\n   334\n   335\t\t// Pass all options through\n   336\t\tfor k, v := range options {\n   337\t\t\tif k == \"tool_choice\" {\n   338\t\t\t\tcontinue // Handled below\n   339\t\t\t}\n   340\t\t\tpayload[k] = v\n   341\t\t}\n   342\n   343\t\tif tools != nil {\n   344\t\t\twrappedTools := make([]interface{}, len(tools))\n   345\t\t\tfor i, t := range tools {\n   346\t\t\t\tif tm, ok := t.(map[string]interface{}); ok {\n   347\t\t\t\t\t// If it already has the wrapper, use it as-is\n   348\t\t\t\t\tif _, hasType := tm[\"type\"]; hasType {\n   349\t\t\t\t\t\tif _, hasFn := tm[\"function\"]; hasFn {\n   350\t\t\t\t\t\t\twrappedTools[i] = t\n   351\t\t\t\t\t\t\tcontinue\n   352\t\t\t\t\t\t}\n   353\t\t\t\t\t}\n   354\n   355\t\t\t\t\t// Otherwise, wrap it (it's likely a flat definition)\n   356\t\t\t\t\tslog.Warn(\"OpenRouter: Wrapping malformed tool definition\", \"index\", i)\n   357\t\t\t\t\twrappedTools[i] = map[string]interface{}{\n   358\t\t\t\t\t\t\"type\": \"function\",\n   359\t\t\t\t\t\t\"function\": map[string]interface{}{\n   360\t\t\t\t\t\t\t\"name\":        tm[\"name\"],\n   361\t\t\t\t\t\t\t\"description\": tm[\"description\"],\n   362\t\t\t\t\t\t\t\"parameters\":  tm[\"parameters\"],\n   363\t\t\t\t\t\t},\n   364\t\t\t\t\t}\n   365\t\t\t\t} else {\n   366\t\t\t\t\twrappedTools[i] = t\n   367\t\t\t\t}\n   368\t\t\t}\n   369\t\t\tpayload[\"tools\"] = wrappedTools\n   370\n   371\t\t\tif toolChoice, ok := options[\"tool_choice\"]; ok {\n   372\t\t\t\tpayload[\"tool_choice\"] = toolChoice\n   373\t\t\t} else {\n   374\t\t\t\tpayload[\"tool_choice\"] = \"auto\"\n   375\t\t\t}\n   376\t\t}\n   377\n   378\t\t// Some providers (like Nvidia) on OpenRouter might not support stream_options\n   379\t\t// or handle it poorly. We only include it if not already provided in options.\n   380\t\tif _, ok := payload[\"stream_options\"]; !ok && !strings.Contains(strings.ToLower(model), \"nvidia\") {\n   381\t\t\tpayload[\"stream_options\"] = map[string]interface{}{\n   382\t\t\t\t\"include_usage\": true,\n   383\t\t\t}\n   384\t\t}\n   385\n   386\t\tbody, err := json.Marshal(payload)\n   387\t\tif err != nil {\n   388\t\t\terrCh <- err\n   389\t\t\treturn\n   390\t\t}\n   391\n   392\t\treq, err := http.NewRequestWithContext(ctx, \"POST\", p.baseURL, bytes.NewBuffer(body))\n   393\t\tif err != nil {\n   394\t\t\terrCh <- err\n   395\t\t\treturn\n   396\t\t}\n   397\n   398\t\treq.Header.Set(\"Authorization\", \"Bearer \"+p.apiKey)\n   399\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n   400\t\tif p.siteURL != \"\" {\n   401\t\t\treq.Header.Set(\"HTTP-Referer\", p.siteURL)\n   402\t\t}\n   403\t\tif p.appName != \"\" {\n   404\t\t\treq.Header.Set(\"X-Title\", p.appName)\n   405\t\t}\n   406\n   407\t\tresp, err := p.client.Do(req)\n   408\t\tif err != nil {\n   409\t\t\terrCh <- err\n   410\t\t\treturn\n   411\t\t}\n   412\t\tdefer resp.Body.Close()\n   413\n   414\t\tif resp.StatusCode != http.StatusOK {\n   415\t\t\trespBody, _ := io.ReadAll(resp.Body)\n   416\t\t\terrCh <- fmt.Errorf(\"openrouter stream request failed with status %d: %s\", resp.StatusCode, string(respBody))\n   417\t\t\treturn\n   418\t\t}\n   419\n   420\t\treader := bufio.NewReader(resp.Body)\n   421\t\tfor {\n   422\t\t\tline, err := reader.ReadString('\\n')\n   423\t\t\tif err != nil {\n   424\t\t\t\tif err != io.EOF {\n   425\t\t\t\t\terrCh <- err\n   426\t\t\t\t}\n   427\t\t\t\treturn\n   428\t\t\t}\n   429\n   430\t\t\tline = strings.TrimSpace(line)\n   431\t\t\tif line == \"\" {\n   432\t\t\t\tcontinue\n   433\t\t\t}\n   434\t\t\tif !strings.HasPrefix(line, \"data: \") {\n   435\t\t\t\tcontinue\n   436\t\t\t}\n   437\n   438\t\t\tdataStr := strings.TrimPrefix(line, \"data: \")\n   439\t\t\tif dataStr == \"[DONE]\" {\n   440\t\t\t\treturn\n   441\t\t\t}\n   442\n   443\t\t\tvar data map[string]interface{}\n   444\t\t\tif err := json.Unmarshal([]byte(dataStr), &data); err != nil {\n   445\t\t\t\tcontinue\n   446\t\t\t}\n   447\n   448\t\t\tvar usage *types.Usage\n   449\t\t\tif usageData, ok := data[\"usage\"].(map[string]interface{}); ok {\n   450\t\t\t\tusage = &types.Usage{}\n   451\t\t\t\tif v, ok := usageData[\"prompt_tokens\"].(float64); ok {\n   452\t\t\t\t\tusage.InputTokens = int(v)\n   453\t\t\t\t}\n   454\t\t\t\tif v, ok := usageData[\"completion_tokens\"].(float64); ok {\n   455\t\t\t\t\tusage.OutputTokens = int(v)\n   456\t\t\t\t}\n   457\t\t\t\tif v, ok := usageData[\"total_tokens\"].(float64); ok {\n   458\t\t\t\t\tusage.TotalTokens = int(v)\n   459\t\t\t\t}\n   460\t\t\t\tif v, ok := usageData[\"cost\"].(float64); ok {\n   461\t\t\t\t\tusage.Cost = v\n   462\t\t\t\t}\n   463\t\t\t}\n   464\n   465\t\t\tchoices, _ := data[\"choices\"].([]interface{})\n   466\t\t\tif len(choices) > 0 {\n   467\t\t\t\tchoice, ok := choices[0].(map[string]interface{})\n   468\t\t\t\tif !ok {\n   469\t\t\t\t\tcontinue\n   470\t\t\t\t}\n   471\t\t\t\tdelta, _ := choice[\"delta\"].(map[string]interface{})\n   472\t\t\t\tif delta == nil {\n   473\t\t\t\t\tcontinue\n   474\t\t\t\t}\n   475\t\t\t\tcontent, _ := delta[\"content\"].(string)\n   476\n   477\t\t\t\t// OpenRouter models use various fields for reasoning/thought\n   478\t\t\t\treasoning, _ := delta[\"reasoning\"].(string)\n   479\t\t\t\tif reasoning == \"\" {\n   480\t\t\t\t\treasoning, _ = delta[\"reasoning_content\"].(string)\n   481\t\t\t\t}\n   482\t\t\t\tif reasoning == \"\" {\n   483\t\t\t\t\treasoning, _ = delta[\"thought\"].(string)\n   484\t\t\t\t}\n   485\t\t\t\tif reasoning == \"\" {\n   486\t\t\t\t\treasoning, _ = delta[\"thinking\"].(string)\n   487\t\t\t\t}\n   488\n   489\t\t\t\tvar toolCalls []types.ToolCallChunk\n   490\t\t\t\tif tcData, ok := delta[\"tool_calls\"].([]interface{}); ok {\n   491\t\t\t\t\tfor _, tcItem := range tcData {\n   492\t\t\t\t\t\ttc, ok := tcItem.(map[string]interface{})\n   493\t\t\t\t\t\tif !ok {\n   494\t\t\t\t\t\t\tcontinue\n   495\t\t\t\t\t\t}\n   496\t\t\t\t\t\tfn, _ := tc[\"function\"].(map[string]interface{})\n   497\t\t\t\t\t\tif fn == nil {\n   498\t\t\t\t\t\t\tcontinue\n   499\t\t\t\t\t\t}\n   500\n   501\t\t\t\t\t\tvar idx *int\n   502\t\t\t\t\t\tif idxVal, ok := tc[\"index\"].(float64); ok {\n   503\t\t\t\t\t\t\ti := int(idxVal)\n   504\t\t\t\t\t\t\tidx = &i\n   505\t\t\t\t\t\t}\n   506\n   507\t\t\t\t\t\tid, _ := tc[\"id\"].(string)\n   508\t\t\t\t\t\ttp, _ := tc[\"type\"].(string)\n   509\t\t\t\t\t\tname, _ := fn[\"name\"].(string)\n   510\t\t\t\t\t\targs, _ := fn[\"arguments\"].(string)\n   511\n   512\t\t\t\t\t\ttoolCalls = append(toolCalls, types.ToolCallChunk{\n   513\t\t\t\t\t\t\tIndex: idx,\n   514\t\t\t\t\t\t\tID:    id,\n   515\t\t\t\t\t\t\tType:  tp,\n   516\t\t\t\t\t\t\tFunction: types.FunctionChunk{\n   517\t\t\t\t\t\t\t\tName:      name,\n   518\t\t\t\t\t\t\t\tArguments: args,\n   519\t\t\t\t\t\t\t},\n   520\t\t\t\t\t\t})\n   521\t\t\t\t\t}\n   522\t\t\t\t}\n   523\n   524\t\t\t\tchunkCh <- types.ChatStreamChunk{\n   525\t\t\t\t\tContent:   content,\n   526\t\t\t\t\tReasoning: reasoning,\n   527\t\t\t\t\tToolCalls: toolCalls,\n   528\t\t\t\t\tUsage:     usage,\n   529\t\t\t\t\tRawChunk:  data,\n   530\t\t\t\t}\n   531\t\t\t} else if usage != nil {\n   532\t\t\t\t// Usage-only chunk\n   533\t\t\t\tchunkCh <- types.ChatStreamChunk{\n   534\t\t\t\t\tUsage:    usage,\n   535\t\t\t\t\tRawChunk: data,\n   536\t\t\t\t}\n   537\t\t\t}\n   538\t\t}\n   539\t}()\n   540\n   541\treturn chunkCh, errCh\n   542}\n   543\n   544func truncate(s string, maxLen int) string {\n   545\tif len(s) <= maxLen {\n   546\t\treturn s\n   547\t}\n   548\treturn s[:maxLen] + \"...\"\n   549}\n   550\n   551func getKeys(m map[string]interface{}) []string {\n   552\tkeys := make([]string, 0, len(m))\n   553\tfor k := range m {\n   554\t\tkeys = append(keys, k)\n   555\t}\n   556\treturn keys\n   557}\n   558\n   559func (p *OpenRouterProvider) Close() error {\n   560\treturn nil\n   561}\n   562\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"9dca8112-fd91-4743-a471-e05bcab1b796","timestamp":"2026-01-03T12:11:20.716Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/openrouter.go","content":"package inference\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/patrick/familiar/packages/go-backend/internal/config\"\n\t\"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n)\n\ntype OpenRouterProvider struct {\n\tapiKey  string\n\tsiteURL string\n\tappName string\n\ttimeout time.Duration\n\tbaseURL string\n\tclient  *http.Client\n}\n\nfunc NewOpenRouterProvider(apiKey, siteURL, appName string) (*OpenRouterProvider, error) {\n\tif apiKey == \"\" {\n\t\tapiKey = config.GetKeychainPassword(\"openrouter-api-key\")\n\t}\n\tif apiKey == \"\" {\n\t\treturn nil, errors.New(\"api key required for openrouter\")\n\t}\n\n\treturn &OpenRouterProvider{\n\t\tapiKey:  apiKey,\n\t\tsiteURL: siteURL,\n\t\tappName: appName,\n\t\ttimeout: 60 * time.Second,\n\t\tbaseURL: \"https://openrouter.ai/api/v1/chat/completions\",\n\t\tclient:  &http.Client{Timeout: 300 * time.Second},\n\t}, nil\n}\n\nfunc (p *OpenRouterProvider) Name() string {\n\treturn \"openrouter\"\n}\n\nfunc (p *OpenRouterProvider) ListModels(ctx context.Context) ([]string, error) {\n\treturn nil, nil\n}\n\nfunc (p *OpenRouterProvider) GetContextLimit(model string) int {\n\t// Try fetching from shared OpenRouter metadata cache\n\tif limit, ok := GetContextLimitFromOpenRouter(model); ok {\n\t\treturn limit\n\t}\n\n\treturn 128000 // Final fallback\n}\n\nfunc (p *OpenRouterProvider) convertMessages(messages []types.Message) []map[string]interface{} {\n\tapiMessages := make([]map[string]interface{}, len(messages))\n\tfor i, m := range messages {\n\t\tvar content interface{} = m.Content\n\t\tvar multiContent []map[string]interface{}\n\n\t\t// Handle Content field\n\t\tif c, ok := m.Content.(string); ok && c != \"\" {\n\t\t\tif len(m.Attachments) > 0 {\n\t\t\t\tmultiContent = append(multiContent, map[string]interface{}{\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": c,\n\t\t\t\t})\n\t\t\t}\n\t\t} else if parts, ok := m.Content.([]interface{}); ok {\n\t\t\tslog.Debug(\"OpenRouter: content is array\", \"num_parts\", len(parts))\n\t\t\tfor _, part := range parts {\n\t\t\t\tif pMap, ok := part.(map[string]interface{}); ok {\n\t\t\t\t\tslog.Debug(\"OpenRouter: adding part\", \"type\", pMap[\"type\"])\n\t\t\t\t\tmultiContent = append(multiContent, pMap)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle Attachments field\n\t\tfor _, att := range m.Attachments {\n\t\t\tif att.Type == \"image\" {\n\t\t\t\turl := att.Data\n\t\t\t\tif !strings.HasPrefix(url, \"data:\") {\n\t\t\t\t\turl = \"data:\" + att.MimeType + \";base64,\" + att.Data\n\t\t\t\t}\n\t\t\t\tmultiContent = append(multiContent, map[string]interface{}{\n\t\t\t\t\t\"type\": \"image_url\",\n\t\t\t\t\t\"image_url\": map[string]interface{}{\n\t\t\t\t\t\t\"url\": url,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// For non-image files, some models on OpenRouter might support them,\n\t\t\t\t// but generally we fall back to a text description if not images.\n\t\t\t\t// However, we should still pass them if they are common formats like PDF.\n\t\t\t\tif att.MimeType == \"application/pdf\" {\n\t\t\t\t\t// OpenRouter might support the OpenAI document format for some models,\n\t\t\t\t\t// or we can try passing it as a file block if the underlying model is Claude.\n\t\t\t\t\t// For now, let's stick to text placeholder + name to avoid breaking things,\n\t\t\t\t\t// but the ideal is native support.\n\t\t\t\t\tmultiContent = append(multiContent, map[string]interface{}{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": \"[File Attachment: \" + att.Name + \" (\" + att.MimeType + \")]\",\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tmultiContent = append(multiContent, map[string]interface{}{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": \"[File Attachment: \" + att.Name + \" (\" + att.MimeType + \")]\",\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif len(multiContent) > 0 {\n\t\t\tcontent = multiContent\n\t\t}\n\n\t\tmsg := map[string]interface{}{\n\t\t\t\"role\":    m.Role,\n\t\t\t\"content\": content,\n\t\t}\n\t\tif msg[\"content\"] == nil {\n\t\t\tmsg[\"content\"] = \"\"\n\t\t}\n\t\tif m.Name != \"\" {\n\t\t\tmsg[\"name\"] = m.Name\n\t\t}\n\t\tif m.ToolCallID != \"\" {\n\t\t\tmsg[\"tool_call_id\"] = m.ToolCallID\n\t\t}\n\t\tif len(m.ToolCalls) > 0 {\n\t\t\tmsg[\"tool_calls\"] = m.ToolCalls\n\t\t}\n\t\tapiMessages[i] = msg\n\t}\n\treturn apiMessages\n}\n\nfunc (p *OpenRouterProvider) ChatCompletion(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (*types.ChatResponse, error) {\n\t// Parse thinking configuration from model string\n\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n\n\tapiMessages := p.convertMessages(messages)\n\tpayload := map[string]interface{}{\n\t\t\"model\":    baseModel,\n\t\t\"messages\": apiMessages,\n\t}\n\n\t// Inject reasoning parameter if level is set\n\tif reasoningLevel != ReasoningNone {\n\t\tpayload[\"reasoning\"] = map[string]interface{}{\n\t\t\t\"effort\": string(reasoningLevel),\n\t\t}\n\t\tslog.Debug(\"OpenRouter: Enabling extended thinking\", \"model\", baseModel, \"level\", reasoningLevel)\n\t}\n\n\tfor k, v := range options {\n\t\tif k == \"tool_choice\" {\n\t\t\tcontinue // Handled below\n\t\t}\n\t\tpayload[k] = v\n\t}\n\n\tif tools != nil {\n\t\twrappedTools := make([]interface{}, len(tools))\n\t\tfor i, t := range tools {\n\t\t\tif tm, ok := t.(map[string]interface{}); ok {\n\t\t\t\tif _, hasType := tm[\"type\"]; hasType {\n\t\t\t\t\tif _, hasFn := tm[\"function\"]; hasFn {\n\t\t\t\t\t\twrappedTools[i] = t\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tslog.Warn(\"OpenRouter: Wrapping malformed tool definition in non-streaming call\", \"index\", i)\n\t\t\t\twrappedTools[i] = map[string]interface{}{\n\t\t\t\t\t\"type\": \"function\",\n\t\t\t\t\t\"function\": map[string]interface{}{\n\t\t\t\t\t\t\"name\":        tm[\"name\"],\n\t\t\t\t\t\t\"description\": tm[\"description\"],\n\t\t\t\t\t\t\"parameters\":  tm[\"parameters\"],\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twrappedTools[i] = t\n\t\t\t}\n\t\t}\n\t\tpayload[\"tools\"] = wrappedTools\n\n\t\tif toolChoice, ok := options[\"tool_choice\"]; ok {\n\t\t\tpayload[\"tool_choice\"] = toolChoice\n\t\t}\n\t}\n\n\tbody, err := json.Marshal(payload)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", p.baseURL, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+p.apiKey)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tif p.siteURL != \"\" {\n\t\treq.Header.Set(\"HTTP-Referer\", p.siteURL)\n\t}\n\tif p.appName != \"\" {\n\t\treq.Header.Set(\"X-Title\", p.appName)\n\t}\n\n\tstart := time.Now()\n\tresp, err := p.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\trespBody, _ := io.ReadAll(resp.Body)\n\t\treturn nil, fmt.Errorf(\"openrouter request failed with status %d: %s\", resp.StatusCode, string(respBody))\n\t}\n\n\tvar data map[string]interface{}\n\tif err := json.NewDecoder(resp.Body).Decode(&data); err != nil {\n\t\treturn nil, err\n\t}\n\n\telapsed := time.Since(start).Seconds()\n\n\tchoices, _ := data[\"choices\"].([]interface{})\n\tif len(choices) == 0 {\n\t\treturn nil, errors.New(\"no choices returned from openrouter\")\n\t}\n\n\tfirstChoice, ok := choices[0].(map[string]interface{})\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid choice format from openrouter\")\n\t}\n\tmessage, ok := firstChoice[\"message\"].(map[string]interface{})\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid message format from openrouter\")\n\t}\n\tcontent, _ := message[\"content\"].(string)\n\n\tvar toolCalls []types.ToolCall\n\tif tcData, ok := message[\"tool_calls\"].([]interface{}); ok {\n\t\tfor _, tcItem := range tcData {\n\t\t\ttc, ok := tcItem.(map[string]interface{})\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfn, ok := tc[\"function\"].(map[string]interface{})\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tid, _ := tc[\"id\"].(string)\n\t\t\ttp, _ := tc[\"type\"].(string)\n\t\t\tname, _ := fn[\"name\"].(string)\n\t\t\targs, _ := fn[\"arguments\"].(string)\n\t\t\ttoolCalls = append(toolCalls, types.ToolCall{\n\t\t\t\tID:   id,\n\t\t\t\tType: tp,\n\t\t\t\tFunction: types.ToolFunction{\n\t\t\t\t\tName:      name,\n\t\t\t\t\tArguments: args,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\tusageData, _ := data[\"usage\"].(map[string]interface{})\n\tusage := types.Usage{}\n\tif usageData != nil {\n\t\tif v, ok := usageData[\"prompt_tokens\"].(float64); ok {\n\t\t\tusage.InputTokens = int(v)\n\t\t}\n\t\tif v, ok := usageData[\"completion_tokens\"].(float64); ok {\n\t\t\tusage.OutputTokens = int(v)\n\t\t}\n\t\tif v, ok := usageData[\"total_tokens\"].(float64); ok {\n\t\t\tusage.TotalTokens = int(v)\n\t\t}\n\t\tif v, ok := usageData[\"cost\"].(float64); ok {\n\t\t\tusage.Cost = v\n\t\t}\n\t}\n\n\treturn &types.ChatResponse{\n\t\tContent:    content,\n\t\tToolCalls:  toolCalls,\n\t\tRawMessage: message,\n\t\tUsage:      usage,\n\t\tMetadata:   map[string]interface{}{\"elapsed\": elapsed},\n\t}, nil\n}\n\nfunc (p *OpenRouterProvider) ChatCompletionStream(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (<-chan types.ChatStreamChunk, <-chan error) {\n\tchunkCh := make(chan types.ChatStreamChunk)\n\terrCh := make(chan error, 1)\n\n\tgo func() {\n\t\tdefer close(chunkCh)\n\t\tdefer close(errCh)\n\n\t\t// Parse thinking configuration from model string\n\t\tbaseModel, reasoningLevel := ParseThinkingModel(model)\n\n\t\tapiMessages := p.convertMessages(messages)\n\n\t\tpayload := map[string]interface{}{\n\t\t\t\"model\":    baseModel,\n\t\t\t\"messages\": apiMessages,\n\t\t\t\"stream\":   true,\n\t\t}\n\n\t\t// Inject reasoning parameter if level is set\n\t\tif reasoningLevel != ReasoningNone {\n\t\t\tpayload[\"reasoning\"] = map[string]interface{}{\n\t\t\t\t\"effort\": string(reasoningLevel),\n\t\t\t}\n\t\t\tslog.Debug(\"OpenRouter: Enabling extended thinking (stream)\", \"model\", baseModel, \"level\", reasoningLevel)\n\t\t}\n\n\t\t// Pass all options through\n\t\tfor k, v := range options {\n\t\t\tif k == \"tool_choice\" {\n\t\t\t\tcontinue // Handled below\n\t\t\t}\n\t\t\tpayload[k] = v\n\t\t}\n\n\t\tif tools != nil {\n\t\t\twrappedTools := make([]interface{}, len(tools))\n\t\t\tfor i, t := range tools {\n\t\t\t\tif tm, ok := t.(map[string]interface{}); ok {\n\t\t\t\t\t// If it already has the wrapper, use it as-is\n\t\t\t\t\tif _, hasType := tm[\"type\"]; hasType {\n\t\t\t\t\t\tif _, hasFn := tm[\"function\"]; hasFn {\n\t\t\t\t\t\t\twrappedTools[i] = t\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, wrap it (it's likely a flat definition)\n\t\t\t\t\tslog.Warn(\"OpenRouter: Wrapping malformed tool definition\", \"index\", i)\n\t\t\t\t\twrappedTools[i] = map[string]interface{}{\n\t\t\t\t\t\t\"type\": \"function\",\n\t\t\t\t\t\t\"function\": map[string]interface{}{\n\t\t\t\t\t\t\t\"name\":        tm[\"name\"],\n\t\t\t\t\t\t\t\"description\": tm[\"description\"],\n\t\t\t\t\t\t\t\"parameters\":  tm[\"parameters\"],\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twrappedTools[i] = t\n\t\t\t\t}\n\t\t\t}\n\t\t\tpayload[\"tools\"] = wrappedTools\n\n\t\t\tif toolChoice, ok := options[\"tool_choice\"]; ok {\n\t\t\t\tpayload[\"tool_choice\"] = toolChoice\n\t\t\t} else {\n\t\t\t\tpayload[\"tool_choice\"] = \"auto\"\n\t\t\t}\n\t\t}\n\n\t\t// Some providers (like Nvidia) on OpenRouter might not support stream_options\n\t\t// or handle it poorly. We only include it if not already provided in options.\n\t\tif _, ok := payload[\"stream_options\"]; !ok && !strings.Contains(strings.ToLower(model), \"nvidia\") {\n\t\t\tpayload[\"stream_options\"] = map[string]interface{}{\n\t\t\t\t\"include_usage\": true,\n\t\t\t}\n\t\t}\n\n\t\tbody, err := json.Marshal(payload)\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\treq, err := http.NewRequestWithContext(ctx, \"POST\", p.baseURL, bytes.NewBuffer(body))\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\treq.Header.Set(\"Authorization\", \"Bearer \"+p.apiKey)\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t\tif p.siteURL != \"\" {\n\t\t\treq.Header.Set(\"HTTP-Referer\", p.siteURL)\n\t\t}\n\t\tif p.appName != \"\" {\n\t\t\treq.Header.Set(\"X-Title\", p.appName)\n\t\t}\n\n\t\tresp, err := p.client.Do(req)\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\trespBody, _ := io.ReadAll(resp.Body)\n\t\t\terrCh <- fmt.Errorf(\"openrouter stream request failed with status %d: %s\", resp.StatusCode, string(respBody))\n\t\t\treturn\n\t\t}\n\n\t\treader := bufio.NewReader(resp.Body)\n\t\tfor {\n\t\t\tline, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tif err != io.EOF {\n\t\t\t\t\terrCh <- err\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tline = strings.TrimSpace(line)\n\t\t\tif line == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !strings.HasPrefix(line, \"data: \") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdataStr := strings.TrimPrefix(line, \"data: \")\n\t\t\tif dataStr == \"[DONE]\" {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar data map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(dataStr), &data); err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar usage *types.Usage\n\t\t\tif usageData, ok := data[\"usage\"].(map[string]interface{}); ok {\n\t\t\t\tusage = &types.Usage{}\n\t\t\t\tif v, ok := usageData[\"prompt_tokens\"].(float64); ok {\n\t\t\t\t\tusage.InputTokens = int(v)\n\t\t\t\t}\n\t\t\t\tif v, ok := usageData[\"completion_tokens\"].(float64); ok {\n\t\t\t\t\tusage.OutputTokens = int(v)\n\t\t\t\t}\n\t\t\t\tif v, ok := usageData[\"total_tokens\"].(float64); ok {\n\t\t\t\t\tusage.TotalTokens = int(v)\n\t\t\t\t}\n\t\t\t\tif v, ok := usageData[\"cost\"].(float64); ok {\n\t\t\t\t\tusage.Cost = v\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchoices, _ := data[\"choices\"].([]interface{})\n\t\t\tif len(choices) > 0 {\n\t\t\t\tchoice, ok := choices[0].(map[string]interface{})\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdelta, _ := choice[\"delta\"].(map[string]interface{})\n\t\t\t\tif delta == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tcontent, _ := delta[\"content\"].(string)\n\n\t\t\t\t// OpenRouter models use various fields for reasoning/thought\n\t\t\t\treasoning, _ := delta[\"reasoning\"].(string)\n\t\t\t\tif reasoning == \"\" {\n\t\t\t\t\treasoning, _ = delta[\"reasoning_content\"].(string)\n\t\t\t\t}\n\t\t\t\tif reasoning == \"\" {\n\t\t\t\t\treasoning, _ = delta[\"thought\"].(string)\n\t\t\t\t}\n\t\t\t\tif reasoning == \"\" {\n\t\t\t\t\treasoning, _ = delta[\"thinking\"].(string)\n\t\t\t\t}\n\n\t\t\t\tvar toolCalls []types.ToolCallChunk\n\t\t\t\tif tcData, ok := delta[\"tool_calls\"].([]interface{}); ok {\n\t\t\t\t\tfor _, tcItem := range tcData {\n\t\t\t\t\t\ttc, ok := tcItem.(map[string]interface{})\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfn, _ := tc[\"function\"].(map[string]interface{})\n\t\t\t\t\t\tif fn == nil {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar idx *int\n\t\t\t\t\t\tif idxVal, ok := tc[\"index\"].(float64); ok {\n\t\t\t\t\t\t\ti := int(idxVal)\n\t\t\t\t\t\t\tidx = &i\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tid, _ := tc[\"id\"].(string)\n\t\t\t\t\t\ttp, _ := tc[\"type\"].(string)\n\t\t\t\t\t\tname, _ := fn[\"name\"].(string)\n\t\t\t\t\t\targs, _ := fn[\"arguments\"].(string)\n\n\t\t\t\t\t\ttoolCalls = append(toolCalls, types.ToolCallChunk{\n\t\t\t\t\t\t\tIndex: idx,\n\t\t\t\t\t\t\tID:    id,\n\t\t\t\t\t\t\tType:  tp,\n\t\t\t\t\t\t\tFunction: types.FunctionChunk{\n\t\t\t\t\t\t\t\tName:      name,\n\t\t\t\t\t\t\t\tArguments: args,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchunkCh <- types.ChatStreamChunk{\n\t\t\t\t\tContent:   content,\n\t\t\t\t\tReasoning: reasoning,\n\t\t\t\t\tToolCalls: toolCalls,\n\t\t\t\t\tUsage:     usage,\n\t\t\t\t\tRawChunk:  data,\n\t\t\t\t}\n\t\t\t} else if usage != nil {\n\t\t\t\t// Usage-only chunk\n\t\t\t\tchunkCh <- types.ChatStreamChunk{\n\t\t\t\t\tUsage:    usage,\n\t\t\t\t\tRawChunk: data,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn chunkCh, errCh\n}\n\nfunc truncate(s string, maxLen int) string {\n\tif len(s) <= maxLen {\n\t\treturn s\n\t}\n\treturn s[:maxLen] + \"...\"\n}\n\nfunc getKeys(m map[string]interface{}) []string {\n\tkeys := make([]string, 0, len(m))\n\tfor k := range m {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\nfunc (p *OpenRouterProvider) Close() error {\n\treturn nil\n}\n","numLines":562,"startLine":1,"totalLines":562}}}
{"parentUuid":"9dca8112-fd91-4743-a471-e05bcab1b796","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01443rdBY4Zh5tU7zxTGzBgb","type":"tool_result","content":"workingdir/familiar/packages/go-backend/pkg/types/chat.go:70:\tInputTokens  int     `json:\"input_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/chat.go:71:\tOutputTokens int     `json:\"output_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/chat.go:72:\tTotalTokens  int     `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/chat.go:81:\tInputTokens  int       `json:\"input_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/chat.go:82:\tOutputTokens int       `json:\"output_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/chat.go:83:\tTotalTokens  int       `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/agent.go:83:\tContextTokens    int            `json:\"context_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/agent.go:84:\tMaxContextTokens int            `json:\"max_context_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/agent.go:94:\tMaxTokens   int     `json:\"max_tokens,omitempty\"`\nworkingdir/familiar/packages/go-backend/go.sum:243:modernc.org/token v1.1.0 h1:Xl7Ap9dKaEs5kLoOQeQmPWevfnk/DM5qcLcYlA8ys6Y=\nworkingdir/familiar/packages/go-backend/go.sum:244:modernc.org/token v1.1.0/go.mod h1:UGzOrNV1mAFSEB63lOFHIpNRUVMvYTc6yu1SMY/XTDM=\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic_stream_test.go:19:\t\t\t`data: {\"type\": \"message_start\", \"message\": {\"id\": \"msg_123\", \"usage\": {\"input_tokens\": 10}}}`,\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic_stream_test.go:34:\t\t\t`data: {\"type\": \"message_delta\", \"usage\": {\"output_tokens\": 5}}`,\nworkingdir/familiar/packages/go-backend/internal/inference/metadata.go:23:\tPricingPrompt     float64 `json:\"pricing_prompt\"`     // Cost per million input tokens\nworkingdir/familiar/packages/go-backend/internal/inference/metadata.go:24:\tPricingCompletion float64 `json:\"pricing_completion\"`   // Cost per million output tokens\nworkingdir/familiar/packages/go-backend/internal/inference/metadata.go:327:\t\t\t// OpenRouter API returns pricing per token, convert to per million tokens\nworkingdir/familiar/packages/go-backend/internal/inference/metadata.go:444:// GetAnthropicBudget returns the budget_tokens value for Anthropic based on reasoning level\nworkingdir/familiar/packages/go-backend/internal/inference/metadata.go:474:// GetModelPricing returns the pricing for a model (input/output cost per million tokens)\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter_test.go:34:\t\t\t\"prompt_tokens\":     10.0,\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter_test.go:35:\t\t\t\"completion_tokens\": 20.0,\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter_test.go:36:\t\t\t\"total_tokens\":      30.0,\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter_test.go:68:\t\tt.Errorf(\"Expected total tokens 30, got %d\", resp.Usage.TotalTokens)\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:213:\treq.Header.Set(\"Authorization\", \"Bearer \"+p.apiKey)\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:285:\t\tif v, ok := usageData[\"prompt_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:288:\t\tif v, ok := usageData[\"completion_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:291:\t\tif v, ok := usageData[\"total_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:398:\t\treq.Header.Set(\"Authorization\", \"Bearer \"+p.apiKey)\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:451:\t\t\t\tif v, ok := usageData[\"prompt_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:454:\t\t\t\tif v, ok := usageData[\"completion_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:457:\t\t\t\tif v, ok := usageData[\"total_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/agent/compaction_test.go:30:\ttokens := CountTokens(messages)\nworkingdir/familiar/packages/go-backend/internal/agent/compaction_test.go:31:\tif tokens < 15 || tokens > 50 {\nworkingdir/familiar/packages/go-backend/internal/agent/compaction_test.go:32:\t\tt.Errorf(\"Expected tokens in reasonable range (15-50), got %d\", tokens)\nworkingdir/familiar/packages/go-backend/internal/agent/compaction_test.go:63:\t// Compact if tokens > 10, preserve 1 recent\nworkingdir/familiar/packages/go-backend/internal/agent/tool_result_storage.go:161:\ttokenCount := estimateTokens(content)\nworkingdir/familiar/packages/go-backend/internal/agent/tool_result_storage.go:162:\tif tokenCount <= maxToolResultTokens {\nworkingdir/familiar/packages/go-backend/internal/agent/tool_result_storage.go:182:\tprocessedContent = fmt.Sprintf(\"[Tool Result Summary]\\n%s\\n\\n[Full result (%d tokens) stored at: %s. You can read it using workspace_read with path '%s'.]\", summary, tokenCount, relativePath, relativePath)\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:50:\t// Anthropic models generally support 200k tokens\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:268:\t// Set max_tokens higher when thinking is enabled\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:278:\t\t\"max_tokens\": maxTokens,\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:285:\t\t\t\"budget_tokens\": thinkingBudget,\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:369:\t\t\tInputTokens:  int(usageData[\"input_tokens\"].(float64)),\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:370:\t\t\tOutputTokens: int(usageData[\"output_tokens\"].(float64)),\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:388:\t\t// Set max_tokens higher when thinking is enabled\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:398:\t\t\t\"max_tokens\": maxTokens,\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:406:\t\t\t\t\"budget_tokens\": thinkingBudget,\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:481:\t\t\t\t\t\t\tif it, ok := usage[\"input_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:538:\t\t\t\t\t\tif ot, ok := usage[\"output_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/agent/runtime_agent.go:62:\t// Update token limits based on the new model\nworkingdir/familiar/packages/go-backend/internal/agent/runtime_agent.go:325:\t\t\"input_tokens\":  u.InputTokens,\nworkingdir/familiar/packages/go-backend/internal/agent/runtime_agent.go:326:\t\t\"output_tokens\": u.OutputTokens,\nworkingdir/familiar/packages/go-backend/internal/agent/runtime_agent.go:327:\t\t\"total_tokens\":  u.TotalTokens,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:319:\t// We use the last known total token count from the previous turn for a better estimate\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:325:\tsystemInfo := fmt.Sprintf(\"System Info:\\n- Current date and time: %s\\n- Context Usage: %.1f%% (%d/%d tokens used in previous turn)\", now, contextPct, sa.TokensUsed, sa.MaxContextTokens)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:508:\t\t// During manual repair, we use all tools the agent is aware of for token counting\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:516:\ttokenCountBefore := CountTokensWithTools(workingMessages, toolDefs)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:539:\t\tslog.Info(\"History compaction performed\", \"tokens_saved\", tokenCountBefore-currentTokenCount, \"forced\", force)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:542:\t\t\t\"tokens_before\": tokenCountBefore,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:543:\t\t\t\"tokens_after\":  currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:544:\t\t\t\"tokens_saved\":  tokenCountBefore - currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:570:\t// parentScope context is not strictly needed for just counting tokens,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:580:\ttokenCount := CountTokensWithTools(messages, toolDefs)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:583:\t\tsa.OnContextUpdate(sa.ID, tokenCount, sa.MaxContextTokens)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:972:\t\ttokenCountBefore := CountTokensWithTools(messages, toolDefs)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:988:\t\tcurrentTokenCount := tokenCountBefore\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:991:\t\t\tslog.Info(\"History compacted in ProposeScope\", \"tokens_saved\", tokenCountBefore-currentTokenCount)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:994:\t\t\t\t\"tokens_before\": tokenCountBefore,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:995:\t\t\t\t\"tokens_after\":  currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:996:\t\t\t\t\"tokens_saved\":  tokenCountBefore - currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1173:\t\t\t\t\t\t\t\t\tslog.Info(\"Stored large tool result\", \"tool\", tc.Function.Name, \"path\", relativePath, \"tokens\", estimateTokens(toolRes.Content))\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1511:\t// We ONLY keep Objective and Plan in the context to be extremely token efficient.\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1782:\t\ttokenCountBefore := CountTokensWithTools(workingMessages, toolDefs)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1783:\t\tcurrentTokenCount := tokenCountBefore\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1808:\t\t\t\tslog.Info(\"History compacted in Run loop\", \"tokens_saved\", tokenCountBefore-currentTokenCount, \"forced\", force)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1811:\t\t\t\t\t\"tokens_before\": tokenCountBefore,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1812:\t\t\t\t\t\"tokens_after\":  currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1813:\t\t\t\t\t\"tokens_saved\":  tokenCountBefore - currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1969:\t\t// Update context tokens with accurate count from provider\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:2229:\t\t\t\t\t\tslog.Info(\"Stored large tool result\", \"tool\", tc.Function.Name, \"path\", relativePath, \"tokens\", estimateTokens(toolRes.Content))\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:22:// CountTokens provides a rough estimate of token count.\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:23:// In a full implementation, this should use a library like tiktoken-go.\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:40:\t\t\t// Parameters schema usually takes a lot of tokens. \nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:41:\t\t\t// A typical function schema is 200-500 tokens.\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:62:\t\t\t\t\t\t// Handle image tokens\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:97:\t// - For normal text, ~4 chars per token\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:98:\t// - For code/dense text, ~2.5-3 chars per token\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:105:\t// Code has many tokens per word because of symbols.\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:115:// NeedsCompaction checks if the message list exceeds the max token limit.\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:141:\t\t\"tokens\", CountTokensWithTools(messages, toolDefs),\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:238:\tslog.Info(\"Compaction complete\", \"final_tokens\", finalTokens, \"target\", targetTokens)\nworkingdir/familiar/packages/go-backend/internal/config/loader.go:47:\t\tMaxToolResultTokens    *int  `yaml:\"max_tool_result_tokens\" json:\"max_tool_result_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/config/loader.go:261:claude -p \"Refactor the authentication module to use JWT tokens\"\nworkingdir/familiar/packages/go-backend/internal/config/loader.go:560:\t// Default max tool result tokens\nworkingdir/familiar/packages/go-backend/internal/config/loader.go:562:\t\ttokens := 5000\nworkingdir/familiar/packages/go-backend/internal/config/loader.go:563:\t\tc.Agent.MaxToolResultTokens = &tokens\nworkingdir/familiar/packages/go-backend/internal/tools/agent.go:31:\t\t\t\t\t\t\"description\": \"The initial prompt/instructions for the sub-agent. IMPORTANT: Keep this mission extremely short and concise (a few sentences max) to remain token-efficient.\",\nworkingdir/familiar/packages/go-backend/internal/tools/agent.go:380:\t\t\tDescription: \"Manually trigger chat history compaction to free up token space in your context window. Use this when the conversation is getting long and you want to summarize older context and archive it. This will archive the older half of the conversation to 'history_archive.md'. You are encouraged to provide your own concise summary of the conversation being compacted.\",\nworkingdir/familiar/packages/go-backend/internal/storage/migrations.go:31:\t\t\t\tcontext_tokens INTEGER DEFAULT 0,\nworkingdir/familiar/packages/go-backend/internal/storage/migrations.go:32:\t\t\t\tmax_context_tokens INTEGER DEFAULT 0,\nworkingdir/familiar/packages/go-backend/internal/storage/migrations.go:68:\t\t\t\tinput_tokens INTEGER DEFAULT 0,\nworkingdir/familiar/packages/go-backend/internal/storage/migrations.go:69:\t\t\t\toutput_tokens INTEGER DEFAULT 0,\nworkingdir/familiar/packages/go-backend/internal/storage/migrations.go:70:\t\t\t\ttotal_tokens INTEGER DEFAULT 0,\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:66:\tTotalInputTokens  int     `json:\"total_input_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:67:\tTotalOutputTokens int     `json:\"total_output_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:68:\tTotalTokens       int     `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:76:\tTotalInputTokens  int     `json:\"total_input_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:77:\tTotalOutputTokens int     `json:\"total_output_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:78:\tTotalTokens       int     `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:85:\tInputTokens  int     `json:\"input_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:86:\tOutputTokens int     `json:\"output_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:87:\tTotalTokens  int     `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:95:\tTotalInputTokens  int     `json:\"total_input_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:96:\tTotalOutputTokens int     `json:\"total_output_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:97:\tTotalTokens       int     `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:122:\t\t`INSERT INTO usage (id, agent_id, provider, model, input_tokens, output_tokens, total_tokens, cost, created_at) \nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:130:\tquery := \"SELECT COUNT(*), SUM(input_tokens), SUM(output_tokens), SUM(total_tokens), SUM(cost) FROM usage\"\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:168:\tquery := \"SELECT id, agent_id, provider, model, input_tokens, output_tokens, total_tokens, cost, created_at FROM usage\"\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:214:\tquery := \"SELECT provider, model, COUNT(*), SUM(input_tokens), SUM(output_tokens), SUM(total_tokens), SUM(cost) FROM usage\"\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:264:\t\t\tSUM(u.input_tokens), \nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:265:\t\t\tSUM(u.output_tokens), \nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:266:\t\t\tSUM(u.total_tokens), \nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:358:\t\t// Rough estimate of tokens (chars / 3)\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:413:\t\t`SELECT strftime('%Y-%m-%d', created_at) as date, COUNT(*), SUM(input_tokens), SUM(output_tokens), SUM(total_tokens), SUM(cost) \nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:639:\t\t`INSERT INTO agents (id, parent_id, type, name, state, current_scope_id, initial_prompt, system_prompt, plan_enabled, sub_agents_enabled, is_internal, working_directory, error_detail, model_config, context_tokens, max_context_tokens, is_compacting, created_at, updated_at)\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:653:\t\t\"SELECT id, parent_id, type, name, state, current_scope_id, initial_prompt, system_prompt, plan_enabled, sub_agents_enabled, is_internal, working_directory, error_detail, model_config, context_tokens, max_context_tokens, is_compacting, created_at, updated_at FROM agents WHERE id = ?\",\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:764:\t_, err := db.Exec(\"UPDATE agents SET context_tokens = ?, max_context_tokens = ?, updated_at = ? WHERE id = ?\", contextTokens, maxContextTokens, now, id)\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:779:\tquery := \"SELECT id, parent_id, type, name, state, current_scope_id, initial_prompt, system_prompt, plan_enabled, sub_agents_enabled, is_internal, working_directory, error_detail, model_config, context_tokens, max_context_tokens, is_compacting, created_at, updated_at FROM agents\""}]},"uuid":"e5f2ecbc-85d6-47bf-be6a-bf9853865300","timestamp":"2026-01-03T12:11:21.105Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"workingdir/familiar/packages/go-backend/pkg/types/chat.go:70:\tInputTokens  int     `json:\"input_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/chat.go:71:\tOutputTokens int     `json:\"output_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/chat.go:72:\tTotalTokens  int     `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/chat.go:81:\tInputTokens  int       `json:\"input_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/chat.go:82:\tOutputTokens int       `json:\"output_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/chat.go:83:\tTotalTokens  int       `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/agent.go:83:\tContextTokens    int            `json:\"context_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/agent.go:84:\tMaxContextTokens int            `json:\"max_context_tokens\"`\nworkingdir/familiar/packages/go-backend/pkg/types/agent.go:94:\tMaxTokens   int     `json:\"max_tokens,omitempty\"`\nworkingdir/familiar/packages/go-backend/go.sum:243:modernc.org/token v1.1.0 h1:Xl7Ap9dKaEs5kLoOQeQmPWevfnk/DM5qcLcYlA8ys6Y=\nworkingdir/familiar/packages/go-backend/go.sum:244:modernc.org/token v1.1.0/go.mod h1:UGzOrNV1mAFSEB63lOFHIpNRUVMvYTc6yu1SMY/XTDM=\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic_stream_test.go:19:\t\t\t`data: {\"type\": \"message_start\", \"message\": {\"id\": \"msg_123\", \"usage\": {\"input_tokens\": 10}}}`,\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic_stream_test.go:34:\t\t\t`data: {\"type\": \"message_delta\", \"usage\": {\"output_tokens\": 5}}`,\nworkingdir/familiar/packages/go-backend/internal/inference/metadata.go:23:\tPricingPrompt     float64 `json:\"pricing_prompt\"`     // Cost per million input tokens\nworkingdir/familiar/packages/go-backend/internal/inference/metadata.go:24:\tPricingCompletion float64 `json:\"pricing_completion\"`   // Cost per million output tokens\nworkingdir/familiar/packages/go-backend/internal/inference/metadata.go:327:\t\t\t// OpenRouter API returns pricing per token, convert to per million tokens\nworkingdir/familiar/packages/go-backend/internal/inference/metadata.go:444:// GetAnthropicBudget returns the budget_tokens value for Anthropic based on reasoning level\nworkingdir/familiar/packages/go-backend/internal/inference/metadata.go:474:// GetModelPricing returns the pricing for a model (input/output cost per million tokens)\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter_test.go:34:\t\t\t\"prompt_tokens\":     10.0,\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter_test.go:35:\t\t\t\"completion_tokens\": 20.0,\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter_test.go:36:\t\t\t\"total_tokens\":      30.0,\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter_test.go:68:\t\tt.Errorf(\"Expected total tokens 30, got %d\", resp.Usage.TotalTokens)\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:213:\treq.Header.Set(\"Authorization\", \"Bearer \"+p.apiKey)\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:285:\t\tif v, ok := usageData[\"prompt_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:288:\t\tif v, ok := usageData[\"completion_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:291:\t\tif v, ok := usageData[\"total_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:398:\t\treq.Header.Set(\"Authorization\", \"Bearer \"+p.apiKey)\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:451:\t\t\t\tif v, ok := usageData[\"prompt_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:454:\t\t\t\tif v, ok := usageData[\"completion_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/openrouter.go:457:\t\t\t\tif v, ok := usageData[\"total_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/agent/compaction_test.go:30:\ttokens := CountTokens(messages)\nworkingdir/familiar/packages/go-backend/internal/agent/compaction_test.go:31:\tif tokens < 15 || tokens > 50 {\nworkingdir/familiar/packages/go-backend/internal/agent/compaction_test.go:32:\t\tt.Errorf(\"Expected tokens in reasonable range (15-50), got %d\", tokens)\nworkingdir/familiar/packages/go-backend/internal/agent/compaction_test.go:63:\t// Compact if tokens > 10, preserve 1 recent\nworkingdir/familiar/packages/go-backend/internal/agent/tool_result_storage.go:161:\ttokenCount := estimateTokens(content)\nworkingdir/familiar/packages/go-backend/internal/agent/tool_result_storage.go:162:\tif tokenCount <= maxToolResultTokens {\nworkingdir/familiar/packages/go-backend/internal/agent/tool_result_storage.go:182:\tprocessedContent = fmt.Sprintf(\"[Tool Result Summary]\\n%s\\n\\n[Full result (%d tokens) stored at: %s. You can read it using workspace_read with path '%s'.]\", summary, tokenCount, relativePath, relativePath)\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:50:\t// Anthropic models generally support 200k tokens\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:268:\t// Set max_tokens higher when thinking is enabled\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:278:\t\t\"max_tokens\": maxTokens,\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:285:\t\t\t\"budget_tokens\": thinkingBudget,\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:369:\t\t\tInputTokens:  int(usageData[\"input_tokens\"].(float64)),\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:370:\t\t\tOutputTokens: int(usageData[\"output_tokens\"].(float64)),\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:388:\t\t// Set max_tokens higher when thinking is enabled\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:398:\t\t\t\"max_tokens\": maxTokens,\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:406:\t\t\t\t\"budget_tokens\": thinkingBudget,\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:481:\t\t\t\t\t\t\tif it, ok := usage[\"input_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/inference/anthropic.go:538:\t\t\t\t\t\tif ot, ok := usage[\"output_tokens\"].(float64); ok {\nworkingdir/familiar/packages/go-backend/internal/agent/runtime_agent.go:62:\t// Update token limits based on the new model\nworkingdir/familiar/packages/go-backend/internal/agent/runtime_agent.go:325:\t\t\"input_tokens\":  u.InputTokens,\nworkingdir/familiar/packages/go-backend/internal/agent/runtime_agent.go:326:\t\t\"output_tokens\": u.OutputTokens,\nworkingdir/familiar/packages/go-backend/internal/agent/runtime_agent.go:327:\t\t\"total_tokens\":  u.TotalTokens,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:319:\t// We use the last known total token count from the previous turn for a better estimate\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:325:\tsystemInfo := fmt.Sprintf(\"System Info:\\n- Current date and time: %s\\n- Context Usage: %.1f%% (%d/%d tokens used in previous turn)\", now, contextPct, sa.TokensUsed, sa.MaxContextTokens)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:508:\t\t// During manual repair, we use all tools the agent is aware of for token counting\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:516:\ttokenCountBefore := CountTokensWithTools(workingMessages, toolDefs)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:539:\t\tslog.Info(\"History compaction performed\", \"tokens_saved\", tokenCountBefore-currentTokenCount, \"forced\", force)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:542:\t\t\t\"tokens_before\": tokenCountBefore,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:543:\t\t\t\"tokens_after\":  currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:544:\t\t\t\"tokens_saved\":  tokenCountBefore - currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:570:\t// parentScope context is not strictly needed for just counting tokens,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:580:\ttokenCount := CountTokensWithTools(messages, toolDefs)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:583:\t\tsa.OnContextUpdate(sa.ID, tokenCount, sa.MaxContextTokens)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:972:\t\ttokenCountBefore := CountTokensWithTools(messages, toolDefs)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:988:\t\tcurrentTokenCount := tokenCountBefore\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:991:\t\t\tslog.Info(\"History compacted in ProposeScope\", \"tokens_saved\", tokenCountBefore-currentTokenCount)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:994:\t\t\t\t\"tokens_before\": tokenCountBefore,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:995:\t\t\t\t\"tokens_after\":  currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:996:\t\t\t\t\"tokens_saved\":  tokenCountBefore - currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1173:\t\t\t\t\t\t\t\t\tslog.Info(\"Stored large tool result\", \"tool\", tc.Function.Name, \"path\", relativePath, \"tokens\", estimateTokens(toolRes.Content))\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1511:\t// We ONLY keep Objective and Plan in the context to be extremely token efficient.\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1782:\t\ttokenCountBefore := CountTokensWithTools(workingMessages, toolDefs)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1783:\t\tcurrentTokenCount := tokenCountBefore\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1808:\t\t\t\tslog.Info(\"History compacted in Run loop\", \"tokens_saved\", tokenCountBefore-currentTokenCount, \"forced\", force)\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1811:\t\t\t\t\t\"tokens_before\": tokenCountBefore,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1812:\t\t\t\t\t\"tokens_after\":  currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1813:\t\t\t\t\t\"tokens_saved\":  tokenCountBefore - currentTokenCount,\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:1969:\t\t// Update context tokens with accurate count from provider\nworkingdir/familiar/packages/go-backend/internal/agent/stateful_agent.go:2229:\t\t\t\t\t\tslog.Info(\"Stored large tool result\", \"tool\", tc.Function.Name, \"path\", relativePath, \"tokens\", estimateTokens(toolRes.Content))\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:22:// CountTokens provides a rough estimate of token count.\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:23:// In a full implementation, this should use a library like tiktoken-go.\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:40:\t\t\t// Parameters schema usually takes a lot of tokens. \nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:41:\t\t\t// A typical function schema is 200-500 tokens.\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:62:\t\t\t\t\t\t// Handle image tokens\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:97:\t// - For normal text, ~4 chars per token\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:98:\t// - For code/dense text, ~2.5-3 chars per token\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:105:\t// Code has many tokens per word because of symbols.\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:115:// NeedsCompaction checks if the message list exceeds the max token limit.\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:141:\t\t\"tokens\", CountTokensWithTools(messages, toolDefs),\nworkingdir/familiar/packages/go-backend/internal/agent/compaction.go:238:\tslog.Info(\"Compaction complete\", \"final_tokens\", finalTokens, \"target\", targetTokens)\nworkingdir/familiar/packages/go-backend/internal/config/loader.go:47:\t\tMaxToolResultTokens    *int  `yaml:\"max_tool_result_tokens\" json:\"max_tool_result_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/config/loader.go:261:claude -p \"Refactor the authentication module to use JWT tokens\"\nworkingdir/familiar/packages/go-backend/internal/config/loader.go:560:\t// Default max tool result tokens\nworkingdir/familiar/packages/go-backend/internal/config/loader.go:562:\t\ttokens := 5000\nworkingdir/familiar/packages/go-backend/internal/config/loader.go:563:\t\tc.Agent.MaxToolResultTokens = &tokens\nworkingdir/familiar/packages/go-backend/internal/tools/agent.go:31:\t\t\t\t\t\t\"description\": \"The initial prompt/instructions for the sub-agent. IMPORTANT: Keep this mission extremely short and concise (a few sentences max) to remain token-efficient.\",\nworkingdir/familiar/packages/go-backend/internal/tools/agent.go:380:\t\t\tDescription: \"Manually trigger chat history compaction to free up token space in your context window. Use this when the conversation is getting long and you want to summarize older context and archive it. This will archive the older half of the conversation to 'history_archive.md'. You are encouraged to provide your own concise summary of the conversation being compacted.\",\nworkingdir/familiar/packages/go-backend/internal/storage/migrations.go:31:\t\t\t\tcontext_tokens INTEGER DEFAULT 0,\nworkingdir/familiar/packages/go-backend/internal/storage/migrations.go:32:\t\t\t\tmax_context_tokens INTEGER DEFAULT 0,\nworkingdir/familiar/packages/go-backend/internal/storage/migrations.go:68:\t\t\t\tinput_tokens INTEGER DEFAULT 0,\nworkingdir/familiar/packages/go-backend/internal/storage/migrations.go:69:\t\t\t\toutput_tokens INTEGER DEFAULT 0,\nworkingdir/familiar/packages/go-backend/internal/storage/migrations.go:70:\t\t\t\ttotal_tokens INTEGER DEFAULT 0,\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:66:\tTotalInputTokens  int     `json:\"total_input_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:67:\tTotalOutputTokens int     `json:\"total_output_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:68:\tTotalTokens       int     `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:76:\tTotalInputTokens  int     `json:\"total_input_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:77:\tTotalOutputTokens int     `json:\"total_output_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:78:\tTotalTokens       int     `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:85:\tInputTokens  int     `json:\"input_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:86:\tOutputTokens int     `json:\"output_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:87:\tTotalTokens  int     `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:95:\tTotalInputTokens  int     `json:\"total_input_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:96:\tTotalOutputTokens int     `json:\"total_output_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:97:\tTotalTokens       int     `json:\"total_tokens\"`\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:122:\t\t`INSERT INTO usage (id, agent_id, provider, model, input_tokens, output_tokens, total_tokens, cost, created_at) \nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:130:\tquery := \"SELECT COUNT(*), SUM(input_tokens), SUM(output_tokens), SUM(total_tokens), SUM(cost) FROM usage\"\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:168:\tquery := \"SELECT id, agent_id, provider, model, input_tokens, output_tokens, total_tokens, cost, created_at FROM usage\"\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:214:\tquery := \"SELECT provider, model, COUNT(*), SUM(input_tokens), SUM(output_tokens), SUM(total_tokens), SUM(cost) FROM usage\"\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:264:\t\t\tSUM(u.input_tokens), \nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:265:\t\t\tSUM(u.output_tokens), \nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:266:\t\t\tSUM(u.total_tokens), \nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:358:\t\t// Rough estimate of tokens (chars / 3)\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:413:\t\t`SELECT strftime('%Y-%m-%d', created_at) as date, COUNT(*), SUM(input_tokens), SUM(output_tokens), SUM(total_tokens), SUM(cost) \nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:639:\t\t`INSERT INTO agents (id, parent_id, type, name, state, current_scope_id, initial_prompt, system_prompt, plan_enabled, sub_agents_enabled, is_internal, working_directory, error_detail, model_config, context_tokens, max_context_tokens, is_compacting, created_at, updated_at)\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:653:\t\t\"SELECT id, parent_id, type, name, state, current_scope_id, initial_prompt, system_prompt, plan_enabled, sub_agents_enabled, is_internal, working_directory, error_detail, model_config, context_tokens, max_context_tokens, is_compacting, created_at, updated_at FROM agents WHERE id = ?\",\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:764:\t_, err := db.Exec(\"UPDATE agents SET context_tokens = ?, max_context_tokens = ?, updated_at = ? WHERE id = ?\", contextTokens, maxContextTokens, now, id)\nworkingdir/familiar/packages/go-backend/internal/storage/sqlite.go:779:\tquery := \"SELECT id, parent_id, type, name, state, current_scope_id, initial_prompt, system_prompt, plan_enabled, sub_agents_enabled, is_internal, working_directory, error_detail, model_config, context_tokens, max_context_tokens, is_compacting, created_at, updated_at FROM agents\"","numLines":127}}
{"parentUuid":"e5f2ecbc-85d6-47bf-be6a-bf9853865300","isSidechain":true,"userType":"external","cwd":"/Users/patrick","sessionId":"3846c6a9-b734-41ac-88fd-9caa47a957a4","version":"2.0.76","gitBranch":"","agentId":"a63ccc0","slug":"wobbly-stirring-garden","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MUvNzXW1XXutmJUiSQn5Yo","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a comprehensive understanding of the codebase. Let me provide the detailed implementation plan:\n\n---\n\n# Implementation Plan: Claude Code/Max OAuth Provider for Familiar\n\n## Overview\n\nThis plan adds a new \"claude-code\" provider to Familiar that uses OAuth 2.0 with PKCE flow for authentication, separate from the existing Anthropic API key provider. The implementation requires changes across the Go backend (OAuth flow, token management, provider) and React frontend (UI for connection status and OAuth trigger).\n\n---\n\n## Part 1: Backend Implementation\n\n### Step 1: Create OAuth Token Types and Manager\n\n**New File: `/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/oauth.go`**\n\nThis file handles OAuth token storage, refresh, and retrieval.\n\n```go\npackage config\n\nimport (\n    \"encoding/json\"\n    \"errors\"\n    \"os\"\n    \"path/filepath\"\n    \"sync\"\n    \"time\"\n)\n\n// ClaudeCodeOAuthToken represents the OAuth token structure\ntype ClaudeCodeOAuthToken struct {\n    AccessToken  string    `json:\"access_token\"`\n    RefreshToken string    `json:\"refresh_token\"`\n    ExpiresAt    time.Time `json:\"expires_at\"`\n    TokenType    string    `json:\"token_type\"`\n    Scopes       []string  `json:\"scopes,omitempty\"`\n}\n\nvar (\n    oauthTokenCache *ClaudeCodeOAuthToken\n    oauthMu         sync.RWMutex\n)\n\n// GetClaudeCodeTokenPath returns the path where OAuth tokens are stored\nfunc GetClaudeCodeTokenPath() string {\n    return filepath.Join(GetConfigDir(), \"claude_code_oauth.json\")\n}\n\n// LoadClaudeCodeToken loads the OAuth token from disk\nfunc LoadClaudeCodeToken() (*ClaudeCodeOAuthToken, error) {\n    oauthMu.RLock()\n    if oauthTokenCache != nil {\n        defer oauthMu.RUnlock()\n        return oauthTokenCache, nil\n    }\n    oauthMu.RUnlock()\n\n    oauthMu.Lock()\n    defer oauthMu.Unlock()\n\n    data, err := os.ReadFile(GetClaudeCodeTokenPath())\n    if err != nil {\n        return nil, err\n    }\n\n    var token ClaudeCodeOAuthToken\n    if err := json.Unmarshal(data, &token); err != nil {\n        return nil, err\n    }\n\n    oauthTokenCache = &token\n    return &token, nil\n}\n\n// SaveClaudeCodeToken saves the OAuth token to disk (encrypted via keychain for refresh token)\nfunc SaveClaudeCodeToken(token *ClaudeCodeOAuthToken) error {\n    oauthMu.Lock()\n    defer oauthMu.Unlock()\n\n    // Store refresh token in keychain for extra security\n    if token.RefreshToken != \"\" {\n        if err := SetKeychainPassword(\"claude-code-refresh-token\", token.RefreshToken); err != nil {\n            return err\n        }\n        // Clear from file storage\n        tokenForFile := *token\n        tokenForFile.RefreshToken = \"\"\n        \n        data, err := json.MarshalIndent(tokenForFile, \"\", \"  \")\n        if err != nil {\n            return err\n        }\n        if err := os.WriteFile(GetClaudeCodeTokenPath(), data, 0600); err != nil {\n            return err\n        }\n    }\n\n    oauthTokenCache = token\n    return nil\n}\n\n// IsClaudeCodeTokenValid checks if current token is valid and not expired\nfunc IsClaudeCodeTokenValid() bool {\n    token, err := LoadClaudeCodeToken()\n    if err != nil || token == nil {\n        return false\n    }\n    // Consider token expired if it expires within 5 minutes\n    return time.Now().Add(5 * time.Minute).Before(token.ExpiresAt)\n}\n\n// ClearClaudeCodeToken removes the OAuth token\nfunc ClearClaudeCodeToken() error {\n    oauthMu.Lock()\n    defer oauthMu.Unlock()\n    \n    oauthTokenCache = nil\n    DeleteKeychainPassword(\"claude-code-refresh-token\")\n    return os.Remove(GetClaudeCodeTokenPath())\n}\n```\n\n### Step 2: Create OAuth Handler\n\n**New File: `/Users/patrick/workingdir/familiar/packages/go-backend/internal/auth/oauth.go`**\n\nThis file implements OAuth 2.0 PKCE flow for Claude Code authentication.\n\n```go\npackage auth\n\nimport (\n    \"context\"\n    \"crypto/rand\"\n    \"crypto/sha256\"\n    \"encoding/base64\"\n    \"encoding/json\"\n    \"errors\"\n    \"fmt\"\n    \"net\"\n    \"net/http\"\n    \"net/url\"\n    \"os/exec\"\n    \"runtime\"\n    \"strings\"\n    \"sync\"\n    \"time\"\n\n    \"github.com/patrick/familiar/packages/go-backend/internal/config\"\n)\n\nconst (\n    ClaudeCodeClientID     = \"9d1c250a-e61b-44d9-88ed-5944d1962f5e\"\n    ClaudeCodeAuthURL      = \"https://console.anthropic.com/oauth/authorize\"\n    ClaudeCodeTokenURL     = \"https://console.anthropic.com/oauth/token\"\n    ClaudeCodeCallbackPort = 54545\n    ClaudeCodeCallbackPath = \"/oauth/callback\"\n    ClaudeCodeScopes       = \"org:create_api_key user:profile user:inference\"\n)\n\ntype OAuthManager struct {\n    mu              sync.Mutex\n    codeVerifier    string\n    state           string\n    pendingCallback chan *OAuthResult\n}\n\ntype OAuthResult struct {\n    Token *config.ClaudeCodeOAuthToken\n    Error error\n}\n\nvar globalOAuthManager = &OAuthManager{}\n\n// GeneratePKCE generates code verifier and code challenge for PKCE\nfunc generatePKCE() (verifier, challenge string, err error) {\n    // Generate random 32-byte verifier\n    bytes := make([]byte, 32)\n    if _, err := rand.Read(bytes); err != nil {\n        return \"\", \"\", err\n    }\n    verifier = base64.RawURLEncoding.EncodeToString(bytes)\n\n    // Create challenge using SHA256\n    hash := sha256.Sum256([]byte(verifier))\n    challenge = base64.RawURLEncoding.EncodeToString(hash[:])\n\n    return verifier, challenge, nil\n}\n\n// GenerateState generates a random state string\nfunc generateState() (string, error) {\n    bytes := make([]byte, 16)\n    if _, err := rand.Read(bytes); err != nil {\n        return \"\", err\n    }\n    return base64.RawURLEncoding.EncodeToString(bytes), nil\n}\n\n// StartOAuthFlow initiates the OAuth flow and returns when complete\nfunc (m *OAuthManager) StartOAuthFlow(ctx context.Context) (*config.ClaudeCodeOAuthToken, error) {\n    m.mu.Lock()\n\n    // Generate PKCE values\n    verifier, challenge, err := generatePKCE()\n    if err != nil {\n        m.mu.Unlock()\n        return nil, fmt.Errorf(\"failed to generate PKCE: %w\", err)\n    }\n    m.codeVerifier = verifier\n\n    // Generate state\n    state, err := generateState()\n    if err != nil {\n        m.mu.Unlock()\n        return nil, fmt.Errorf(\"failed to generate state: %w\", err)\n    }\n    m.state = state\n\n    m.pendingCallback = make(chan *OAuthResult, 1)\n    m.mu.Unlock()\n\n    // Start callback server\n    callbackURL := fmt.Sprintf(\"http://localhost:%d%s\", ClaudeCodeCallbackPort, ClaudeCodeCallbackPath)\n    \n    server, err := m.startCallbackServer(ctx)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to start callback server: %w\", err)\n    }\n    defer server.Shutdown(context.Background())\n\n    // Build authorization URL\n    authURL, err := url.Parse(ClaudeCodeAuthURL)\n    if err != nil {\n        return nil, err\n    }\n    params := authURL.Query()\n    params.Set(\"client_id\", ClaudeCodeClientID)\n    params.Set(\"redirect_uri\", callbackURL)\n    params.Set(\"response_type\", \"code\")\n    params.Set(\"scope\", ClaudeCodeScopes)\n    params.Set(\"state\", state)\n    params.Set(\"code_challenge\", challenge)\n    params.Set(\"code_challenge_method\", \"S256\")\n    authURL.RawQuery = params.Encode()\n\n    // Open browser\n    if err := openBrowser(authURL.String()); err != nil {\n        return nil, fmt.Errorf(\"failed to open browser: %w\", err)\n    }\n\n    // Wait for callback or timeout\n    select {\n    case result := <-m.pendingCallback:\n        if result.Error != nil {\n            return nil, result.Error\n        }\n        return result.Token, nil\n    case <-ctx.Done():\n        return nil, ctx.Err()\n    case <-time.After(5 * time.Minute):\n        return nil, errors.New(\"OAuth flow timed out\")\n    }\n}\n\nfunc (m *OAuthManager) startCallbackServer(ctx context.Context) (*http.Server, error) {\n    listener, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", ClaudeCodeCallbackPort))\n    if err != nil {\n        return nil, err\n    }\n\n    mux := http.NewServeMux()\n    mux.HandleFunc(ClaudeCodeCallbackPath, m.handleCallback)\n\n    server := &http.Server{Handler: mux}\n\n    go func() {\n        if err := server.Serve(listener); err != http.ErrServerClosed {\n            m.pendingCallback <- &OAuthResult{Error: err}\n        }\n    }()\n\n    return server, nil\n}\n\nfunc (m *OAuthManager) handleCallback(w http.ResponseWriter, r *http.Request) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n\n    // Verify state\n    state := r.URL.Query().Get(\"state\")\n    if state != m.state {\n        m.pendingCallback <- &OAuthResult{Error: errors.New(\"invalid state parameter\")}\n        http.Error(w, \"Invalid state\", http.StatusBadRequest)\n        return\n    }\n\n    // Check for error\n    if errParam := r.URL.Query().Get(\"error\"); errParam != \"\" {\n        errDesc := r.URL.Query().Get(\"error_description\")\n        m.pendingCallback <- &OAuthResult{Error: fmt.Errorf(\"OAuth error: %s - %s\", errParam, errDesc)}\n        http.Error(w, \"Authorization failed\", http.StatusBadRequest)\n        return\n    }\n\n    // Get authorization code\n    code := r.URL.Query().Get(\"code\")\n    if code == \"\" {\n        m.pendingCallback <- &OAuthResult{Error: errors.New(\"no authorization code received\")}\n        http.Error(w, \"No code received\", http.StatusBadRequest)\n        return\n    }\n\n    // Exchange code for token\n    token, err := m.exchangeCode(code)\n    if err != nil {\n        m.pendingCallback <- &OAuthResult{Error: err}\n        http.Error(w, \"Token exchange failed\", http.StatusInternalServerError)\n        return\n    }\n\n    // Save token\n    if err := config.SaveClaudeCodeToken(token); err != nil {\n        m.pendingCallback <- &OAuthResult{Error: err}\n        http.Error(w, \"Failed to save token\", http.StatusInternalServerError)\n        return\n    }\n\n    // Success response\n    w.Header().Set(\"Content-Type\", \"text/html\")\n    w.Write([]byte(`\n        <html>\n        <head><title>Authorization Successful</title></head>\n        <body style=\"font-family: system-ui; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #1a1a1a; color: #fff;\">\n            <div style=\"text-align: center;\">\n                <h1>Connected to Claude Code!</h1>\n                <p>You can close this window and return to Familiar.</p>\n            </div>\n        </body>\n        </html>\n    `))\n\n    m.pendingCallback <- &OAuthResult{Token: token}\n}\n\nfunc (m *OAuthManager) exchangeCode(code string) (*config.ClaudeCodeOAuthToken, error) {\n    callbackURL := fmt.Sprintf(\"http://localhost:%d%s\", ClaudeCodeCallbackPort, ClaudeCodeCallbackPath)\n\n    data := url.Values{}\n    data.Set(\"grant_type\", \"authorization_code\")\n    data.Set(\"client_id\", ClaudeCodeClientID)\n    data.Set(\"code\", code)\n    data.Set(\"redirect_uri\", callbackURL)\n    data.Set(\"code_verifier\", m.codeVerifier)\n\n    resp, err := http.Post(ClaudeCodeTokenURL, \"application/x-www-form-urlencoded\", strings.NewReader(data.Encode()))\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return nil, fmt.Errorf(\"token exchange failed with status %d\", resp.StatusCode)\n    }\n\n    var tokenResp struct {\n        AccessToken  string `json:\"access_token\"`\n        RefreshToken string `json:\"refresh_token\"`\n        ExpiresIn    int    `json:\"expires_in\"`\n        TokenType    string `json:\"token_type\"`\n    }\n\n    if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {\n        return nil, err\n    }\n\n    return &config.ClaudeCodeOAuthToken{\n        AccessToken:  tokenResp.AccessToken,\n        RefreshToken: tokenResp.RefreshToken,\n        ExpiresAt:    time.Now().Add(time.Duration(tokenResp.ExpiresIn) * time.Second),\n        TokenType:    tokenResp.TokenType,\n        Scopes:       strings.Split(ClaudeCodeScopes, \" \"),\n    }, nil\n}\n\n// RefreshToken refreshes the access token using the refresh token\nfunc (m *OAuthManager) RefreshToken() (*config.ClaudeCodeOAuthToken, error) {\n    refreshToken := config.GetKeychainPassword(\"claude-code-refresh-token\")\n    if refreshToken == \"\" {\n        return nil, errors.New(\"no refresh token available\")\n    }\n\n    data := url.Values{}\n    data.Set(\"grant_type\", \"refresh_token\")\n    data.Set(\"client_id\", ClaudeCodeClientID)\n    data.Set(\"refresh_token\", refreshToken)\n\n    resp, err := http.Post(ClaudeCodeTokenURL, \"application/x-www-form-urlencoded\", strings.NewReader(data.Encode()))\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return nil, fmt.Errorf(\"token refresh failed with status %d\", resp.StatusCode)\n    }\n\n    var tokenResp struct {\n        AccessToken  string `json:\"access_token\"`\n        RefreshToken string `json:\"refresh_token\"`\n        ExpiresIn    int    `json:\"expires_in\"`\n        TokenType    string `json:\"token_type\"`\n    }\n\n    if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {\n        return nil, err\n    }\n\n    token := &config.ClaudeCodeOAuthToken{\n        AccessToken:  tokenResp.AccessToken,\n        RefreshToken: tokenResp.RefreshToken,\n        ExpiresAt:    time.Now().Add(time.Duration(tokenResp.ExpiresIn) * time.Second),\n        TokenType:    tokenResp.TokenType,\n    }\n\n    if err := config.SaveClaudeCodeToken(token); err != nil {\n        return nil, err\n    }\n\n    return token, nil\n}\n\n// GetValidAccessToken returns a valid access token, refreshing if necessary\nfunc GetValidAccessToken() (string, error) {\n    token, err := config.LoadClaudeCodeToken()\n    if err != nil {\n        return \"\", err\n    }\n\n    // Check if token needs refresh\n    if time.Now().Add(5 * time.Minute).After(token.ExpiresAt) {\n        token, err = globalOAuthManager.RefreshToken()\n        if err != nil {\n            return \"\", err\n        }\n    }\n\n    return token.AccessToken, nil\n}\n\nfunc openBrowser(url string) error {\n    var cmd *exec.Cmd\n    switch runtime.GOOS {\n    case \"darwin\":\n        cmd = exec.Command(\"open\", url)\n    case \"linux\":\n        cmd = exec.Command(\"xdg-open\", url)\n    case \"windows\":\n        cmd = exec.Command(\"rundll32\", \"url.dll,FileProtocolHandler\", url)\n    default:\n        return fmt.Errorf(\"unsupported platform\")\n    }\n    return cmd.Start()\n}\n\n// StartOAuth is the exported function to initiate OAuth flow\nfunc StartOAuth(ctx context.Context) (*config.ClaudeCodeOAuthToken, error) {\n    return globalOAuthManager.StartOAuthFlow(ctx)\n}\n\n// DisconnectClaudeCode clears the OAuth tokens\nfunc DisconnectClaudeCode() error {\n    return config.ClearClaudeCodeToken()\n}\n\n// IsConnected checks if Claude Code is connected\nfunc IsClaudeCodeConnected() bool {\n    return config.IsClaudeCodeTokenValid()\n}\n```\n\n### Step 3: Create Claude Code Provider\n\n**New File: `/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/claude_code.go`**\n\nThis file implements the Claude Code provider that uses OAuth Bearer tokens.\n\n```go\npackage inference\n\nimport (\n    \"bufio\"\n    \"bytes\"\n    \"context\"\n    \"encoding/json\"\n    \"errors\"\n    \"fmt\"\n    \"io\"\n    \"log/slog\"\n    \"net/http\"\n    \"strings\"\n    \"time\"\n\n    \"github.com/patrick/familiar/packages/go-backend/internal/auth\"\n    \"github.com/patrick/familiar/packages/go-backend/pkg/types\"\n)\n\ntype ClaudeCodeProvider struct {\n    baseURL string\n    client  *http.Client\n}\n\nfunc NewClaudeCodeProvider() (*ClaudeCodeProvider, error) {\n    // Verify OAuth token exists and is valid\n    if !auth.IsClaudeCodeConnected() {\n        return nil, errors.New(\"claude code not connected. Please connect via Settings\")\n    }\n\n    return &ClaudeCodeProvider{\n        baseURL: \"https://api.anthropic.com/v1/messages\",\n        client:  &http.Client{Timeout: 300 * time.Second},\n    }, nil\n}\n\nfunc (p *ClaudeCodeProvider) Name() string {\n    return \"claude-code\"\n}\n\nfunc (p *ClaudeCodeProvider) ListModels(ctx context.Context) ([]string, error) {\n    // Claude Code subscription supports specific models\n    return []string{\n        \"claude-sonnet-4-5\",\n        \"claude-opus-4-5\",\n        \"claude-haiku-4-5\",\n    }, nil\n}\n\nfunc (p *ClaudeCodeProvider) GetContextLimit(model string) int {\n    // Claude models generally support 200k tokens\n    return 200000\n}\n\nfunc (p *ClaudeCodeProvider) getAuthHeader() (string, error) {\n    accessToken, err := auth.GetValidAccessToken()\n    if err != nil {\n        return \"\", err\n    }\n    return \"Bearer \" + accessToken, nil\n}\n\n// Reuse the Anthropic message conversion logic\nfunc (p *ClaudeCodeProvider) convertMessages(messages []types.Message) ([]map[string]interface{}, string) {\n    // Same implementation as AnthropicProvider.convertMessages\n    // (Copy the existing logic from anthropic.go)\n    var systemPrompt string\n    var anthropicMessages []map[string]interface{}\n\n    for _, msg := range messages {\n        // ... (same conversion logic as anthropic.go)\n        if msg.Role == \"system\" {\n            if content, ok := msg.Content.(string); ok {\n                systemPrompt += content + \"\\n\"\n            }\n        } else {\n            // ... rest of conversion\n        }\n    }\n    return anthropicMessages, systemPrompt\n}\n\nfunc (p *ClaudeCodeProvider) ChatCompletion(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (*types.ChatResponse, error) {\n    authHeader, err := p.getAuthHeader()\n    if err != nil {\n        return nil, fmt.Errorf(\"authentication failed: %w\", err)\n    }\n\n    baseModel, reasoningLevel := ParseThinkingModel(model)\n    anthropicMessages, systemPrompt := p.convertMessages(messages)\n\n    maxTokens := 4096\n    thinkingBudget := GetAnthropicBudget(reasoningLevel)\n    if thinkingBudget > 0 {\n        maxTokens = thinkingBudget + 8192\n    }\n\n    payload := map[string]interface{}{\n        \"model\":      baseModel,\n        \"messages\":   anthropicMessages,\n        \"max_tokens\": maxTokens,\n    }\n\n    if reasoningLevel != ReasoningNone {\n        payload[\"thinking\"] = map[string]interface{}{\n            \"type\":          \"enabled\",\n            \"budget_tokens\": thinkingBudget,\n        }\n    }\n\n    if systemPrompt != \"\" {\n        payload[\"system\"] = systemPrompt\n    }\n    if tools != nil {\n        payload[\"tools\"] = p.convertTools(tools)\n    }\n\n    body, err := json.Marshal(payload)\n    if err != nil {\n        return nil, err\n    }\n\n    req, err := http.NewRequestWithContext(ctx, \"POST\", p.baseURL, bytes.NewBuffer(body))\n    if err != nil {\n        return nil, err\n    }\n\n    // Key difference: Use Authorization Bearer instead of x-api-key\n    req.Header.Set(\"Authorization\", authHeader)\n    req.Header.Set(\"anthropic-version\", \"2023-06-01\")\n    req.Header.Set(\"anthropic-beta\", \"pdfs-2024-09-25\")\n    req.Header.Set(\"Content-Type\", \"application/json\")\n\n    resp, err := p.client.Do(req)\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode == http.StatusUnauthorized {\n        // Token might be expired, try to refresh\n        if _, refreshErr := auth.GetValidAccessToken(); refreshErr != nil {\n            return nil, fmt.Errorf(\"authentication expired. Please reconnect Claude Code in Settings\")\n        }\n        // Retry with refreshed token\n        return p.ChatCompletion(ctx, messages, model, tools, options)\n    }\n\n    if resp.StatusCode != http.StatusOK {\n        respBody, _ := io.ReadAll(resp.Body)\n        return nil, fmt.Errorf(\"claude code request failed with status %d: %s\", resp.StatusCode, string(respBody))\n    }\n\n    // Parse response (same as Anthropic)\n    var data map[string]interface{}\n    if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {\n        return nil, err\n    }\n\n    // ... (same response parsing as anthropic.go)\n    contentBlocks := data[\"content\"].([]interface{})\n    var contentText string\n    var reasoningText string\n    var toolCalls []types.ToolCall\n\n    for _, b := range contentBlocks {\n        block, ok := b.(map[string]interface{})\n        if !ok {\n            continue\n        }\n        if block[\"type\"] == \"text\" {\n            text, _ := block[\"text\"].(string)\n            contentText += text\n        } else if block[\"type\"] == \"thinking\" {\n            thinking, _ := block[\"thinking\"].(string)\n            reasoningText += thinking\n        } else if block[\"type\"] == \"tool_use\" {\n            id, _ := block[\"id\"].(string)\n            name, _ := block[\"name\"].(string)\n            args, _ := json.Marshal(block[\"input\"])\n            toolCalls = append(toolCalls, types.ToolCall{\n                ID:   id,\n                Type: \"function\",\n                Function: types.ToolFunction{\n                    Name:      name,\n                    Arguments: string(args),\n                },\n            })\n        }\n    }\n\n    usageData, _ := data[\"usage\"].(map[string]interface{})\n    return &types.ChatResponse{\n        Content:    contentText,\n        Reasoning:  reasoningText,\n        ToolCalls:  toolCalls,\n        RawMessage: data,\n        Usage: types.Usage{\n            InputTokens:  int(usageData[\"input_tokens\"].(float64)),\n            OutputTokens: int(usageData[\"output_tokens\"].(float64)),\n        },\n    }, nil\n}\n\nfunc (p *ClaudeCodeProvider) ChatCompletionStream(ctx context.Context, messages []types.Message, model string, tools []interface{}, options map[string]interface{}) (<-chan types.ChatStreamChunk, <-chan error) {\n    chunkCh := make(chan types.ChatStreamChunk)\n    errCh := make(chan error, 1)\n\n    go func() {\n        defer close(chunkCh)\n        defer close(errCh)\n\n        authHeader, err := p.getAuthHeader()\n        if err != nil {\n            errCh <- fmt.Errorf(\"authentication failed: %w\", err)\n            return\n        }\n\n        // ... (same streaming logic as anthropic.go, but with Bearer auth)\n        // Use req.Header.Set(\"Authorization\", authHeader) instead of x-api-key\n    }()\n\n    return chunkCh, errCh\n}\n\nfunc (p *ClaudeCodeProvider) convertTools(tools []interface{}) []interface{} {\n    // Same implementation as AnthropicProvider.convertTools\n    if tools == nil {\n        return nil\n    }\n    // ... copy logic from anthropic.go\n    return tools\n}\n\nfunc (p *ClaudeCodeProvider) Close() error {\n    return nil\n}\n```\n\n### Step 4: Register Provider in Server\n\n**Modify: `/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/server.go`**\n\nAdd the claude-code provider to the `createProvider` switch statement:\n\n```go\nfunc (s *Server) createProvider(providerType string) (inference.Provider, error) {\n    // ... existing code ...\n\n    switch providerType {\n    case \"openrouter\":\n        return inference.NewOpenRouterProvider(\"\", \"\", \"familiar\")\n    case \"anthropic\":\n        return inference.NewAnthropicProvider(\"\")\n    case \"claude-code\":\n        return inference.NewClaudeCodeProvider()  // NEW\n    case \"openai\":\n        return inference.NewOpenAIProvider(\"\", \"\")\n    // ... rest of cases\n    }\n}\n```\n\n### Step 5: Add WebSocket Handlers for OAuth\n\n**Modify: `/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/handlers.go`**\n\nAdd new WebSocket handlers for OAuth flow:\n\n```go\ncase \"connect_claude_code\":\n    go func() {\n        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)\n        defer cancel()\n        \n        token, err := auth.StartOAuth(ctx)\n        if err != nil {\n            s.globalBroadcast(map[string]interface{}{\n                \"type\":  \"claude_code_connection_failed\",\n                \"error\": err.Error(),\n            })\n            return\n        }\n        \n        s.globalBroadcast(map[string]interface{}{\n            \"type\":   \"claude_code_connected\",\n            \"status\": \"connected\",\n        })\n    }()\n    resp.Payload = map[string]string{\"status\": \"oauth_started\"}\n\ncase \"disconnect_claude_code\":\n    if err := auth.DisconnectClaudeCode(); err != nil {\n        resp.Status = \"error\"\n        resp.Error = err.Error()\n    } else {\n        resp.Payload = map[string]string{\"status\": \"disconnected\"}\n    }\n\ncase \"get_claude_code_status\":\n    isConnected := auth.IsClaudeCodeConnected()\n    resp.Payload = map[string]interface{}{\n        \"connected\": isConnected,\n    }\n```\n\nAlso update `get_api_keys` handler to include claude-code:\n\n```go\ncase \"get_api_keys\":\n    cfg, _ := config.LoadConfig()\n    providers := []string{\"openrouter\", \"anthropic\", \"claude-code\", \"openai\", \"gemini\", \"ollama\", \"lmstudio\"}\n    // ... rest of handler\n    \n    for _, p := range providers {\n        var configured bool\n        switch p {\n        case \"claude-code\":\n            configured = auth.IsClaudeCodeConnected()  // Special handling for OAuth\n        case \"ollama\", \"lmstudio\":\n            configured = true\n        default:\n            configured = config.GetKeychainPassword(p+\"-api-key\") != \"\"\n        }\n        // ... rest\n    }\n```\n\n### Step 6: Update Config Defaults\n\n**Modify: `/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/server.go`**\n\nUpdate `formatConfigResponse` to include claude-code in default models:\n\n```go\ndefaults := map[string]map[string][]string{\n    // ... existing\n    \"claude-code\": {\n        \"chat\": {\n            \"claude-haiku-4-5\",\n            \"claude-sonnet-4-5\",\n            \"claude-opus-4-5\",\n        },\n    },\n    // ... rest\n}\n```\n\n---\n\n## Part 2: Frontend Implementation\n\n### Step 7: Update API Module\n\n**Modify: `/Users/patrick/workingdir/familiar/packages/desktop/ui/src/lib/api.ts`**\n\nAdd new API methods:\n\n```typescript\n// Add new methods to the api object\nconnectClaudeCode: () => globalWS.send({ type: 'connect_claude_code' }),\ndisconnectClaudeCode: () => globalWS.send({ type: 'disconnect_claude_code' }),\ngetClaudeCodeStatus: (): Promise<{ connected: boolean }> => \n    globalWS.send({ type: 'get_claude_code_status' }),\n```\n\n### Step 8: Update Settings View\n\n**Modify: `/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SettingsView.tsx`**\n\nAdd Claude Code special handling in the provider list and configuration panel:\n\n1. Add state for Claude Code connection:\n```typescript\nconst [claudeCodeConnecting, setClaudeCodeConnecting] = useState(false);\n```\n\n2. Add query for Claude Code status:\n```typescript\nconst { data: claudeCodeStatus, refetch: refetchClaudeCodeStatus } = useQuery({\n    queryKey: ['claudeCodeStatus'],\n    queryFn: () => api.getClaudeCodeStatus(),\n    refetchInterval: 5000,\n});\n```\n\n3. Add WebSocket listener for connection events:\n```typescript\nuseEffect(() => {\n    const handleMessage = (event: MessageEvent) => {\n        const data = JSON.parse(event.data);\n        if (data.type === 'claude_code_connected') {\n            setClaudeCodeConnecting(false);\n            refetchClaudeCodeStatus();\n            triggerSuccess();\n        } else if (data.type === 'claude_code_connection_failed') {\n            setClaudeCodeConnecting(false);\n            console.error('Claude Code connection failed:', data.error);\n        }\n    };\n    // ... add listener\n}, []);\n```\n\n4. Add special UI for claude-code provider (instead of API key input, show Connect button):\n```tsx\n{editingProvider === 'claude-code' && (\n    <div className=\"p-3 border border-accent/20 bg-accent/5\">\n        {claudeCodeStatus?.connected ? (\n            <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center gap-2\">\n                    <div className=\"w-2 h-2 rounded-full bg-status-success\" />\n                    <span className=\"text-[10px] font-black text-status-success uppercase tracking-widest\">\n                        Connected to Claude Code\n                    </span>\n                </div>\n                <button\n                    onClick={async () => {\n                        await api.disconnectClaudeCode();\n                        refetchClaudeCodeStatus();\n                    }}\n                    className=\"text-[9px] text-text-tertiary/40 hover:text-status-error transition-all uppercase font-black\"\n                >\n                    [Disconnect]\n                </button>\n            </div>\n        ) : (\n            <div className=\"space-y-3\">\n                <div className=\"flex items-center gap-2\">\n                    <div className=\"w-2 h-2 rounded-full bg-accent/50\" />\n                    <span className=\"text-[10px] font-black text-accent/70 uppercase tracking-widest\">\n                        OAuth Authentication Required\n                    </span>\n                </div>\n                <button\n                    onClick={async () => {\n                        setClaudeCodeConnecting(true);\n                        await api.connectClaudeCode();\n                    }}\n                    disabled={claudeCodeConnecting}\n                    className={clsx(\n                        \"w-full py-2 text-accent hover:text-accent-hover font-black text-[10px] uppercase tracking-widest border border-accent/20 transition-all\",\n                        claudeCodeConnecting && \"opacity-50 animate-pulse\"\n                    )}\n                >\n                    {claudeCodeConnecting ? 'Opening Browser...' : 'Connect with Anthropic Account'}\n                </button>\n                <p className=\"text-[8px] text-text-tertiary/40 italic\">\n                    Uses your Claude Code / Claude Max subscription. Opens browser for secure login.\n                </p>\n            </div>\n        )}\n    </div>\n)}\n```\n\n5. Add claude-code to the provider list rendering:\n```typescript\nconst standardProviders = ['openrouter', 'anthropic', 'claude-code', 'openai', 'gemini', 'ollama', 'lmstudio'];\n```\n\n---\n\n## Part 3: Testing Considerations\n\n### Manual Testing Checklist\n\n1. **OAuth Flow**:\n   - Verify browser opens to Anthropic login page\n   - Verify callback is received and tokens are stored\n   - Verify success message displays in UI\n\n2. **Token Refresh**:\n   - Wait for token to near expiry\n   - Make API call and verify automatic refresh\n\n3. **Provider Selection**:\n   - Verify claude-code appears in provider dropdown\n   - Verify connection status shows correctly\n   - Verify agents can be created with claude-code provider\n\n4. **Error Handling**:\n   - Test OAuth cancellation\n   - Test network errors during token exchange\n   - Test invalid/expired tokens\n\n---\n\n## Implementation Order\n\n1. **Phase 1: Backend Core** (2-3 hours)\n   - Create `oauth.go` for token management\n   - Create `auth/oauth.go` for OAuth flow\n   - Create `claude_code.go` provider\n\n2. **Phase 2: Backend Integration** (1-2 hours)\n   - Update `server.go` with provider registration\n   - Update `handlers.go` with WebSocket handlers\n   - Update config defaults\n\n3. **Phase 3: Frontend** (1-2 hours)\n   - Update `api.ts` with new methods\n   - Update `SettingsView.tsx` with Claude Code UI\n\n4. **Phase 4: Testing** (1-2 hours)\n   - Manual end-to-end testing\n   - Error case testing\n\n---\n\n### Critical Files for Implementation\n\n- `/Users/patrick/workingdir/familiar/packages/go-backend/internal/inference/anthropic.go` - Reference for Anthropic API structure and message conversion (reuse convertMessages and convertTools methods)\n- `/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/server.go` - Provider factory (createProvider) where claude-code must be registered\n- `/Users/patrick/workingdir/familiar/packages/go-backend/cmd/server/handlers.go` - WebSocket handlers for OAuth flow and API key status\n- `/Users/patrick/workingdir/familiar/packages/go-backend/internal/config/keychain.go` - Pattern for secure credential storage (use for refresh tokens)\n- `/Users/patrick/workingdir/familiar/packages/desktop/ui/src/components/Agent/SettingsView.tsx` - Provider configuration UI where OAuth connect button must be added"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13174,"cache_read_input_tokens":123181,"cache_creation":{"ephemeral_5m_input_tokens":13174,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWkRSen9hRfVEjyhSh3hw","type":"assistant","uuid":"a551fb7b-0a9a-4736-b0c2-7eb86646a72a","timestamp":"2026-01-03T12:14:07.023Z"}
