package config

import (
	"strings"
	"testing"
)

func TestReplaceVaultSecrets(t *testing.T) {
	// Enable mock mode for testing
	originalMockMode := MockMode
	MockMode = true
	defer func() {
		MockMode = originalMockMode
		// Clear mock vault after tests
		mockMu.Lock()
		mockVault = make(map[string]string)
		mockMu.Unlock()
	}()

	t.Run("single secret replacement", func(t *testing.T) {
		SetMockVaultSecret("api_key", "secret123")
		result, err := ReplaceVaultSecrets("api_key={{vault:api_key}}")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		expected := "api_key=secret123"
		if result != expected {
			t.Errorf("expected %s, got %s", expected, result)
		}
	})

	t.Run("multiple secrets replacement", func(t *testing.T) {
		SetMockVaultSecret("api_key", "secret123")
		SetMockVaultSecret("db_password", "pass456")
		result, err := ReplaceVaultSecrets("key={{vault:api_key}} pass={{vault:db_password}}")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		expected := "key=secret123 pass=pass456"
		if result != expected {
			t.Errorf("expected %s, got %s", expected, result)
		}
	})

	t.Run("secret with underscores and hyphens", func(t *testing.T) {
		SetMockVaultSecret("my-api_key", "test-value")
		result, err := ReplaceVaultSecrets("value={{vault:my-api_key}}")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		expected := "value=test-value"
		if result != expected {
			t.Errorf("expected %s, got %s", expected, result)
		}
	})

	t.Run("missing secret returns error", func(t *testing.T) {
		// Clear mock vault
		mockMu.Lock()
		mockVault = make(map[string]string)
		mockMu.Unlock()

		result, err := ReplaceVaultSecrets("key={{vault:missing_secret}}")
		if err == nil {
			t.Error("expected error for missing secret")
		}
		if !strings.Contains(err.Error(), "missing_secret") {
			t.Errorf("error should mention missing secret, got: %v", err)
		}
		if result != "key={{vault:missing_secret}}" {
			t.Errorf("expected original text when secret missing, got %s", result)
		}
	})

	t.Run("no vault placeholders", func(t *testing.T) {
		result, err := ReplaceVaultSecrets("plain text without secrets")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		expected := "plain text without secrets"
		if result != expected {
			t.Errorf("expected %s, got %s", expected, result)
		}
	})

	t.Run("empty string", func(t *testing.T) {
		result, err := ReplaceVaultSecrets("")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if result != "" {
			t.Errorf("expected empty string, got %s", result)
		}
	})

	t.Run("mixed valid and invalid secrets", func(t *testing.T) {
		SetMockVaultSecret("valid", "value123")
		result, err := ReplaceVaultSecrets("valid={{vault:valid}} invalid={{vault:invalid}}")
		if err == nil {
			t.Error("expected error for invalid secret")
		}
		// Should replace valid but keep invalid placeholder
		if !strings.Contains(result, "value123") {
			t.Error("expected valid secret to be replaced")
		}
		if !strings.Contains(result, "{{vault:invalid}}") {
			t.Error("expected invalid placeholder to remain")
		}
	})
}

func TestMaskSecrets(t *testing.T) {
	t.Run("single secret masking", func(t *testing.T) {
		text := "password is secret123"
		secrets := []string{"secret123"}
		result := MaskSecrets(text, secrets)
		expected := "password is ********"
		if result != expected {
			t.Errorf("expected %s, got %s", expected, result)
		}
	})

	t.Run("multiple secrets masking", func(t *testing.T) {
		text := "key1=secret1 key2=secret2"
		secrets := []string{"secret1", "secret2"}
		result := MaskSecrets(text, secrets)
		expected := "key1=******** key2=********"
		if result != expected {
			t.Errorf("expected %s, got %s", expected, result)
		}
	})

	t.Run("empty secrets list", func(t *testing.T) {
		text := "password is secret123"
		secrets := []string{}
		result := MaskSecrets(text, secrets)
		if result != text {
			t.Errorf("expected original text, got %s", result)
		}
	})

	t.Run("nil secrets list", func(t *testing.T) {
		text := "password is secret123"
		var secrets []string
		result := MaskSecrets(text, secrets)
		if result != text {
			t.Errorf("expected original text, got %s", result)
		}
	})

	t.Run("empty secret string", func(t *testing.T) {
		text := "password is secret123"
		secrets := []string{""}
		result := MaskSecrets(text, secrets)
		if result != text {
			t.Errorf("expected original text when secret is empty, got %s", result)
		}
	})

	t.Run("secret not in text", func(t *testing.T) {
		text := "password is secret123"
		secrets := []string{"other_secret"}
		result := MaskSecrets(text, secrets)
		if result != text {
			t.Errorf("expected original text when secret not found, got %s", result)
		}
	})

	t.Run("secret appears multiple times", func(t *testing.T) {
		text := "secret123 and secret123 again"
		secrets := []string{"secret123"}
		result := MaskSecrets(text, secrets)
		expected := "******** and ******** again"
		if result != expected {
			t.Errorf("expected %s, got %s", expected, result)
		}
	})

	t.Run("partial match should mask substring", func(t *testing.T) {
		text := "password is secret12345"
		secrets := []string{"secret123"}
		result := MaskSecrets(text, secrets)
		// Should mask because the secret is a substring (security requirement)
		expected := "password is ********45"
		if result != expected {
			t.Errorf("expected %s, got %s", expected, result)
		}
	})
}

func TestGetVaultSecretValues(t *testing.T) {
	// Enable mock mode for testing
	originalMockMode := MockMode
	MockMode = true
	defer func() {
		MockMode = originalMockMode
		// Clear mock vault after tests
		mockMu.Lock()
		mockVault = make(map[string]string)
		mockMu.Unlock()
	}()

	t.Run("single secret retrieval", func(t *testing.T) {
		SetMockVaultSecret("api_key", "secret123")
		values := GetVaultSecretValues([]string{"api_key"})
		if len(values) != 1 {
			t.Fatalf("expected 1 value, got %d", len(values))
		}
		if values[0] != "secret123" {
			t.Errorf("expected secret123, got %s", values[0])
		}
	})

	t.Run("multiple secrets retrieval", func(t *testing.T) {
		SetMockVaultSecret("key1", "value1")
		SetMockVaultSecret("key2", "value2")
		values := GetVaultSecretValues([]string{"key1", "key2"})
		if len(values) != 2 {
			t.Fatalf("expected 2 values, got %d", len(values))
		}
		// Order may vary, so check both
		if values[0] != "value1" && values[0] != "value2" {
			t.Errorf("unexpected value: %s", values[0])
		}
		if values[1] != "value1" && values[1] != "value2" {
			t.Errorf("unexpected value: %s", values[1])
		}
	})

	t.Run("missing secret excluded", func(t *testing.T) {
		SetMockVaultSecret("key1", "value1")
		// Clear key2
		mockMu.Lock()
		delete(mockVault, "key2")
		mockMu.Unlock()

		values := GetVaultSecretValues([]string{"key1", "key2"})
		if len(values) != 1 {
			t.Fatalf("expected 1 value (missing key2 excluded), got %d", len(values))
		}
		if values[0] != "value1" {
			t.Errorf("expected value1, got %s", values[0])
		}
	})

	t.Run("all secrets missing", func(t *testing.T) {
		// Clear mock vault
		mockMu.Lock()
		mockVault = make(map[string]string)
		mockMu.Unlock()

		values := GetVaultSecretValues([]string{"missing1", "missing2"})
		if len(values) != 0 {
			t.Fatalf("expected 0 values, got %d", len(values))
		}
	})

	t.Run("empty names list", func(t *testing.T) {
		values := GetVaultSecretValues([]string{})
		if len(values) != 0 {
			t.Fatalf("expected 0 values, got %d", len(values))
		}
	})
}







