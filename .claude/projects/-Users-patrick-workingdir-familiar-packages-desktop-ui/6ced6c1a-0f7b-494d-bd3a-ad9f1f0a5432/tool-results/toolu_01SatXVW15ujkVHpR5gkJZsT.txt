     1→import { render, screen, fireEvent, waitFor } from '@testing-library/react';
     2→import { Unibar } from './Unibar';
     3→import { describe, it, expect, vi, beforeEach } from 'vitest';
     4→import { MemoryRouter } from 'react-router-dom';
     5→import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
     6→import { useAgents } from '../context/AgentContext';
     7→import { api } from '../lib/api';
     8→
     9→// Mock useAgents hook
    10→vi.mock('../context/AgentContext', () => ({
    11→  useAgents: vi.fn(),
    12→}));
    13→
    14→// Mock api
    15→vi.mock('../lib/api', () => ({
    16→  api: {
    17→    getConfig: vi.fn().mockResolvedValue({ ui: { hotkeys: { toggle_unibar: 'Cmd+K' } } }),
    18→    getApiKeys: vi.fn().mockResolvedValue([]),
    19→  },
    20→}));
    21→
    22→const queryClient = new QueryClient({
    23→  defaultOptions: {
    24→    queries: { retry: false },
    25→  },
    26→});
    27→
    28→describe('Unibar Component', () => {
    29→  const mockSelectAgent = vi.fn();
    30→  const mockCreateAgent = vi.fn();
    31→
    32→  beforeEach(() => {
    33→    vi.mocked(useAgents).mockReturnValue({
    34→      agents: {},
    35→      selectAgent: mockSelectAgent,
    36→      createAgent: mockCreateAgent,
    37→    } as any);
    38→  });
    39→
    40→  it('renders correctly in closed state', async () => {
    41→    render(
    42→      <QueryClientProvider client={queryClient}>
    43→        <MemoryRouter initialEntries={['/']}>
    44→          <Unibar />
    45→        </MemoryRouter>
    46→      </QueryClientProvider>
    47→    );
    48→
    49→    await waitFor(() => {
    50→      expect(screen.getByText('Fleet')).toBeInTheDocument();
    51→    });
    52→    expect(screen.getByText('Skills')).toBeInTheDocument();
    53→  });
    54→
    55→  it('opens on keyboard shortcut', async () => {
    56→    render(
    57→      <QueryClientProvider client={queryClient}>
    58→        <MemoryRouter>
    59→          <Unibar />
    60→        </MemoryRouter>
    61→      </QueryClientProvider>
    62→    );
    63→
    64→    await waitFor(() => {
    65→      expect(vi.mocked(api.getConfig)).toHaveBeenCalled();
    66→    });
    67→
    68→    await waitFor(() => {
    69→      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    70→      const event = new KeyboardEvent('keydown', {
    71→        key: 'K',
    72→        metaKey: isMac,
    73→        ctrlKey: !isMac,
    74→        bubbles: true,
    75→        cancelable: true,
    76→      } as any);
    77→      Object.defineProperty(event, 'metaKey', { value: isMac, configurable: true });
    78→      Object.defineProperty(event, 'ctrlKey', { value: !isMac, configurable: true });
    79→      window.dispatchEvent(event);
    80→    });
    81→
    82→    await waitFor(() => {
    83→      expect(screen.getByPlaceholderText('search agents or commands...')).toBeInTheDocument();
    84→    }, { timeout: 3000 });
    85→  });
    86→
    87→  it('filters commands based on query', async () => {
    88→    render(
    89→      <QueryClientProvider client={queryClient}>
    90→        <MemoryRouter>
    91→          <Unibar />
    92→        </MemoryRouter>
    93→      </QueryClientProvider>
    94→    );
    95→
    96→    await waitFor(() => {
    97→      expect(vi.mocked(api.getConfig)).toHaveBeenCalled();
    98→    });
    99→
   100→    await waitFor(() => {
   101→      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
   102→      const event = new KeyboardEvent('keydown', {
   103→        key: 'K',
   104→        metaKey: isMac,
   105→        ctrlKey: !isMac,
   106→        bubbles: true,
   107→        cancelable: true,
   108→      } as any);
   109→      Object.defineProperty(event, 'metaKey', { value: isMac, configurable: true });
   110→      Object.defineProperty(event, 'ctrlKey', { value: !isMac, configurable: true });
   111→      window.dispatchEvent(event);
   112→    });
   113→
   114→    await waitFor(() => {
   115→      expect(screen.getByPlaceholderText('search agents or commands...')).toBeInTheDocument();
   116→    }, { timeout: 3000 });
   117→
   118→    const input = screen.getByPlaceholderText('search agents or commands...');
   119→    fireEvent.change(input, { target: { value: 'settings' } });
   120→    
   121→    await waitFor(() => {
   122→      expect(screen.getByText('System Settings')).toBeInTheDocument();
   123→    });
   124→    expect(screen.queryByText('Tools & Skills')).not.toBeInTheDocument();
   125→  });
   126→});
   127→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
