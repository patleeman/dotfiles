import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { globalWS } from './websocket';
import * as backend from './backend';

// Mock backend module
vi.mock('./backend', () => ({
  getBackendPort: vi.fn(),
}));

describe('GlobalWebSocket', () => {
  let mockWebSocket: any;
  let wsInstances: any[];

  beforeEach(() => {
    // Reset the globalWS singleton state before each test
    globalWS._reset();
    wsInstances = [];
    vi.mocked(backend.getBackendPort).mockResolvedValue(8080);

    // Mock WebSocket
    mockWebSocket = class MockWebSocket {
      url: string;
      readyState: number = WebSocket.CONNECTING;
      onopen: ((event: Event) => void) | null = null;
      onmessage: ((event: MessageEvent) => void) | null = null;
      onclose: ((event: CloseEvent) => void) | null = null;
      onerror: ((event: Event) => void) | null = null;

      constructor(url: string) {
        this.url = url;
        wsInstances.push(this);
        // Simulate async connection
        setTimeout(() => {
          this.readyState = WebSocket.OPEN;
          if (this.onopen) {
            this.onopen(new Event('open'));
          }
        }, 10);
      }

      send(_data: string) {
        // Mock send
      }

      close() {
        this.readyState = WebSocket.CLOSED;
        if (this.onclose) {
          this.onclose(new CloseEvent('close'));
        }
      }
    };

    (globalThis as any).WebSocket = mockWebSocket;
  });

  afterEach(() => {
    vi.clearAllMocks();
    globalWS._reset();
    wsInstances = [];
  });

  describe('connection', () => {
    it('connects to WebSocket', async () => {
      const ws = await globalWS.connect();
      expect(ws).toBeDefined();
      expect(wsInstances.length).toBe(1);
      expect(wsInstances[0].url).toBe('ws://localhost:8080/api/ws');
    });

    it('returns same connection on subsequent calls', async () => {
      const ws1 = await globalWS.connect();
      const ws2 = await globalWS.connect();
      expect(ws1).toBe(ws2);
      expect(wsInstances.length).toBe(1);
    });

    it('uses correct port from backend', async () => {
      vi.mocked(backend.getBackendPort).mockResolvedValue(9999);
      await globalWS.connect();
      expect(wsInstances[0].url).toBe('ws://localhost:9999/api/ws');
    });
  });

  describe('send', () => {
    it('sends message and receives response', async () => {
      let sentData: any = null;
      const mockSend = vi.fn((_data: string) => {
        sentData = JSON.parse(_data);
        // Simulate response
        setTimeout(() => {
          const response = {
            request_id: sentData.request_id,
            status: 'ok',
            payload: { result: 'success' },
          };
          if (wsInstances[0].onmessage) {
            wsInstances[0].onmessage({
              data: JSON.stringify(response),
            } as MessageEvent);
          }
        }, 10);
      });

      wsInstances[0] = {
        ...wsInstances[0],
        send: mockSend,
        readyState: WebSocket.OPEN,
      };

      await globalWS.connect();

      const result = await globalWS.send({
        type: 'test_request',
        payload: { test: 'data' },
      });

      expect(sentData.type).toBe('test_request');
      expect(sentData.payload.test).toBe('data');
      expect(sentData.request_id).toBeDefined();
      expect(result.result).toBe('success');
    });

    it('handles error responses', async () => {
      const mockSend = vi.fn((_data: string) => {
        const sentData = JSON.parse(_data);
        setTimeout(() => {
          const response = {
            request_id: sentData.request_id,
            status: 'error',
            error: 'Something went wrong',
          };
          if (wsInstances[0].onmessage) {
            wsInstances[0].onmessage({
              data: JSON.stringify(response),
            } as MessageEvent);
          }
        }, 10);
      });

      wsInstances[0] = {
        ...wsInstances[0],
        send: mockSend,
        readyState: WebSocket.OPEN,
      };

      await globalWS.connect();

      await expect(
        globalWS.send({
          type: 'test_request',
        })
      ).rejects.toThrow('Something went wrong');
    });

    it('generates unique request IDs', async () => {
      const requestIds = new Set<string>();
      const mockSend = vi.fn((_data: string) => {
        const sentData = JSON.parse(_data);
        requestIds.add(sentData.request_id);
        setTimeout(() => {
          const response = {
            request_id: sentData.request_id,
            status: 'ok',
            payload: {},
          };
          if (wsInstances[0].onmessage) {
            wsInstances[0].onmessage({
              data: JSON.stringify(response),
            } as MessageEvent);
          }
        }, 10);
      });

      wsInstances[0] = {
        ...wsInstances[0],
        send: mockSend,
        readyState: WebSocket.OPEN,
      };

      await globalWS.connect();

      await globalWS.send({ type: 'request1' });
      await globalWS.send({ type: 'request2' });
      await globalWS.send({ type: 'request3' });

      expect(requestIds.size).toBe(3);
    });
  });

  describe('message listeners', () => {
    it('notifies message listeners', async () => {
      const listener = vi.fn();
      const unsubscribe = globalWS.addMessageListener(listener);

      await globalWS.connect();

      const testMessage = { type: 'stream_chunk', content: 'test' };
      if (wsInstances[0].onmessage) {
        wsInstances[0].onmessage({
          data: JSON.stringify(testMessage),
        } as MessageEvent);
      }

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(listener).toHaveBeenCalledWith(testMessage);

      unsubscribe();
    });

    it('allows removing message listeners', async () => {
      const listener = vi.fn();
      const unsubscribe = globalWS.addMessageListener(listener);

      await globalWS.connect();

      unsubscribe();

      const testMessage = { type: 'stream_chunk', content: 'test' };
      if (wsInstances[0].onmessage) {
        wsInstances[0].onmessage({
          data: JSON.stringify(testMessage),
        } as MessageEvent);
      }

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(listener).not.toHaveBeenCalled();
    });

    it('supports multiple message listeners', async () => {
      const listener1 = vi.fn();
      const listener2 = vi.fn();

      globalWS.addMessageListener(listener1);
      globalWS.addMessageListener(listener2);

      await globalWS.connect();

      const testMessage = { type: 'stream_chunk', content: 'test' };
      if (wsInstances[0].onmessage) {
        wsInstances[0].onmessage({
          data: JSON.stringify(testMessage),
        } as MessageEvent);
      }

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(listener1).toHaveBeenCalledWith(testMessage);
      expect(listener2).toHaveBeenCalledWith(testMessage);
    });
  });

  describe('status listeners', () => {
    it('notifies status listeners on connection', async () => {
      const statuses: string[] = [];
      const listener = (status: 'connecting' | 'open' | 'closed' | 'error') => {
        statuses.push(status);
      };

      globalWS.addStatusListener(listener);
      await globalWS.connect();

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(statuses).toContain('connecting');
      expect(statuses).toContain('open');
    });

    it('notifies status listeners on close', async () => {
      const statuses: string[] = [];
      const listener = (status: 'connecting' | 'open' | 'closed' | 'error') => {
        statuses.push(status);
      };

      globalWS.addStatusListener(listener);
      await globalWS.connect();

      await new Promise((resolve) => setTimeout(resolve, 20));

      if (wsInstances[0].onclose) {
        wsInstances[0].onclose(new CloseEvent('close'));
      }

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(statuses).toContain('closed');
    });

    it('allows removing status listeners', () => {
      const listener = vi.fn();
      const unsubscribe = globalWS.addStatusListener(listener);

      unsubscribe();

      // Status changes should not call removed listener
      // (we can't easily test this without triggering actual status changes)
      expect(unsubscribe).toBeDefined();
    });
  });

  describe('reconnection', () => {
    it('reconnects after close', async () => {
      await globalWS.connect();
      await new Promise((resolve) => setTimeout(resolve, 20));

      const initialInstance = wsInstances[0];

      // Close connection
      if (initialInstance.onclose) {
        initialInstance.onclose(new CloseEvent('close'));
      }

      // Wait for reconnection attempt
      await new Promise((resolve) => setTimeout(resolve, 1100));

      // Should have attempted reconnection (new instance or same instance reopened)
      expect(wsInstances.length).toBeGreaterThanOrEqual(1);
    });

    it('handles connection errors', async () => {
      const statuses: string[] = [];
      const listener = (status: 'connecting' | 'open' | 'closed' | 'error') => {
        statuses.push(status);
      };

      globalWS.addStatusListener(listener);

      // Create a WebSocket that will error
      const errorWs = new mockWebSocket('ws://localhost:8080/api/ws');
      errorWs.readyState = WebSocket.CLOSED;

      if (errorWs.onerror) {
        errorWs.onerror(new Event('error'));
      }

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(statuses).toContain('error');
    });
  });

  describe('pending requests on close', () => {
    it('rejects pending requests when connection closes', async () => {
      const mockSend = vi.fn((_data: string) => {
        // Don't send response, simulate connection close
        setTimeout(() => {
          if (wsInstances[0].onclose) {
            wsInstances[0].onclose(new CloseEvent('close'));
          }
        }, 10);
      });

      wsInstances[0] = {
        ...wsInstances[0],
        send: mockSend,
        readyState: WebSocket.OPEN,
      };

      await globalWS.connect();

      await expect(
        globalWS.send({
          type: 'test_request',
        })
      ).rejects.toThrow();
    });
  });

  describe('error handling', () => {
    it('handles invalid JSON in messages', async () => {
      const listener = vi.fn();
      globalWS.addMessageListener(listener);

      await globalWS.connect();

      // Send invalid JSON
      if (wsInstances[0].onmessage) {
        try {
          wsInstances[0].onmessage({
            data: 'invalid json',
          } as MessageEvent);
        } catch (e) {
          // Expected to throw
        }
      }

      // Should not crash
      expect(listener).not.toHaveBeenCalled();
    });
  });
});

